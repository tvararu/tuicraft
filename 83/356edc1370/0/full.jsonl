{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-28T23:38:35.076Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","content":"/superpowers:using-superpowers"}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-28T23:38:35.077Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.sh"},"parentToolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","toolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","timestamp":"2026-02-28T23:38:35.062Z","uuid":"49106347-17f5-4ed6-af18-70af500f4407"}
{"parentUuid":"49106347-17f5-4ed6-af18-70af500f4407","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"entire hooks claude-code session-start"},"parentToolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","toolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","timestamp":"2026-02-28T23:38:35.062Z","uuid":"77e0a16d-b192-4cb4-ba53-71b385b826db"}
{"parentUuid":"77e0a16d-b192-4cb4-ba53-71b385b826db","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"'${CLAUDE_PLUGIN_ROOT}/hooks/run-hook.cmd' session-start"},"parentToolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","toolUseID":"6695b6d9-6787-46d6-93ba-bc4466134562","timestamp":"2026-02-28T23:38:35.063Z","uuid":"8af782ff-e9bb-46ae-9a5c-331b81e5d6a1"}
{"parentUuid":"8af782ff-e9bb-46ae-9a5c-331b81e5d6a1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":"<command-message>superpowers:using-superpowers</command-message>\n<command-name>/superpowers:using-superpowers</command-name>"},"uuid":"44fea9aa-9adc-4d98-87b9-843d9992aa1d","timestamp":"2026-02-28T23:38:35.089Z"}
{"parentUuid":"44fea9aa-9adc-4d98-87b9-843d9992aa1d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"Base directory for this skill: /home/openclaw/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/using-superpowers\n\n<EXTREMELY-IMPORTANT>\nIf you think there is even a 1% chance a skill might apply to what you are doing, you ABSOLUTELY MUST invoke the skill.\n\nIF A SKILL APPLIES TO YOUR TASK, YOU DO NOT HAVE A CHOICE. YOU MUST USE IT.\n\nThis is not negotiable. This is not optional. You cannot rationalize your way out of this.\n</EXTREMELY-IMPORTANT>\n\n## How to Access Skills\n\n**In Claude Code:** Use the `Skill` tool. When you invoke a skill, its content is loaded and presented to you—follow it directly. Never use the Read tool on skill files.\n\n**In other environments:** Check your platform's documentation for how skills are loaded.\n\n# Using Skills\n\n## The Rule\n\n**Invoke relevant or requested skills BEFORE any response or action.** Even a 1% chance a skill might apply means that you should invoke the skill to check. If an invoked skill turns out to be wrong for the situation, you don't need to use it.\n\n```dot\ndigraph skill_flow {\n    \"User message received\" [shape=doublecircle];\n    \"About to EnterPlanMode?\" [shape=doublecircle];\n    \"Already brainstormed?\" [shape=diamond];\n    \"Invoke brainstorming skill\" [shape=box];\n    \"Might any skill apply?\" [shape=diamond];\n    \"Invoke Skill tool\" [shape=box];\n    \"Announce: 'Using [skill] to [purpose]'\" [shape=box];\n    \"Has checklist?\" [shape=diamond];\n    \"Create TodoWrite todo per item\" [shape=box];\n    \"Follow skill exactly\" [shape=box];\n    \"Respond (including clarifications)\" [shape=doublecircle];\n\n    \"About to EnterPlanMode?\" -> \"Already brainstormed?\";\n    \"Already brainstormed?\" -> \"Invoke brainstorming skill\" [label=\"no\"];\n    \"Already brainstormed?\" -> \"Might any skill apply?\" [label=\"yes\"];\n    \"Invoke brainstorming skill\" -> \"Might any skill apply?\";\n\n    \"User message received\" -> \"Might any skill apply?\";\n    \"Might any skill apply?\" -> \"Invoke Skill tool\" [label=\"yes, even 1%\"];\n    \"Might any skill apply?\" -> \"Respond (including clarifications)\" [label=\"definitely not\"];\n    \"Invoke Skill tool\" -> \"Announce: 'Using [skill] to [purpose]'\";\n    \"Announce: 'Using [skill] to [purpose]'\" -> \"Has checklist?\";\n    \"Has checklist?\" -> \"Create TodoWrite todo per item\" [label=\"yes\"];\n    \"Has checklist?\" -> \"Follow skill exactly\" [label=\"no\"];\n    \"Create TodoWrite todo per item\" -> \"Follow skill exactly\";\n}\n```\n\n## Red Flags\n\nThese thoughts mean STOP—you're rationalizing:\n\n| Thought | Reality |\n|---------|---------|\n| \"This is just a simple question\" | Questions are tasks. Check for skills. |\n| \"I need more context first\" | Skill check comes BEFORE clarifying questions. |\n| \"Let me explore the codebase first\" | Skills tell you HOW to explore. Check first. |\n| \"I can check git/files quickly\" | Files lack conversation context. Check for skills. |\n| \"Let me gather information first\" | Skills tell you HOW to gather information. |\n| \"This doesn't need a formal skill\" | If a skill exists, use it. |\n| \"I remember this skill\" | Skills evolve. Read current version. |\n| \"This doesn't count as a task\" | Action = task. Check for skills. |\n| \"The skill is overkill\" | Simple things become complex. Use it. |\n| \"I'll just do this one thing first\" | Check BEFORE doing anything. |\n| \"This feels productive\" | Undisciplined action wastes time. Skills prevent this. |\n| \"I know what that means\" | Knowing the concept ≠ using the skill. Invoke it. |\n\n## Skill Priority\n\nWhen multiple skills could apply, use this order:\n\n1. **Process skills first** (brainstorming, debugging) - these determine HOW to approach the task\n2. **Implementation skills second** (frontend-design, mcp-builder) - these guide execution\n\n\"Let's build X\" → brainstorming first, then implementation skills.\n\"Fix this bug\" → debugging first, then domain-specific skills.\n\n## Skill Types\n\n**Rigid** (TDD, debugging): Follow exactly. Don't adapt away discipline.\n\n**Flexible** (patterns): Adapt principles to context.\n\nThe skill itself tells you which.\n\n## User Instructions\n\nInstructions say WHAT, not HOW. \"Add X\" or \"Fix Y\" doesn't mean skip workflows.\n"}]},"isMeta":true,"uuid":"fd44d43e-2b0e-48cf-a1ae-6f1f155525db","timestamp":"2026-02-28T23:38:35.089Z"}
{"parentUuid":"fd44d43e-2b0e-48cf-a1ae-6f1f155525db","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_01EnxS5DtCBe61PpNbCt6wYT","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nReady to help with tuicraft. What would you like to work on?"}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":7360,"cache_read_input_tokens":19120,"output_tokens":20,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":7360,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbM9UFrJAnKcK9mBzBjP","type":"assistant","uuid":"6089a57c-9911-44c9-89fd-d93c13b57e72","timestamp":"2026-02-28T23:38:37.852Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-28T23:38:51.472Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","content":"Add text emote support: /e and /emote slash commands. This sends a chat message with CHAT_MSG_EMOTE type. Also handle receiving emotes from other players. Look at how say/yell work and follow the same pattern. This is tiny — branch, implement with full test coverage, and open a PR. Use feat: prefix for commits."}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-28T23:38:51.473Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd"}
{"parentUuid":"6089a57c-9911-44c9-89fd-d93c13b57e72","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.sh"},"parentToolUseID":"f756f861-4aab-4009-9225-0ec958614109","toolUseID":"f756f861-4aab-4009-9225-0ec958614109","timestamp":"2026-02-28T23:38:51.457Z","uuid":"1a66deb9-b029-49c1-b17d-6e023d73e636"}
{"parentUuid":"1a66deb9-b029-49c1-b17d-6e023d73e636","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"entire hooks claude-code session-start"},"parentToolUseID":"f756f861-4aab-4009-9225-0ec958614109","toolUseID":"f756f861-4aab-4009-9225-0ec958614109","timestamp":"2026-02-28T23:38:51.457Z","uuid":"7db0e757-560d-4ca5-b2bb-4880c5a81745"}
{"parentUuid":"7db0e757-560d-4ca5-b2bb-4880c5a81745","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"'${CLAUDE_PLUGIN_ROOT}/hooks/run-hook.cmd' session-start"},"parentToolUseID":"f756f861-4aab-4009-9225-0ec958614109","toolUseID":"f756f861-4aab-4009-9225-0ec958614109","timestamp":"2026-02-28T23:38:51.458Z","uuid":"04049db2-d5db-483c-ba19-62828e70ced9"}
{"parentUuid":"04049db2-d5db-483c-ba19-62828e70ced9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":"Add text emote support: /e and /emote slash commands. This sends a chat message with CHAT_MSG_EMOTE type. Also handle receiving emotes from other players. Look at how say/yell work and follow the same pattern. This is tiny — branch, implement with full test coverage, and open a PR. Use feat: prefix for commits."},"uuid":"1e6719c5-a3c8-4e94-b99b-bafa8bcaea29","timestamp":"2026-02-28T23:38:51.477Z","permissionMode":"bypassPermissions"}
{"parentUuid":"1e6719c5-a3c8-4e94-b99b-bafa8bcaea29","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_01UV74tursh2C2y4LU1k44Ja","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to add text emote support (/e and /emote slash commands) to the tuicraft project. Let me invoke the relevant skills first before doing anything else.\n\nThis is a feature implementation task. Let me check which skills apply:\n1. brainstorming - creative work, new feature\n2. feature-dev - guided feature development\n3. typescript-style - will be writing TypeScript\n4. test-driven-development - need full test coverage\n\nThe user said \"This is tiny\" and gave clear instructions. Let me invoke brainstorming first since it's a process skill, then follow through.\n\nActually, the user gave very specific instructions: branch, implement with full test coverage, open a PR. \n\nI need to invoke the brainstorming skill first since the skill system requires it before any creative work, and also the TDD skill since they want full test coverage.","signature":"EqoKCkYICxgCKkA1W2WMCQTFriDhYgF4QGWGn6xii/kxU0CZbrcwn0TZXf/ChkP0NmKx3vxsMfx/fWxEOaqbKR2SH2s2d+wNzJK+EgyZ08ioMhg3C/GV31IaDAuUwVr/yPaVLkjJSiIwQr2GbWn0jJST+YHSCMVyqgBv16PRtBL1IBr664LKMHDD3r6k6rKlge5fcld6A1TpKpEJEuG3wOresnRXVqnZnQ1Cxm0K+LUy3CvMF8rf0gLepgKQx+38USf8yJkdjNIBBdBjpkKNa3+saeFYJzXwNoKHmUrPHoTKwNy1aYjZ6RvT/RNvxmKjJuJA9d9syVWJU4a192ecPIBdg7/0JDcTTWETyWFgPaDhv3Bw4xajTk8MH/ZghzhIn5Bhsilq3IetKoLsD5NlANQJpIs41t/i/lM2zQ/tzF05gAM0qKX7JuaBeyIaE+hlWAGkTvAbJ6dN7v0uVuVnLB+8n5Zp2FTI+jvf1vEpjFV5RB8Sq1nwFjPyoslRNd4Z5SwnzsALOGw1c52rKk8aoO/W2bGoe02ApEvpdzeQkFVdY4ARP0kUx7nPhrzIVAfasLhgRw6RhP1yN+PbaWB4J/gCCCuJRaMc1z/17BLnwPgrntT1kcZjo//hVqzCHqqsvGz1zGGrRvY471V06vnefGleO8iQB2Kl9ovQgSIxtafteEV/fxHv5dkJoGewA9izHtL4JVjuLg3o4bIRvv9MQQlY4faH5vWxBm2ZselaExqI+au8RgF0IzIzhhgNFUztOKYApPK6Htv++lDh0uTXGG1pbfQjaJOvI/5GUJvFH5AYFYhRw3ZdjL0rB1J2L7CEE7hr1+6gWJgccVA3PHsi/OJET1RQKbeZLgOeW0FE/UHZj8o6hIin2lwPdp/ZXITUBHYrWnK6xT2gAs4fcCu+aKm17A3V7xqyYVXHHzOp062m81qWGXSeqwN0xBee003uYojjvdldk1R6Ea+OKJjXE/r0wMRE2M/s05gK228LWfSf017EXcZM5ju+ZxLyyD6v57qIaAxNG7rsEU5PUC+HIQEY+OMTKNHeleUVsUWGdSrvcpC9HghZHhRVL/yG/Kt50TdSbUY6SmC43BDWbKiGaFyntD4ox/Ty+X+Pe7/Kr2sl/RK6nnZMilNEsDUb+e5Hmj/OpkgPj4TKTjSGgME9pzXfW0vyuhLJlhKCU8fpcZP7YQL6+7hrvJ+1CIII+6O5ii/Uvm9U/EYERxr99quSt2mpq/4TuELnLEj3kI8Kvf8Ddof0JEkVWT7SwaZYPfAdj+9KikPSrx520l2khYAhHlI6ZLb8Jd4hAhEbhKUzMXTnnqfbwPCynn6zaJG97nvNz0j84Qsg/GnEAFLoBQwsgDWpTt9Ld6LUEF4lnERs0kyl3/Lgbk64RwvWJM9hJwn/33ErxnkIdO7RCXN2c61AKxUAkCSPfTeaZJZqiZH0FI9Ul1nim7xcOWQtWcbqg0XmYFvdEDweySKydaC1l2rAQV2p2De6UNSAzRjgOiwWr+PYlcXXxmH/oY8x/UD2vjsh91H+H/sPdenu5scEjIyrK5ZPO2ywFSdwl2AIZhruIIoTDUobX3J8Hp7Clsu1H1x46A5BWm1PBrFH1jmFCt0P1pqDin9w+UtU4EjQi/WOMoh12BoISbcrRHZA6sAmq3ljXM2eWQ44olqvPpuyoRznT1N4eYlD/TMCtex5vQSlPmzBktp3Yx8LBeNXe66MiCq4/scGa9DS/GoipjdAooiOi+Nj68HsppJgX5bod8EYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7462,"cache_read_input_tokens":19120,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7462},"output_tokens":11,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMAgECxDisAtQXmAVwi","type":"assistant","uuid":"fa111279-e184-46db-afb6-811a516b0f49","timestamp":"2026-02-28T23:39:00.120Z"}
{"parentUuid":"fa111279-e184-46db-afb6-811a516b0f49","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_01UV74tursh2C2y4LU1k44Ja","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GA2rQYU1TQ2QGEkhxzisR1","name":"Skill","input":{"skill":"superpowers:brainstorming"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7462,"cache_read_input_tokens":19120,"output_tokens":349,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":7462,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMAgECxDisAtQXmAVwi","type":"assistant","uuid":"8910cb3a-44c3-4eef-950f-1ec2b44c6173","timestamp":"2026-02-28T23:39:00.147Z"}
{"parentUuid":"8910cb3a-44c3-4eef-950f-1ec2b44c6173","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01GA2rQYU1TQ2QGEkhxzisR1","content":"Launching skill: superpowers:brainstorming"}]},"uuid":"58c89e75-fa2d-4ea1-bf5f-2eec414d5b7e","timestamp":"2026-02-28T23:39:00.158Z","toolUseResult":{"success":true,"commandName":"superpowers:brainstorming"},"sourceToolAssistantUUID":"8910cb3a-44c3-4eef-950f-1ec2b44c6173"}
{"parentUuid":"58c89e75-fa2d-4ea1-bf5f-2eec414d5b7e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"Base directory for this skill: /home/openclaw/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/brainstorming\n\n# Brainstorming Ideas Into Designs\n\n## Overview\n\nHelp turn ideas into fully formed designs and specs through natural collaborative dialogue.\n\nStart by understanding the current project context, then ask questions one at a time to refine the idea. Once you understand what you're building, present the design and get user approval.\n\n<HARD-GATE>\nDo NOT invoke any implementation skill, write any code, scaffold any project, or take any implementation action until you have presented a design and the user has approved it. This applies to EVERY project regardless of perceived simplicity.\n</HARD-GATE>\n\n## Anti-Pattern: \"This Is Too Simple To Need A Design\"\n\nEvery project goes through this process. A todo list, a single-function utility, a config change — all of them. \"Simple\" projects are where unexamined assumptions cause the most wasted work. The design can be short (a few sentences for truly simple projects), but you MUST present it and get approval.\n\n## Checklist\n\nYou MUST create a task for each of these items and complete them in order:\n\n1. **Explore project context** — check files, docs, recent commits\n2. **Ask clarifying questions** — one at a time, understand purpose/constraints/success criteria\n3. **Propose 2-3 approaches** — with trade-offs and your recommendation\n4. **Present design** — in sections scaled to their complexity, get user approval after each section\n5. **Write design doc** — save to `docs/plans/YYYY-MM-DD-<topic>-design.md` and commit\n6. **Transition to implementation** — invoke writing-plans skill to create implementation plan\n\n## Process Flow\n\n```dot\ndigraph brainstorming {\n    \"Explore project context\" [shape=box];\n    \"Ask clarifying questions\" [shape=box];\n    \"Propose 2-3 approaches\" [shape=box];\n    \"Present design sections\" [shape=box];\n    \"User approves design?\" [shape=diamond];\n    \"Write design doc\" [shape=box];\n    \"Invoke writing-plans skill\" [shape=doublecircle];\n\n    \"Explore project context\" -> \"Ask clarifying questions\";\n    \"Ask clarifying questions\" -> \"Propose 2-3 approaches\";\n    \"Propose 2-3 approaches\" -> \"Present design sections\";\n    \"Present design sections\" -> \"User approves design?\";\n    \"User approves design?\" -> \"Present design sections\" [label=\"no, revise\"];\n    \"User approves design?\" -> \"Write design doc\" [label=\"yes\"];\n    \"Write design doc\" -> \"Invoke writing-plans skill\";\n}\n```\n\n**The terminal state is invoking writing-plans.** Do NOT invoke frontend-design, mcp-builder, or any other implementation skill. The ONLY skill you invoke after brainstorming is writing-plans.\n\n## The Process\n\n**Understanding the idea:**\n- Check out the current project state first (files, docs, recent commits)\n- Ask questions one at a time to refine the idea\n- Prefer multiple choice questions when possible, but open-ended is fine too\n- Only one question per message - if a topic needs more exploration, break it into multiple questions\n- Focus on understanding: purpose, constraints, success criteria\n\n**Exploring approaches:**\n- Propose 2-3 different approaches with trade-offs\n- Present options conversationally with your recommendation and reasoning\n- Lead with your recommended option and explain why\n\n**Presenting the design:**\n- Once you believe you understand what you're building, present the design\n- Scale each section to its complexity: a few sentences if straightforward, up to 200-300 words if nuanced\n- Ask after each section whether it looks right so far\n- Cover: architecture, components, data flow, error handling, testing\n- Be ready to go back and clarify if something doesn't make sense\n\n## After the Design\n\n**Documentation:**\n- Write the validated design to `docs/plans/YYYY-MM-DD-<topic>-design.md`\n- Use elements-of-style:writing-clearly-and-concisely skill if available\n- Commit the design document to git\n\n**Implementation:**\n- Invoke the writing-plans skill to create a detailed implementation plan\n- Do NOT invoke any other skill. writing-plans is the next step.\n\n## Key Principles\n\n- **One question at a time** - Don't overwhelm with multiple questions\n- **Multiple choice preferred** - Easier to answer than open-ended when possible\n- **YAGNI ruthlessly** - Remove unnecessary features from all designs\n- **Explore alternatives** - Always propose 2-3 approaches before settling\n- **Incremental validation** - Present design, get approval before moving on\n- **Be flexible** - Go back and clarify when something doesn't make sense\n"}]},"isMeta":true,"uuid":"2c785ea1-c926-443e-a692-d5956941df68","timestamp":"2026-02-28T23:39:00.157Z","sourceToolUseID":"toolu_01GA2rQYU1TQ2QGEkhxzisR1"}
{"parentUuid":"2c785ea1-c926-443e-a692-d5956941df68","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_01SepfvcEHij38jXJob5pigh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ta4Dj2MzgwbDQtM2Zecbux","name":"TodoWrite","input":{"todos":[{"content":"Explore project context for emote support","status":"in_progress","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"pending","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1505,"cache_read_input_tokens":26582,"output_tokens":205,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1505,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMBK6k4uJEmpEbfMg7B","type":"assistant","uuid":"13061d7d-941c-4bb2-a999-33294f082fab","timestamp":"2026-02-28T23:39:04.567Z"}
{"parentUuid":"13061d7d-941c-4bb2-a999-33294f082fab","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ta4Dj2MzgwbDQtM2Zecbux","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"5bb25a72-df5c-4a4c-ac6c-aa8657853820","timestamp":"2026-02-28T23:39:04.569Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Explore project context for emote support","status":"in_progress","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"pending","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"sourceToolAssistantUUID":"13061d7d-941c-4bb2-a999-33294f082fab"}
{"parentUuid":"5bb25a72-df5c-4a4c-ac6c-aa8657853820","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_0125nxq9eHiUdNjmuE1322fx","type":"message","role":"assistant","content":[{"type":"text","text":"Let me explore how say/yell currently work so I can understand the pattern for adding emotes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":241,"cache_read_input_tokens":28087,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":241},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMBdzoB1HmaTrtoyWEj","type":"assistant","uuid":"b9b9a278-657c-4f1c-8d24-05b87b736d15","timestamp":"2026-02-28T23:39:07.643Z"}
{"parentUuid":"b9b9a278-657c-4f1c-8d24-05b87b736d15","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_0125nxq9eHiUdNjmuE1322fx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017kQje5QZv5GbbW7xV7c5Lw","name":"Agent","input":{"description":"Explore say/yell chat pattern","subagent_type":"Explore","prompt":"Explore how say/yell slash commands work in this tuicraft codebase. I need to understand the full pattern for adding a new chat message type (text emote / CHAT_MSG_EMOTE). Find:\n\n1. Where slash commands like /say and /yell are defined and dispatched\n2. How CMSG_MESSAGECHAT is constructed and sent (the outbound chat packet)\n3. How incoming chat messages (SMSG_MESSAGECHAT) are parsed and which chat types are handled\n4. The chat type enum/constants (where CHAT_MSG_SAY, CHAT_MSG_YELL etc are defined)\n5. How incoming say/yell messages surface as events (event handlers, session log, etc.)\n6. Any test files for the above\n\nBe very thorough - read the actual implementations, not just file names. I need to understand the data flow end-to-end."},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":241,"cache_read_input_tokens":28087,"output_tokens":323,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":241,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMBdzoB1HmaTrtoyWEj","type":"assistant","uuid":"fc2b0ca7-5cf9-41ae-b205-4f7b96b2bd01","timestamp":"2026-02-28T23:39:13.828Z"}
{"parentUuid":"fc2b0ca7-5cf9-41ae-b205-4f7b96b2bd01","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017kQje5QZv5GbbW7xV7c5Lw","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have a complete understanding. Let me create a comprehensive summary of the chat system architecture.\n\n## Summary: Chat System Architecture in Tuicraft\n\nI've thoroughly explored the tuicraft codebase and mapped the complete data flow for chat commands. Here's the full end-to-end pattern:\n\n### 1. **Slash Command Parsing** (`/say`, `/yell`, etc.)\n\n**File:** `/home/openclaw/code/tuicraft/src/ui/tui.ts` (lines 41-145)\n\nThe `parseCommand()` function handles slash command parsing:\n- `/s` or `/say <message>` → `{ type: \"say\", message }`\n- `/y` or `/yell <message>` → `{ type: \"yell\", message }`\n- `/g` or `/guild <message>` → `{ type: \"guild\", message }`\n- `/p` or `/party <message>` → `{ type: \"party\", message }`\n- `/w` or `/whisper <target> <message>` → `{ type: \"whisper\", target, message }`\n- `/raid <message>` → `{ type: \"raid\", message }`\n- `/1` through `/N` (channel numbers) → `{ type: \"channel\", target: channelNumber, message }`\n- `/e` or `/emote <message>` → Currently returns `{ type: \"unimplemented\", feature: \"Text emotes\" }` (line 135-136)\n\n**Unimplemented:** Text emotes are explicitly marked as unimplemented in the parser.\n\n---\n\n### 2. **Command Dispatch** (IPC Layer)\n\n**File:** `/home/openclaw/code/tuicraft/src/daemon/commands.ts` (lines 63-188)\n\nThe `parseIpcCommand()` function converts both slash commands and UPPERCASE commands to IPC commands:\n- Supports both `/say hello` and `SAY hello` formats\n- Maps to `IpcCommand` type (lines 34-61)\n- Unimplemented commands map to `{ type: \"unimplemented\", feature: \"...\" }`\n\n**Dispatch function:** `dispatchCommand()` (lines 213-355) routes commands to `WorldHandle` methods:\n```typescript\ncase \"say\":\n  handle.sendSay(cmd.message);\n  writeLines(socket, [\"OK\"]);\n  return false;\n```\n\n---\n\n### 3. **Chat Type Constants**\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/opcodes.ts` (lines 644-661)\n\n```typescript\nexport const ChatType = {\n  SYSTEM: 0x00,\n  SAY: 0x01,\n  PARTY: 0x02,\n  RAID: 0x03,\n  GUILD: 0x04,\n  OFFICER: 0x05,\n  YELL: 0x06,\n  WHISPER: 0x07,\n  WHISPER_INFORM: 0x09,\n  EMOTE: 0x0a,  // <-- Text emote chat type\n  CHANNEL: 0x11,\n  RAID_LEADER: 0x27,\n  RAID_WARNING: 0x28,\n  BATTLEGROUND: 0x2c,\n  BATTLEGROUND_LEADER: 0x2d,\n  PARTY_LEADER: 0x33,\n};\n```\n\n**Language constants** (lines 633-637):\n```typescript\nexport const Language = {\n  UNIVERSAL: 0x00,\n  ORCISH: 0x01,\n  COMMON: 0x07,\n};\n```\n\n**Opcodes** (lines 160-162):\n```typescript\nCMSG_MESSAGE_CHAT: 0x095,  // Client → Server\nSMSG_MESSAGE_CHAT: 0x096,  // Server → Client\nSMSG_GM_MESSAGECHAT: 0x3b3,  // GM messages\n```\n\n---\n\n### 4. **Building & Sending CMSG_MESSAGECHAT** (Outbound)\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts` (lines 70-84)\n\n```typescript\nexport function buildChatMessage(\n  type: number,          // ChatType.SAY, ChatType.YELL, etc.\n  language: number,      // Language.COMMON, Language.ORCISH\n  message: string,\n  target?: string,       // For whispers and channels\n): Uint8Array {\n  const w = new PacketWriter();\n  w.uint32LE(type);      // Chat type\n  w.uint32LE(language);  // Language\n  if (type === ChatType.WHISPER || type === ChatType.CHANNEL) {\n    w.cString(target ?? \"\");  // Target name or channel name\n  }\n  w.cString(message);    // The message text (null-terminated)\n  return w.finish();\n}\n```\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/client.ts` (lines 1107-1154)\n\nThe `WorldHandle` implementation:\n```typescript\nsendSay(message) {\n  conn.lastChatMode = { type: \"say\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.SAY, lang, message),\n  );\n},\nsendYell(message) {\n  conn.lastChatMode = { type: \"yell\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.YELL, lang, message),\n  );\n},\nsendGuild(message) {\n  conn.lastChatMode = { type: \"guild\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.GUILD, lang, message),\n  );\n},\nsendParty(message) {\n  conn.lastChatMode = { type: \"party\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.PARTY, lang, message),\n  );\n},\nsendRaid(message) {\n  conn.lastChatMode = { type: \"raid\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.RAID, lang, message),\n  );\n},\nsendChannel(channel, message) {\n  conn.lastChatMode = { type: \"channel\", channel };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n  );\n},\n```\n\n**Key detail:** All chat sending methods update `conn.lastChatMode` to track the current chat context, used by `sendInCurrentMode()` (lines 1169-1194).\n\n---\n\n### 5. **Parsing SMSG_MESSAGECHAT** (Incoming)\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts` (lines 30-68)\n\n```typescript\nexport type ChatMessage = {\n  type: number;           // ChatType value\n  language: number;\n  senderGuidLow: number;\n  senderGuidHigh: number;\n  message: string;\n  channel?: string;       // For channel messages\n  senderName?: string;    // For GM messages (isGm=true)\n};\n\nexport function parseChatMessage(r: PacketReader, isGm = false): ChatMessage {\n  const type = r.uint8();\n  const language = r.uint32LE();\n  const senderGuidLow = r.uint32LE();\n  const senderGuidHigh = r.uint32LE();\n  r.uint32LE();\n\n  let senderName: string | undefined;\n  if (isGm) {\n    const nameLen = r.uint32LE();\n    senderName = new TextDecoder().decode(r.bytes(nameLen));\n  }\n\n  let channel: string | undefined;\n  if (type === ChatType.CHANNEL) {\n    channel = r.cString();\n  }\n\n  r.uint32LE();\n  r.uint32LE();\n  const messageLength = r.uint32LE();\n  const messageBytes = r.bytes(messageLength);\n  const end =\n    messageLength > 0 && messageBytes[messageLength - 1] === 0\n      ? messageLength - 1\n      : messageLength;\n  const message = new TextDecoder().decode(messageBytes.subarray(0, end));\n  if (r.remaining > 0) r.uint8();\n\n  return {\n    type,\n    language,\n    senderGuidLow,\n    senderGuidHigh,\n    message,\n    channel,\n    senderName,\n  };\n}\n```\n\n**Important detail:** Server messages include a trailing null terminator that gets stripped (lines 52-56).\n\n---\n\n### 6. **Chat Message Handling & Event Callbacks**\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/client.ts` (lines 442-485)\n\n```typescript\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    // System messages (no sender)\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    // Sender name is cached\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  // Queue message pending name lookup\n  if (!conn.pendingMessages.has(raw.senderGuidLow)) {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  } else {\n    conn.pendingMessages.get(raw.senderGuidLow)!.push(raw);\n  }\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,        // ChatType value\n    sender: name,          // Player or NPC name\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n```\n\n**Opcode registration** (line 1006):\n```typescript\nconn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n  handleChatMessage(conn, r),\n);\n```\n\n---\n\n### 7. **Message Formatting for Display & Logging**\n\n**File:** `/home/openclaw/code/tuicraft/src/ui/tui.ts` (lines 147-213)\n\n**Text formatting** (lines 164-181):\n```typescript\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  // ... etc\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n```\n\n**JSON formatting** (lines 183-213):\n```typescript\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  // ... etc\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n```\n\n---\n\n### 8. **Event Callbacks & Session Logging**\n\n**File:** `/home/openclaw/code/tuicraft/src/daemon/commands.ts` (lines 483-491)\n\n```typescript\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n```\n\nChat messages flow through the event ring buffer and session log:\n- **Ring buffer:** In-memory buffer for reading recent events via IPC\n- **Session log:** JSON-per-line file log with timestamps\n\n**File:** `/home/openclaw/code/tuicraft/src/lib/session-log.ts` (lines 1-23)\n\n```typescript\nexport type LogEntry = {\n  type: string;      // \"SAY\", \"YELL\", \"EMOTE\", etc.\n  sender: string;\n  message: string;\n  channel?: string;  // For channel messages\n};\n\nexport class SessionLog {\n  async append(entry: LogEntry): Promise<void> {\n    const line = JSON.stringify({ ...entry, timestamp: Date.now() }) + \"\\n\";\n    await appendFile(this.path, line);\n  }\n}\n```\n\n---\n\n### 9. **Test Coverage**\n\n**Protocol tests:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.test.ts`\n- Tests for SAY, WHISPER, CHANNEL, SYSTEM, GM message parsing\n- Tests for buildChatMessage for all types\n\n**Client tests:** `/home/openclaw/code/tuicraft/src/wow/client.test.ts` (lines 675-768)\n- `sendSay` → receives SAY echo\n- `sendYell` → receives YELL echo\n- `sendGuild` → receives GUILD echo\n- `sendParty` → receives PARTY echo\n- `sendRaid` → receives RAID echo\n- `sendChannel` → receives CHANNEL echo\n\n**Command dispatch tests:** `/home/openclaw/code/tuicraft/src/daemon/commands.test.ts` (lines 397-486)\n- Tests for IPC command parsing\n- Tests for dispatchCommand routing to WorldHandle methods\n- Tests for message formatting and logging\n\n**Mock server:** `/home/openclaw/code/tuicraft/src/test/mock-world-server.ts` (lines 173-196)\n- `handleMessageChat()` echoes CMSG_MESSAGE_CHAT back as SMSG_MESSAGE_CHAT\n\n---\n\n## **Pattern for Adding CHAT_MSG_EMOTE Support**\n\nBased on the codebase architecture, adding text emote support would follow this pattern:\n\n### **Step 1: UI Parser** (tui.ts)\n- Update `parseCommand()` to handle `/e` and `/emote` commands, returning `{ type: \"emote\", message }`\n\n### **Step 2: IPC Layer** (commands.ts)\n- Add emote to `IpcCommand` type\n- Update `parseIpcCommand()` to recognize emote commands\n- Update `dispatchCommand()` to handle `case \"emote\"`\n\n### **Step 3: WorldHandle** (client.ts)\n- Add `sendEmote(message: string)` method\n- Call `buildChatMessage(ChatType.EMOTE, lang, message)`\n- Update `lastChatMode` tracking\n\n### **Step 4: Already in place**\n- `ChatType.EMOTE: 0x0a` exists in opcodes.ts ✓\n- `buildChatMessage()` already handles EMOTE (no special target needed) ✓\n- `parseChatMessage()` already handles EMOTE (no channel parsing) ✓\n- `CHAT_TYPE_LABELS[\"emote\"]` and `JSON_TYPE_LABELS[\"EMOTE\"]` exist ✓\n- `onChatMessage()` formatting works for any type ✓\n- Session logging works for any chat type ✓\n\n### **Test additions needed**\n- Add emote command parsing test to tui.test.ts\n- Add `sendEmote()` test to client.test.ts (echoed back as EMOTE type)\n- Update mock-world-server.ts if needed (should already work)\n- Add dispatchCommand test for emote type\n\n---\n\n## **File Location Summary**\n\n| Component | File | Lines |\n|-----------|------|-------|\n| Slash command parser | `/src/ui/tui.ts` | 41-145 |\n| IPC command dispatcher | `/src/daemon/commands.ts` | 63-355 |\n| Chat type constants | `/src/wow/protocol/opcodes.ts` | 644-661 |\n| Outbound packet builder | `/src/wow/protocol/chat.ts` | 70-84 |\n| WorldHandle methods | `/src/wow/client.ts` | 1107-1154 |\n| Inbound packet parser | `/src/wow/protocol/chat.ts` | 30-68 |\n| Message handler | `/src/wow/client.ts` | 442-485 |\n| Message formatting | `/src/ui/tui.ts` | 147-213 |\n| Event callback | `/src/daemon/commands.ts` | 483-491 |\n| Session logging | `/src/lib/session-log.ts` | 1-23 |"},{"type":"text","text":"agentId: a1cf6eb7e03a9628b (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 77792\ntool_uses: 30\nduration_ms: 83428</usage>"}]}]},"uuid":"d2e3e035-e6cc-449a-b312-23cf3edca3d7","timestamp":"2026-02-28T23:40:37.277Z","toolUseResult":{"status":"completed","prompt":"Explore how say/yell slash commands work in this tuicraft codebase. I need to understand the full pattern for adding a new chat message type (text emote / CHAT_MSG_EMOTE). Find:\n\n1. Where slash commands like /say and /yell are defined and dispatched\n2. How CMSG_MESSAGECHAT is constructed and sent (the outbound chat packet)\n3. How incoming chat messages (SMSG_MESSAGECHAT) are parsed and which chat types are handled\n4. The chat type enum/constants (where CHAT_MSG_SAY, CHAT_MSG_YELL etc are defined)\n5. How incoming say/yell messages surface as events (event handlers, session log, etc.)\n6. Any test files for the above\n\nBe very thorough - read the actual implementations, not just file names. I need to understand the data flow end-to-end.","agentId":"a1cf6eb7e03a9628b","content":[{"type":"text","text":"Perfect! Now I have a complete understanding. Let me create a comprehensive summary of the chat system architecture.\n\n## Summary: Chat System Architecture in Tuicraft\n\nI've thoroughly explored the tuicraft codebase and mapped the complete data flow for chat commands. Here's the full end-to-end pattern:\n\n### 1. **Slash Command Parsing** (`/say`, `/yell`, etc.)\n\n**File:** `/home/openclaw/code/tuicraft/src/ui/tui.ts` (lines 41-145)\n\nThe `parseCommand()` function handles slash command parsing:\n- `/s` or `/say <message>` → `{ type: \"say\", message }`\n- `/y` or `/yell <message>` → `{ type: \"yell\", message }`\n- `/g` or `/guild <message>` → `{ type: \"guild\", message }`\n- `/p` or `/party <message>` → `{ type: \"party\", message }`\n- `/w` or `/whisper <target> <message>` → `{ type: \"whisper\", target, message }`\n- `/raid <message>` → `{ type: \"raid\", message }`\n- `/1` through `/N` (channel numbers) → `{ type: \"channel\", target: channelNumber, message }`\n- `/e` or `/emote <message>` → Currently returns `{ type: \"unimplemented\", feature: \"Text emotes\" }` (line 135-136)\n\n**Unimplemented:** Text emotes are explicitly marked as unimplemented in the parser.\n\n---\n\n### 2. **Command Dispatch** (IPC Layer)\n\n**File:** `/home/openclaw/code/tuicraft/src/daemon/commands.ts` (lines 63-188)\n\nThe `parseIpcCommand()` function converts both slash commands and UPPERCASE commands to IPC commands:\n- Supports both `/say hello` and `SAY hello` formats\n- Maps to `IpcCommand` type (lines 34-61)\n- Unimplemented commands map to `{ type: \"unimplemented\", feature: \"...\" }`\n\n**Dispatch function:** `dispatchCommand()` (lines 213-355) routes commands to `WorldHandle` methods:\n```typescript\ncase \"say\":\n  handle.sendSay(cmd.message);\n  writeLines(socket, [\"OK\"]);\n  return false;\n```\n\n---\n\n### 3. **Chat Type Constants**\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/opcodes.ts` (lines 644-661)\n\n```typescript\nexport const ChatType = {\n  SYSTEM: 0x00,\n  SAY: 0x01,\n  PARTY: 0x02,\n  RAID: 0x03,\n  GUILD: 0x04,\n  OFFICER: 0x05,\n  YELL: 0x06,\n  WHISPER: 0x07,\n  WHISPER_INFORM: 0x09,\n  EMOTE: 0x0a,  // <-- Text emote chat type\n  CHANNEL: 0x11,\n  RAID_LEADER: 0x27,\n  RAID_WARNING: 0x28,\n  BATTLEGROUND: 0x2c,\n  BATTLEGROUND_LEADER: 0x2d,\n  PARTY_LEADER: 0x33,\n};\n```\n\n**Language constants** (lines 633-637):\n```typescript\nexport const Language = {\n  UNIVERSAL: 0x00,\n  ORCISH: 0x01,\n  COMMON: 0x07,\n};\n```\n\n**Opcodes** (lines 160-162):\n```typescript\nCMSG_MESSAGE_CHAT: 0x095,  // Client → Server\nSMSG_MESSAGE_CHAT: 0x096,  // Server → Client\nSMSG_GM_MESSAGECHAT: 0x3b3,  // GM messages\n```\n\n---\n\n### 4. **Building & Sending CMSG_MESSAGECHAT** (Outbound)\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts` (lines 70-84)\n\n```typescript\nexport function buildChatMessage(\n  type: number,          // ChatType.SAY, ChatType.YELL, etc.\n  language: number,      // Language.COMMON, Language.ORCISH\n  message: string,\n  target?: string,       // For whispers and channels\n): Uint8Array {\n  const w = new PacketWriter();\n  w.uint32LE(type);      // Chat type\n  w.uint32LE(language);  // Language\n  if (type === ChatType.WHISPER || type === ChatType.CHANNEL) {\n    w.cString(target ?? \"\");  // Target name or channel name\n  }\n  w.cString(message);    // The message text (null-terminated)\n  return w.finish();\n}\n```\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/client.ts` (lines 1107-1154)\n\nThe `WorldHandle` implementation:\n```typescript\nsendSay(message) {\n  conn.lastChatMode = { type: \"say\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.SAY, lang, message),\n  );\n},\nsendYell(message) {\n  conn.lastChatMode = { type: \"yell\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.YELL, lang, message),\n  );\n},\nsendGuild(message) {\n  conn.lastChatMode = { type: \"guild\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.GUILD, lang, message),\n  );\n},\nsendParty(message) {\n  conn.lastChatMode = { type: \"party\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.PARTY, lang, message),\n  );\n},\nsendRaid(message) {\n  conn.lastChatMode = { type: \"raid\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.RAID, lang, message),\n  );\n},\nsendChannel(channel, message) {\n  conn.lastChatMode = { type: \"channel\", channel };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n  );\n},\n```\n\n**Key detail:** All chat sending methods update `conn.lastChatMode` to track the current chat context, used by `sendInCurrentMode()` (lines 1169-1194).\n\n---\n\n### 5. **Parsing SMSG_MESSAGECHAT** (Incoming)\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts` (lines 30-68)\n\n```typescript\nexport type ChatMessage = {\n  type: number;           // ChatType value\n  language: number;\n  senderGuidLow: number;\n  senderGuidHigh: number;\n  message: string;\n  channel?: string;       // For channel messages\n  senderName?: string;    // For GM messages (isGm=true)\n};\n\nexport function parseChatMessage(r: PacketReader, isGm = false): ChatMessage {\n  const type = r.uint8();\n  const language = r.uint32LE();\n  const senderGuidLow = r.uint32LE();\n  const senderGuidHigh = r.uint32LE();\n  r.uint32LE();\n\n  let senderName: string | undefined;\n  if (isGm) {\n    const nameLen = r.uint32LE();\n    senderName = new TextDecoder().decode(r.bytes(nameLen));\n  }\n\n  let channel: string | undefined;\n  if (type === ChatType.CHANNEL) {\n    channel = r.cString();\n  }\n\n  r.uint32LE();\n  r.uint32LE();\n  const messageLength = r.uint32LE();\n  const messageBytes = r.bytes(messageLength);\n  const end =\n    messageLength > 0 && messageBytes[messageLength - 1] === 0\n      ? messageLength - 1\n      : messageLength;\n  const message = new TextDecoder().decode(messageBytes.subarray(0, end));\n  if (r.remaining > 0) r.uint8();\n\n  return {\n    type,\n    language,\n    senderGuidLow,\n    senderGuidHigh,\n    message,\n    channel,\n    senderName,\n  };\n}\n```\n\n**Important detail:** Server messages include a trailing null terminator that gets stripped (lines 52-56).\n\n---\n\n### 6. **Chat Message Handling & Event Callbacks**\n\n**File:** `/home/openclaw/code/tuicraft/src/wow/client.ts` (lines 442-485)\n\n```typescript\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    // System messages (no sender)\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    // Sender name is cached\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  // Queue message pending name lookup\n  if (!conn.pendingMessages.has(raw.senderGuidLow)) {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  } else {\n    conn.pendingMessages.get(raw.senderGuidLow)!.push(raw);\n  }\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,        // ChatType value\n    sender: name,          // Player or NPC name\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n```\n\n**Opcode registration** (line 1006):\n```typescript\nconn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n  handleChatMessage(conn, r),\n);\n```\n\n---\n\n### 7. **Message Formatting for Display & Logging**\n\n**File:** `/home/openclaw/code/tuicraft/src/ui/tui.ts` (lines 147-213)\n\n**Text formatting** (lines 164-181):\n```typescript\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  // ... etc\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n```\n\n**JSON formatting** (lines 183-213):\n```typescript\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  // ... etc\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n```\n\n---\n\n### 8. **Event Callbacks & Session Logging**\n\n**File:** `/home/openclaw/code/tuicraft/src/daemon/commands.ts` (lines 483-491)\n\n```typescript\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n```\n\nChat messages flow through the event ring buffer and session log:\n- **Ring buffer:** In-memory buffer for reading recent events via IPC\n- **Session log:** JSON-per-line file log with timestamps\n\n**File:** `/home/openclaw/code/tuicraft/src/lib/session-log.ts` (lines 1-23)\n\n```typescript\nexport type LogEntry = {\n  type: string;      // \"SAY\", \"YELL\", \"EMOTE\", etc.\n  sender: string;\n  message: string;\n  channel?: string;  // For channel messages\n};\n\nexport class SessionLog {\n  async append(entry: LogEntry): Promise<void> {\n    const line = JSON.stringify({ ...entry, timestamp: Date.now() }) + \"\\n\";\n    await appendFile(this.path, line);\n  }\n}\n```\n\n---\n\n### 9. **Test Coverage**\n\n**Protocol tests:** `/home/openclaw/code/tuicraft/src/wow/protocol/chat.test.ts`\n- Tests for SAY, WHISPER, CHANNEL, SYSTEM, GM message parsing\n- Tests for buildChatMessage for all types\n\n**Client tests:** `/home/openclaw/code/tuicraft/src/wow/client.test.ts` (lines 675-768)\n- `sendSay` → receives SAY echo\n- `sendYell` → receives YELL echo\n- `sendGuild` → receives GUILD echo\n- `sendParty` → receives PARTY echo\n- `sendRaid` → receives RAID echo\n- `sendChannel` → receives CHANNEL echo\n\n**Command dispatch tests:** `/home/openclaw/code/tuicraft/src/daemon/commands.test.ts` (lines 397-486)\n- Tests for IPC command parsing\n- Tests for dispatchCommand routing to WorldHandle methods\n- Tests for message formatting and logging\n\n**Mock server:** `/home/openclaw/code/tuicraft/src/test/mock-world-server.ts` (lines 173-196)\n- `handleMessageChat()` echoes CMSG_MESSAGE_CHAT back as SMSG_MESSAGE_CHAT\n\n---\n\n## **Pattern for Adding CHAT_MSG_EMOTE Support**\n\nBased on the codebase architecture, adding text emote support would follow this pattern:\n\n### **Step 1: UI Parser** (tui.ts)\n- Update `parseCommand()` to handle `/e` and `/emote` commands, returning `{ type: \"emote\", message }`\n\n### **Step 2: IPC Layer** (commands.ts)\n- Add emote to `IpcCommand` type\n- Update `parseIpcCommand()` to recognize emote commands\n- Update `dispatchCommand()` to handle `case \"emote\"`\n\n### **Step 3: WorldHandle** (client.ts)\n- Add `sendEmote(message: string)` method\n- Call `buildChatMessage(ChatType.EMOTE, lang, message)`\n- Update `lastChatMode` tracking\n\n### **Step 4: Already in place**\n- `ChatType.EMOTE: 0x0a` exists in opcodes.ts ✓\n- `buildChatMessage()` already handles EMOTE (no special target needed) ✓\n- `parseChatMessage()` already handles EMOTE (no channel parsing) ✓\n- `CHAT_TYPE_LABELS[\"emote\"]` and `JSON_TYPE_LABELS[\"EMOTE\"]` exist ✓\n- `onChatMessage()` formatting works for any type ✓\n- Session logging works for any chat type ✓\n\n### **Test additions needed**\n- Add emote command parsing test to tui.test.ts\n- Add `sendEmote()` test to client.test.ts (echoed back as EMOTE type)\n- Update mock-world-server.ts if needed (should already work)\n- Add dispatchCommand test for emote type\n\n---\n\n## **File Location Summary**\n\n| Component | File | Lines |\n|-----------|------|-------|\n| Slash command parser | `/src/ui/tui.ts` | 41-145 |\n| IPC command dispatcher | `/src/daemon/commands.ts` | 63-355 |\n| Chat type constants | `/src/wow/protocol/opcodes.ts` | 644-661 |\n| Outbound packet builder | `/src/wow/protocol/chat.ts` | 70-84 |\n| WorldHandle methods | `/src/wow/client.ts` | 1107-1154 |\n| Inbound packet parser | `/src/wow/protocol/chat.ts` | 30-68 |\n| Message handler | `/src/wow/client.ts` | 442-485 |\n| Message formatting | `/src/ui/tui.ts` | 147-213 |\n| Event callback | `/src/daemon/commands.ts` | 483-491 |\n| Session logging | `/src/lib/session-log.ts` | 1-23 |"}],"totalDurationMs":83428,"totalTokens":77792,"totalToolUseCount":30,"usage":{"input_tokens":0,"cache_creation_input_tokens":291,"cache_read_input_tokens":72908,"output_tokens":4593,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":291,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"fc2b0ca7-5cf9-41ae-b205-4f7b96b2bd01"}
{"parentUuid":"d2e3e035-e6cc-449a-b312-23cf3edca3d7","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01YRJDrKhSgnohNGdrbgdNE9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0144zwBY6HpwrXLJQg34Kw3T","name":"TodoWrite","input":{"todos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"in_progress","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4982,"cache_read_input_tokens":28328,"output_tokens":197,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":4982,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMJUVEu9puEnwXwYSib","type":"assistant","uuid":"bfd38023-de28-4a36-a1ac-ea39a78dbfe9","timestamp":"2026-02-28T23:40:42.175Z"}
{"parentUuid":"bfd38023-de28-4a36-a1ac-ea39a78dbfe9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0144zwBY6HpwrXLJQg34Kw3T","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"30c4debb-20bc-4638-900b-8dafe8ef7fc5","timestamp":"2026-02-28T23:40:42.177Z","toolUseResult":{"oldTodos":[{"content":"Explore project context for emote support","status":"in_progress","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"pending","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}],"newTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"in_progress","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"sourceToolAssistantUUID":"bfd38023-de28-4a36-a1ac-ea39a78dbfe9"}
{"parentUuid":"30c4debb-20bc-4638-900b-8dafe8ef7fc5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_017SPkRyPyXPT2M5QNwkjce1","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The exploration is very thorough. The codebase already has most of the infrastructure in place:\n\n- `ChatType.EMOTE: 0x0a` exists\n- `CHAT_TYPE_LABELS` has \"emote\" \n- `JSON_TYPE_LABELS` has \"EMOTE\"\n- The parser already has `/e` and `/emote` returning `{ type: \"unimplemented\", feature: \"Text emotes\" }`\n- `buildChatMessage` and `parseChatMessage` already handle EMOTE (no special target)\n\nWhat's needed:\n1. Update `parseCommand()` to return `{ type: \"emote\", message }` instead of unimplemented\n\n\n2. Add emote to the IPC command types, implement `sendEmote()` in WorldHandle, wire up the dispatch case, and update `sendInCurrentMode()` to route emote commands\n3. Write tests covering the new functionality\n\nThe pattern mirrors say/yell exactly with no edge cases, so I can move straight to implementation rather than cycling through clarification questions. I'll follow the existing pattern since the emote label is already defined in the codebase and the user asked me to match the say/yell format—this is straightforward enough that I can move directly to the implementation.","signature":"EosSCkYICxgCKkBEVqeIQYSiuNjbDQqikGWUjWIXZ+QsuxAkb1yJQ+Oj/ncU5VFAqgeVhhexcTCmiSyTGa9aUGF4ja5HLyed1PYNEgzifWL5Fs9/EfCpPkYaDKWTzN5kgqxy0gj9NiIwM5N9uuUJ800vr0/4dtBnKKhdOO3UP3L9/dF/a1bE+eDGjzzQwvDKpDCG0xo/e32EKvIQN9lARzW9RILNH9tUSwCz+c0tEqCIimQuXnE5diU/benjYfc5M8+aHA9ZJJqWAfXRtdfSvqd0msaXi+LinNuzCW02AbzWOnkqG4WHDtDVbKkzbzDq58fdGPPmam5ZOC+A9M6BhO+Ct8r3vn26NYoXdzW3RlprCPZ7oEWEDB4pnEmOtutHpSdVBD7oIA6mgLIZREErkifKsZI36Si6iQEtTphRQwBLzrCD4u3+rHRfWYgucQyWRx6BNxzQdZP4Vts3adfjD7Lm6If4q/8J08eJZD22EpOCrKdy700/Xqf3E5NdS6rnqzAOwFgOy31F/Ldw0KcdG9/PjR0kpt9omZnF5w3Swung9/tbMi23CItUub0DsXTvqfdxa+bJI4sx7PfMUCW5/3XwooyxjvqgqCX195A6Y4CnIr9kwbuJSZQqK3LCyHM55K+7Iv9P1h79lJFs41sxyVw8cAxgF9GboXVgBglrn+RLLDh/WOWwOZVE7a70MCx237Ak4P2H7wflfgHNi2wZpCgL/I/bJd+MduWDnAFoE8jv6fviMvBT788ejaSsFpgJRgjOi+/95GE7tgLT9eGfJqac+3FtribcLpxTIZqXav3n81vT3b5ygvLuhMvNBRycS/STzuql9pBspRUFIzvDWZud5i66PWcFEV3E1DZvVejZPJk87jRNIncFoJMnl4GROe+D6zCsayIBW6xakl5FXc7sH97EcrTzH4FLCkmQ4cp57kq7K5h/94dt9kNMNCWzjZUl5SdcpoMGG88vsuoPhuLw07qzfVU4vy1cEYIZXwEW5tf2T/kmQeLheDV7a4qivFIszezC8gAbZHql8p88YY4/yJGkk92ra1gakQqJMAbr2NvTHJRUrYWhilxw8BP2yxc0D6vSbZ7g5wT63W8iit00g70G9PSMdLemF5tw2iGodc97T0yXxF1cDNARX0lVZn54+RnqLvnsa/BfwNfIjLEO9ug3SdTG0kLzk1IdtnPk0vn0E3JDhtTE/2WbHhkqr6H2HK+OgkpAmsflEGDtZ5hCTCTauBJSNqX4mmOqWb/PuwShHWV2i6mAzvVe2D3/rBx+lNRuPIiD4UJ/dRZwSrsT1i7h7upT/t9nbd5GtuBWhu+KRtjMSmBVphMWSyIQkqie8DjvrNrK97Ks6vcskix/9qPBKnXEoLQhg8ycp/gh5/XxLU1KhnEUSRYeib0DqwvVwycQGE9Rxv6bFGHQop4P/sOFhfphWPL1VN4s3dPmfnHaMAxWjHUTSoUukPhTbb8iQQySDeuV7fEJ8HlYXay4d1bR4RCLwPpwMpSR37hlfvw9atWhYMV60ST3hFgneBlIeT1ieMSUuRqJ/1ySKH8EptYYHOT+BWx9GDBwDUGDMtA1ar6DwuBYvklH+gBvVaCBUFc+oYuBKLyMse5PNbPzHDXLKdvJ00LH1YzCok9qQRS49ysT3vHLgoLGN+HrIPAS0OHatISytgbausbUaVWcwTlz3A4fED5WukdUxwwg7aRISC6BxmFHDFSRLbWu15KWAvFREeNh5cC5zJh+RtorbLmnTe30/aqCUAgTCQ901aBfaBVqNI+dMVSQ+hF43cc6zlPEcFp2qMah3ZlhoMSZ/DURM1N9yfek2puVFLVv4MsZwkf9Lyq+fWAgTz7X6USTYxHJekc2ncWuyIIS24/ED7nh4QPOL0Lgh+CqbjWfV1jYPyT5HOkUQTTtEgnBhI2/Ouzq2pBydDQ1MnMMhzdKMa749JrolpHCYjKoLiVFOmZAOxC9zbll8fTkypIMPsM1rowOZAowdbdwZi5bG8X3gnPfkd0zV2x4V1Eo0eM8RvwC4w94ZNUJKDQjLGFv8MBf776WAG4nqjB3mIaZPZgWK8H5nwabV62cq8gFM+9MRAUrw1uT6sYXB/cQ1eCID0WrmDMi9z/X5PugPzTsYfdGU3ZJbroY4uPKuYr79RSanTKwwXICtFL6vRXyc7y5K9uWMZ0SYBphhUuC8aV+3agDML+4BOOwd3k8gD5/Bf1S3pmA95OhxBvigmzUU+19xksfgnhcJXYr+wWAJmy4CtDTpbSv7VxHo/Xj2EV9kT6GSbM769M/mY0xnLDYfoGoGL18j72V/cAdOg3mpmeG3DmjDwwBLCbuIFagPWC9AYzN9uBn0p39LWbk7kufFo9sn7BH61sqt871lNeLbbrBuwhe6EmBANM4pyttoEdRRQxsIQreNGXz3E9uqAHegjTfhYzEWVtiEMkVcluPBcfGf7CZFF25GgiQaw5+YgyBxoGGNBUSacADN2cUbuL7ZwifHRSE3n3RtPb4jRvCOecR5MGxrgzPRrbNOymwDdgop65InoplmopLoL+0U5JgFEWAkDM/3NOVydWmg0pqiE6ugtjKdOx2xDFb18h/xBK+dXpiA8IjUhUM4cveHBswY2SvaFJcHdWtcg4Wz51BZBbdXf0U7f9+QVQTyDIXkwkbLOVoeE0ZDW8JBTgs6mzLwfU1Vc1opKUBc04Z3cG4i/pogfovOwkHcwSC+XZfPNSrFC31OLD+edx27e+Gq/I01pQ/RlJEL5w2dpFzFBOmsppiVYeGsQJPwuPWjVCi8R61gDbQZM7dvOVuL9hk0hObzJWF8IFZgmARQtA5WLpAKYsfdwgbs+/A7i3JfcAsGZrW6Qnq04rKQX9Ubu27BfSTUlPTpCi01Y4D9iW4tVqjiMIeatOQTl3+zBCMdiONa7/35vAUxEY3bWOp9hQGKyAXq7P4locxsl2MBewWcIZkwc+d9xWjWwJ3wrP2C8rgF1Z85IMZKlsG4UNYn3uJBpCeX4zijBwxrseu7K2EB0/FRwqBhys2ghBbkYtGu/WPkI/POKuQY6MB35RtzbTDaONZjItuPdFevf4kNv7tFIVhgKIYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":239,"cache_read_input_tokens":33310,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":239},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMJqMrnysH48N46ypbM","type":"assistant","uuid":"0f836181-aa42-4601-b1b7-52ad99e602f9","timestamp":"2026-02-28T23:40:57.521Z"}
{"parentUuid":"0f836181-aa42-4601-b1b7-52ad99e602f9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_017SPkRyPyXPT2M5QNwkjce1","type":"message","role":"assistant","content":[{"type":"text","text":"Good news — the codebase is already 80% ready. `ChatType.EMOTE`, format labels, and the parser/builder all exist. The `/e` and `/emote` commands are explicitly stubbed as `\"unimplemented\"`. This is purely wiring up the same pattern as say/yell.\n\nGiven how cookie-cutter this is (the user even said \"tiny\" and \"follow the same pattern\"), there's really only one approach — I don't think there are meaningful alternatives or clarifying questions here. Let me present the design directly."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":239,"cache_read_input_tokens":33310,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":239},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMJqMrnysH48N46ypbM","type":"assistant","uuid":"a4a8bb3b-af21-4283-aae3-6839753118c8","timestamp":"2026-02-28T23:40:59.975Z"}
{"parentUuid":"a4a8bb3b-af21-4283-aae3-6839753118c8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_017SPkRyPyXPT2M5QNwkjce1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016xiRDzARKX1ckaDgkfD3vP","name":"TodoWrite","input":{"todos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"in_progress","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":239,"cache_read_input_tokens":33310,"output_tokens":911,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":239,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMJqMrnysH48N46ypbM","type":"assistant","uuid":"644fd45f-8fee-4577-8945-338f1a77a2ed","timestamp":"2026-02-28T23:41:01.345Z"}
{"parentUuid":"644fd45f-8fee-4577-8945-338f1a77a2ed","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016xiRDzARKX1ckaDgkfD3vP","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"a0d3668a-3db5-44af-ac37-24060c83703e","timestamp":"2026-02-28T23:41:01.347Z","toolUseResult":{"oldTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"in_progress","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"pending","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"pending","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}],"newTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"in_progress","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}]},"sourceToolAssistantUUID":"644fd45f-8fee-4577-8945-338f1a77a2ed"}
{"parentUuid":"a0d3668a-3db5-44af-ac37-24060c83703e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01BVetakTTNc7TJipjEYCmLG","type":"message","role":"assistant","content":[{"type":"text","text":"## Design: Text Emote Support\n\n**What:** Wire `/e` and `/emote` slash commands through the existing chat pipeline, exactly like say/yell. Handle incoming emotes from other players the same way.\n\n**Changes (4 files):**\n\n1. **`src/ui/tui.ts`** — Change `/e`/`/emote` from `unimplemented` to `{ type: \"emote\", message }`\n2. **`src/daemon/commands.ts`** — Add `emote` to `IpcCommand` union, `parseIpcCommand()`, and `dispatchCommand()` (+ `EMOTE` uppercase form)\n3. **`src/wow/client.ts`** — Add `sendEmote(message)` to `WorldHandle`, update `lastChatMode` tracking and `sendInCurrentMode()`\n4. **`src/test/mock-handle.ts`** + inline mock in `start.test.ts` — Add `sendEmote` stub\n\n**Already in place (no changes needed):**\n- `ChatType.EMOTE: 0x0a` in opcodes\n- `buildChatMessage()` / `parseChatMessage()` handle EMOTE (no special target like whisper/channel)\n- Format labels: `[emote]` for text, `EMOTE` for JSON\n- Incoming emote delivery via `onChatMessage` works for any chat type\n\n**Tests:** Emote parsing, IPC routing, send/receive echo, mock handle updates — mirroring existing say/yell test patterns.\n\nDoes this look right? It's a straight copy of the say/yell pattern with zero divergence."}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":942,"cache_read_input_tokens":33549,"output_tokens":393,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":942,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMLFM2WB5qSKbMxiCxx","type":"assistant","uuid":"3aef0ba5-47b1-4c59-9dd9-e912caa18020","timestamp":"2026-02-28T23:41:11.114Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-28T23:41:21.210Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","content":"Yes, proceed. Branch, implement, test, PR. Don't ask more questions."}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-28T23:41:21.210Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd"}
{"parentUuid":"3aef0ba5-47b1-4c59-9dd9-e912caa18020","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.sh"},"parentToolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","toolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","timestamp":"2026-02-28T23:41:21.195Z","uuid":"dee4ba65-2ea8-4063-8d71-d86abbad3837"}
{"parentUuid":"dee4ba65-2ea8-4063-8d71-d86abbad3837","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"entire hooks claude-code session-start"},"parentToolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","toolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","timestamp":"2026-02-28T23:41:21.195Z","uuid":"19cb80b4-053e-4429-8542-6855b235a423"}
{"parentUuid":"19cb80b4-053e-4429-8542-6855b235a423","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"'${CLAUDE_PLUGIN_ROOT}/hooks/run-hook.cmd' session-start"},"parentToolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","toolUseID":"fad9834c-189d-47ad-954d-89c8c6626adb","timestamp":"2026-02-28T23:41:21.195Z","uuid":"4f5a9c3a-b42c-4df9-b46a-a88c11e5d04f"}
{"parentUuid":"4f5a9c3a-b42c-4df9-b46a-a88c11e5d04f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":"Yes, proceed. Branch, implement, test, PR. Don't ask more questions."},"uuid":"aa5b89dd-2f31-4d97-a458-a8b9964248a6","timestamp":"2026-02-28T23:41:21.215Z","permissionMode":"bypassPermissions"}
{"parentUuid":"aa5b89dd-2f31-4d97-a458-a8b9964248a6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0188tfkFhLMoLgKabbhEexDk","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user approved the design and wants me to proceed directly. Let me invoke the writing-plans skill as the brainstorming skill requires, then move straight to implementation.\n\nActually, the user said \"Don't ask more questions\" and \"Branch, implement, test, PR.\" They want me to just do it. The brainstorming skill says to invoke writing-plans next, but the user is telling me to skip the ceremony and just implement. Let me respect the user's wishes while still following the key skills.\n\nLet me invoke the writing-plans skill to create a quick plan, then execute it. But actually, the user is very clear - they don't want more process. Let me just do it.\n\n\nI'm mapping out which skills I need to apply here - the design is already approved, so I can skip the full planning ceremony since these are straightforward changes across four files. I'll go straight to creating the branch and implementing the changes, then run tests and open the PR.","signature":"EvsMCkYICxgCKkBd3iNhQFwXYzzQZmL9rtetZYr764LpRe6HG5ZlAp6R1ltMY72zXv1r7t3ixfCL4DO/Gdg+0o/4OvDitUR8UHOfEgww5iKtuGvcoHrW/oIaDCjqrQo3qudXEc3lCSIwqSdKSA3TuZ4oC9qRREb26nVYSdJu/2EVgyQzakm2JGgAwQWyoGuCwskGfQN+v0zTKuIL1COzhZNYgsn2xfuOkxcwSGw9Hjwn2GK4bbm7Jvf8iz1ZWgyTBphhltggUQu58+FAXY8gUEgGxoafphh5dh2FtWfLs6g5Sx9xmfBPKBAqY1K5gNDAKq8QNzCwjNO3v8Hc2d37Y1c8FG91frq7YqD2gAUDbmevc9fmsh/IeViWcPaK3BK1veSCyKSLS29oiTfsPlU1uSrYZlBLGr1gMoVNTMK5JuKSH53Fh0VaykPjCnssnb9U8uz6DESx3+l8hIBuEv+vPEjcenBWksmly/idUThla/vQSr3uBX5mz+eULVuF8bKa6cFbhNudjzhTuOiOuS+6EBxKwO9+GjvZrzBeEhlBMBbRpaXIhEdOTi0d+O77pDmtO73pQiuj7FGBdxYlqfsLtaeXezigo8KindL3DZyaEbGNZNS9P1xJjbruW/S9gPhaIeymEDh4dBFS2/Io1pP87ShvwbTJLDvvYdavp7jOoQ4YoyRmorgU1O85vZt+sIBIwZQ7sEjqK6dy2CyubLstNhS0OvvRY8scJoiS7h2UflvBfLSKKwg0WbjMCi+MysZYHw8092AeQVUF0RYY9mnUxCaZG+clgKZMtlB6YtEyMeasHTyb//HM59u9GwcdV+TzEycckM+JryQUfb5k6vYTSuTnQGmsnSPHpbmOsY97ZTgf5dxmos0IJYSYE1xfQqXc7P/A7SBYtvx6SsywBtb0UGdtLeXQkzoegQ513LXBbzrCfrxkVQHK1Qa7ERReR2oLkQzT4ON8kDii2nSur1PgNMgplgydRp0Mec5bYfl2pvSfLIORsqVk5GOQ5I27s0ZrkPO7KTWmALIJf9zxvWjESOzkVXvD9+P7Sqc4IHW6icdXRAsWe1/EYL+NreyG6PgJ3SPZ2FOhfV0HdnSZK2BQ8X+k5mPbcyLPhnnksmu/fwZrLLLrrVnlQmEBmVRk/6wE7P2PFbC3tx/RSwgdW3kBFyX5JaT1eLK7REFqEJC835H4MpGHrrDipIpFHPL9Xl2vz0F39LGhIK2qsdtK3+rWCByRSpIuGfcsvA/DVQS9p5duTJpE6kivPPSr6Apa9ysg5LT79kO1fw1PRcxULXBq3CYUHhZFXilGOMH+SQzuUDlYm0bSrYwfeVt4F2eX4gNnRob5wwgvYrhtVI9o/PkbAqZ6rEq7T6uabZuE5gzqtR3TA7nbe+BHENuUt6cJTBsAOdjFCaiSpavhkgk+kw0pbRBKj85jjsKCQyPRL/HdgGIhrI/9VXqoIOu1oavj6/B+n1Q2copuZXgJPFD8BVgf0yVsaTOJ3xZjSmZyGuoAtWSi7qGt8BDADGQglq7yG3CCSKEPxt5BPhlIN8u+nbz7Zk+AeJHfmhm1vujRnqcNF5quH6fD+IL1D6Ubn2AfCzOXA39tAaTyiWW6QwV7+p8rC1t2CRY51qhGI0atfNVWpWFuOioIKif9ke6tQoG28iS9AnP6tb3zfhCie+ViyA6CXKo5zkz+lZjEZ+G6KgzSxMQqgiPvBEb1Fybwve9vVUobRxNPa1sIvKkD1l6m3JLHZiDtmYd5KSuvbxnDAa4pY/YqXI/3ux0G7Tz4MzTXCLvJ/Ia1lDIvAIwcpgdMPOrU5TJorUyFgln3QZSanf65pSALMaGTZzWdiHVaP26mJHn8bifI+tdJwZnCCsRE9AJAVSvSR5z+P/8+eSZseR6MgzyNfAxzjS8G6hJplafkf85L7wYIkqQKV/LqtPsIo8DfPTo9akZabaFNVNezJhdaSUQjkLaYvOtn5+sRycy9ZlLvX1WPoRucFLW4Yes3d0ZCPM2nQc+GCQrmZLM8K3RplLNgcWrvp1liR87JdGAuIWXdH5mF2aVYLoMDDNJiYITLjkiwunOKJXIkafRDEh+bpW0e0VgMzAsCGqw8UXy7VJPPVagXveVc4sgbrkpV1L35bMujXxvfFHrBjX83XviEYzyhHqCXnRWHbkc/H1eKlr46uM31Y5QmayhOaN6/Q8UM4gEZTM3daGMbnYLjzyyUGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":10663,"cache_read_input_tokens":24240,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10663},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMMiWS8JvvtybEwY5rS","type":"assistant","uuid":"a0bde636-6aa8-4382-8696-eb92804db129","timestamp":"2026-02-28T23:41:32.847Z"}
{"parentUuid":"a0bde636-6aa8-4382-8696-eb92804db129","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0188tfkFhLMoLgKabbhEexDk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0136ZbGugCrzWfKJp1WLMPdf","name":"Bash","input":{"command":"git checkout -b feat/text-emote","description":"Create feature branch for text emote support"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":10663,"cache_read_input_tokens":24240,"output_tokens":480,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":10663,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMMiWS8JvvtybEwY5rS","type":"assistant","uuid":"f5e6b25f-ea3f-4fa0-9a79-5c283edc1fe6","timestamp":"2026-02-28T23:41:33.913Z"}
{"parentUuid":"f5e6b25f-ea3f-4fa0-9a79-5c283edc1fe6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"main","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0136ZbGugCrzWfKJp1WLMPdf","type":"tool_result","content":"Switched to a new branch 'feat/text-emote'","is_error":false}]},"uuid":"ff27b754-3fe0-4ce1-8000-242dda75d5e8","timestamp":"2026-02-28T23:41:33.966Z","toolUseResult":{"stdout":"Switched to a new branch 'feat/text-emote'","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"f5e6b25f-ea3f-4fa0-9a79-5c283edc1fe6"}
{"parentUuid":"ff27b754-3fe0-4ce1-8000-242dda75d5e8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01WgUJzUniLQ5aGKRD8hvHn8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01945aD5p92EpxEBFXfDWSFr","name":"TodoWrite","input":{"todos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"completed","activeForm":"Presenting design"},{"content":"Update tui.ts parseCommand for /e and /emote","status":"in_progress","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"pending","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":484,"cache_read_input_tokens":34903,"output_tokens":426,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":484,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMNehGbexsVCha8qsd8","type":"assistant","uuid":"0d255455-f602-4d4a-add6-312908118d86","timestamp":"2026-02-28T23:41:42.034Z"}
{"parentUuid":"0d255455-f602-4d4a-add6-312908118d86","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01945aD5p92EpxEBFXfDWSFr","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"704a0c7e-262a-4817-ba7f-e0efd38cf061","timestamp":"2026-02-28T23:41:42.036Z","toolUseResult":{"oldTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"in_progress","activeForm":"Presenting design"},{"content":"Write design doc and transition to implementation","status":"pending","activeForm":"Writing design doc"}],"newTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"completed","activeForm":"Presenting design"},{"content":"Update tui.ts parseCommand for /e and /emote","status":"in_progress","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"pending","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"0d255455-f602-4d4a-add6-312908118d86"}
{"parentUuid":"704a0c7e-262a-4817-ba7f-e0efd38cf061","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01L8BPY4eheJsSLZzbttpNXc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EsSAhvrdS1QRiHDB1s21WG","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":468,"cache_read_input_tokens":35387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":468},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPFQpd9dxLN3WxBFjP","type":"assistant","uuid":"61ea908a-b7cc-494e-8bdd-70bf2cbdba17","timestamp":"2026-02-28T23:41:44.774Z"}
{"parentUuid":"61ea908a-b7cc-494e-8bdd-70bf2cbdba17","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EsSAhvrdS1QRiHDB1s21WG","type":"tool_result","content":"     1→import { createInterface } from \"node:readline\";\n     2→import { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\n     3→import { ObjectType } from \"wow/protocol/entity-fields\";\n     4→import type {\n     5→  WorldHandle,\n     6→  ChatMessage,\n     7→  ChatMode,\n     8→  WhoResult,\n     9→  GroupEvent,\n    10→} from \"wow/client\";\n    11→import type { EntityEvent, UnitEntity } from \"wow/entity-store\";\n    12→import type { FriendEntry, FriendEvent } from \"wow/friend-store\";\n    13→import { FriendStatus } from \"wow/protocol/social\";\n    14→import type { LogEntry } from \"lib/session-log\";\n    15→import { stripColorCodes } from \"lib/strip-colors\";\n    16→\n    17→export type Command =\n    18→  | { type: \"chat\"; message: string }\n    19→  | { type: \"say\"; message: string }\n    20→  | { type: \"yell\"; message: string }\n    21→  | { type: \"guild\"; message: string }\n    22→  | { type: \"party\"; message: string }\n    23→  | { type: \"raid\"; message: string }\n    24→  | { type: \"whisper\"; target: string; message: string }\n    25→  | { type: \"reply\"; message: string }\n    26→  | { type: \"channel\"; target: string; message: string }\n    27→  | { type: \"who\"; target?: string }\n    28→  | { type: \"invite\"; target: string }\n    29→  | { type: \"kick\"; target: string }\n    30→  | { type: \"leave\" }\n    31→  | { type: \"leader\"; target: string }\n    32→  | { type: \"accept\" }\n    33→  | { type: \"decline\" }\n    34→  | { type: \"quit\" }\n    35→  | { type: \"tuicraft\"; subcommand: string; value: string }\n    36→  | { type: \"friends\" }\n    37→  | { type: \"add-friend\"; target: string }\n    38→  | { type: \"remove-friend\"; target: string }\n    39→  | { type: \"unimplemented\"; feature: string };\n    40→\n    41→export function parseCommand(input: string): Command {\n    42→  if (!input.startsWith(\"/\")) return { type: \"chat\", message: input };\n    43→\n    44→  const spaceIdx = input.indexOf(\" \");\n    45→  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);\n    46→  const rest = spaceIdx === -1 ? \"\" : input.slice(spaceIdx + 1);\n    47→\n    48→  switch (cmd) {\n    49→    case \"/s\":\n    50→    case \"/say\":\n    51→      return { type: \"say\", message: rest };\n    52→    case \"/y\":\n    53→    case \"/yell\":\n    54→      return { type: \"yell\", message: rest };\n    55→    case \"/g\":\n    56→    case \"/guild\":\n    57→      return { type: \"guild\", message: rest };\n    58→    case \"/p\":\n    59→    case \"/party\":\n    60→      return { type: \"party\", message: rest };\n    61→    case \"/raid\":\n    62→      return { type: \"raid\", message: rest };\n    63→    case \"/w\":\n    64→    case \"/whisper\": {\n    65→      const targetEnd = rest.indexOf(\" \");\n    66→      if (targetEnd === -1)\n    67→        return { type: \"whisper\", target: rest, message: \"\" };\n    68→      return {\n    69→        type: \"whisper\",\n    70→        target: rest.slice(0, targetEnd),\n    71→        message: rest.slice(targetEnd + 1),\n    72→      };\n    73→    }\n    74→    case \"/r\":\n    75→      return { type: \"reply\", message: rest };\n    76→    case \"/who\":\n    77→      return rest ? { type: \"who\", target: rest } : { type: \"who\" };\n    78→    case \"/invite\":\n    79→      return rest\n    80→        ? { type: \"invite\", target: rest }\n    81→        : { type: \"say\", message: input };\n    82→    case \"/kick\":\n    83→      return rest\n    84→        ? { type: \"kick\", target: rest }\n    85→        : { type: \"say\", message: input };\n    86→    case \"/leave\":\n    87→      return { type: \"leave\" };\n    88→    case \"/leader\":\n    89→      return rest\n    90→        ? { type: \"leader\", target: rest }\n    91→        : { type: \"say\", message: input };\n    92→    case \"/accept\":\n    93→      return { type: \"accept\" };\n    94→    case \"/decline\":\n    95→      return { type: \"decline\" };\n    96→    case \"/quit\":\n    97→      return { type: \"quit\" };\n    98→    case \"/tuicraft\": {\n    99→      const parts = rest.split(\" \");\n   100→      return {\n   101→        type: \"tuicraft\",\n   102→        subcommand: parts[0] ?? \"\",\n   103→        value: parts[1] ?? \"\",\n   104→      };\n   105→    }\n   106→    case \"/friends\":\n   107→      return { type: \"friends\" };\n   108→    case \"/f\":\n   109→      return { type: \"friends\" };\n   110→    case \"/friend\": {\n   111→      const parts = rest.split(\" \");\n   112→      const sub = parts[0] ?? \"\";\n   113→      const target = parts.slice(1).join(\" \");\n   114→      if (sub === \"add\" && target) return { type: \"add-friend\", target };\n   115→      if (sub === \"remove\" && target) return { type: \"remove-friend\", target };\n   116→      return { type: \"friends\" };\n   117→    }\n   118→    case \"/ignore\":\n   119→      return { type: \"unimplemented\", feature: \"Ignore list\" };\n   120→    case \"/join\":\n   121→      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n   122→    case \"/ginvite\":\n   123→    case \"/gkick\":\n   124→    case \"/gleave\":\n   125→    case \"/gpromote\":\n   126→      return { type: \"unimplemented\", feature: \"Guild management\" };\n   127→    case \"/mail\":\n   128→      return { type: \"unimplemented\", feature: \"Mail\" };\n   129→    case \"/roll\":\n   130→      return { type: \"unimplemented\", feature: \"Random roll\" };\n   131→    case \"/dnd\":\n   132→    case \"/afk\":\n   133→      return { type: \"unimplemented\", feature: \"Player status\" };\n   134→    case \"/e\":\n   135→    case \"/emote\":\n   136→      return { type: \"unimplemented\", feature: \"Text emotes\" };\n   137→    default: {\n   138→      const channelMatch = cmd.match(/^\\/(\\d+)$/);\n   139→      if (channelMatch) {\n   140→        return { type: \"channel\", target: channelMatch[1]!, message: rest };\n   141→      }\n   142→      return { type: \"say\", message: input };\n   143→    }\n   144→  }\n   145→}\n   146→\n   147→const CHAT_TYPE_LABELS: Record<number, string> = {\n   148→  [ChatType.SYSTEM]: \"system\",\n   149→  [ChatType.SAY]: \"say\",\n   150→  [ChatType.PARTY]: \"party\",\n   151→  [ChatType.RAID]: \"raid\",\n   152→  [ChatType.GUILD]: \"guild\",\n   153→  [ChatType.OFFICER]: \"officer\",\n   154→  [ChatType.YELL]: \"yell\",\n   155→  [ChatType.WHISPER]: \"whisper from\",\n   156→  [ChatType.WHISPER_INFORM]: \"whisper to\",\n   157→  [ChatType.EMOTE]: \"emote\",\n   158→  [ChatType.CHANNEL]: \"channel\",\n   159→  [ChatType.RAID_LEADER]: \"raid leader\",\n   160→  [ChatType.RAID_WARNING]: \"raid warning\",\n   161→  [ChatType.PARTY_LEADER]: \"party leader\",\n   162→};\n   163→\n   164→export function formatMessage(msg: ChatMessage): string {\n   165→  const message = stripColorCodes(msg.message);\n   166→  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n   167→\n   168→  if (msg.type === ChatType.WHISPER) {\n   169→    return `[whisper from ${msg.sender}] ${message}`;\n   170→  }\n   171→  if (msg.type === ChatType.WHISPER_INFORM) {\n   172→    return `[whisper to ${msg.sender}] ${message}`;\n   173→  }\n   174→  if (msg.type === ChatType.SYSTEM) {\n   175→    return `[system] ${message}`;\n   176→  }\n   177→  if (msg.type === ChatType.CHANNEL && msg.channel) {\n   178→    return `[${msg.channel}] ${msg.sender}: ${message}`;\n   179→  }\n   180→  return `[${label}] ${msg.sender}: ${message}`;\n   181→}\n   182→\n   183→const JSON_TYPE_LABELS: Record<number, string> = {\n   184→  [ChatType.SYSTEM]: \"SYSTEM\",\n   185→  [ChatType.SAY]: \"SAY\",\n   186→  [ChatType.PARTY]: \"PARTY\",\n   187→  [ChatType.RAID]: \"RAID\",\n   188→  [ChatType.GUILD]: \"GUILD\",\n   189→  [ChatType.OFFICER]: \"OFFICER\",\n   190→  [ChatType.YELL]: \"YELL\",\n   191→  [ChatType.WHISPER]: \"WHISPER_FROM\",\n   192→  [ChatType.WHISPER_INFORM]: \"WHISPER_TO\",\n   193→  [ChatType.EMOTE]: \"EMOTE\",\n   194→  [ChatType.CHANNEL]: \"CHANNEL\",\n   195→  [ChatType.RAID_LEADER]: \"RAID_LEADER\",\n   196→  [ChatType.RAID_WARNING]: \"RAID_WARNING\",\n   197→  [ChatType.PARTY_LEADER]: \"PARTY_LEADER\",\n   198→};\n   199→\n   200→export function formatMessageObj(msg: ChatMessage): LogEntry {\n   201→  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n   202→  const obj: LogEntry = {\n   203→    type,\n   204→    sender: msg.sender,\n   205→    message: stripColorCodes(msg.message),\n   206→  };\n   207→  if (msg.channel) obj.channel = msg.channel;\n   208→  return obj;\n   209→}\n   210→\n   211→export function formatMessageJson(msg: ChatMessage): string {\n   212→  return JSON.stringify(formatMessageObj(msg));\n   213→}\n   214→\n   215→export function formatError(message: string): string {\n   216→  return `[system] ${message}`;\n   217→}\n   218→\n   219→export function formatWhoResults(results: WhoResult[]): string {\n   220→  const names =\n   221→    results.map((r) => `${r.name} (${r.level})`).join(\", \") || \"none\";\n   222→  return `[who] ${results.length} results: ${names}`;\n   223→}\n   224→\n   225→export function formatWhoResultsJson(results: WhoResult[]): string {\n   226→  return JSON.stringify({\n   227→    type: \"WHO\",\n   228→    count: results.length,\n   229→    results: results.map((r) => ({\n   230→      name: r.name,\n   231→      guild: r.guild,\n   232→      level: r.level,\n   233→      classId: r.classId,\n   234→      race: r.race,\n   235→      gender: r.gender,\n   236→      zone: r.zone,\n   237→    })),\n   238→  });\n   239→}\n   240→\n   241→export function formatPrompt(mode: ChatMode): string {\n   242→  switch (mode.type) {\n   243→    case \"whisper\":\n   244→      return `[whisper: ${mode.target}] > `;\n   245→    case \"channel\":\n   246→      return `[${mode.channel}] > `;\n   247→    default:\n   248→      return `[${mode.type}] > `;\n   249→  }\n   250→}\n   251→\n   252→function partyResultLabel(result: number): string {\n   253→  switch (result) {\n   254→    case PartyResult.BAD_PLAYER_NAME:\n   255→      return \"player not found\";\n   256→    case PartyResult.GROUP_FULL:\n   257→      return \"group is full\";\n   258→    case PartyResult.ALREADY_IN_GROUP:\n   259→      return \"already in a group\";\n   260→    case PartyResult.NOT_LEADER:\n   261→      return \"you are not the leader\";\n   262→    case PartyResult.PLAYER_WRONG_FACTION:\n   263→      return \"wrong faction\";\n   264→    case PartyResult.IGNORING_YOU:\n   265→      return \"player is ignoring you\";\n   266→    default:\n   267→      return `error ${result}`;\n   268→  }\n   269→}\n   270→\n   271→export function formatGroupEvent(event: GroupEvent): string | undefined {\n   272→  switch (event.type) {\n   273→    case \"invite_received\":\n   274→      return `[group] ${event.from} invites you to a group`;\n   275→    case \"command_result\": {\n   276→      const verb =\n   277→        event.operation === PartyOperation.UNINVITE\n   278→          ? \"kick\"\n   279→          : event.operation === PartyOperation.LEAVE\n   280→            ? \"leave\"\n   281→            : \"invite\";\n   282→      const label =\n   283→        event.result === PartyResult.SUCCESS\n   284→          ? verb === \"kick\"\n   285→            ? `Removed ${event.target} from group`\n   286→            : verb === \"leave\"\n   287→              ? \"Left the group\"\n   288→              : `Invited ${event.target}`\n   289→          : `Cannot ${verb}${event.target ? ` ${event.target}` : \"\"}: ${partyResultLabel(event.result)}`;\n   290→      return `[group] ${label}`;\n   291→    }\n   292→    case \"leader_changed\":\n   293→      return `[group] ${event.name} is now the group leader`;\n   294→    case \"group_destroyed\":\n   295→      return \"[group] Group has been disbanded\";\n   296→    case \"kicked\":\n   297→      return \"[group] You have been removed from the group\";\n   298→    case \"invite_declined\":\n   299→      return `[group] ${event.name} has declined your invitation`;\n   300→    case \"group_list\":\n   301→    case \"member_stats\":\n   302→      return undefined;\n   303→  }\n   304→}\n   305→\n   306→export function formatEntityEvent(event: EntityEvent): string | undefined {\n   307→  switch (event.type) {\n   308→    case \"appear\": {\n   309→      const e = event.entity;\n   310→      if (!e.name) return undefined;\n   311→      if (\n   312→        e.objectType === ObjectType.UNIT ||\n   313→        e.objectType === ObjectType.PLAYER\n   314→      ) {\n   315→        const unit = e as UnitEntity;\n   316→        const kind = e.objectType === ObjectType.PLAYER ? \"Player\" : \"NPC\";\n   317→        const levelStr = unit.level > 0 ? `, level ${unit.level}` : \"\";\n   318→        return `[world] ${e.name} appeared (${kind}${levelStr})`;\n   319→      }\n   320→      if (e.objectType === ObjectType.GAMEOBJECT) {\n   321→        return `[world] ${e.name} appeared (GameObject)`;\n   322→      }\n   323→      return undefined;\n   324→    }\n   325→    case \"disappear\": {\n   326→      const name = event.name ?? \"Unknown entity\";\n   327→      return `[world] ${name} left range`;\n   328→    }\n   329→    case \"update\": {\n   330→      if (!event.changed.includes(\"name\") || !event.entity.name)\n   331→        return undefined;\n   332→      return formatEntityEvent({ type: \"appear\", entity: event.entity });\n   333→    }\n   334→  }\n   335→}\n   336→\n   337→export function formatEntityEventObj(\n   338→  event: EntityEvent,\n   339→): Record<string, unknown> | undefined {\n   340→  switch (event.type) {\n   341→    case \"appear\": {\n   342→      const e = event.entity;\n   343→      const obj: Record<string, unknown> = {\n   344→        type: \"ENTITY_APPEAR\",\n   345→        guid: `0x${e.guid.toString(16)}`,\n   346→        objectType: e.objectType,\n   347→        name: e.name,\n   348→      };\n   349→      if (\n   350→        e.objectType === ObjectType.UNIT ||\n   351→        e.objectType === ObjectType.PLAYER\n   352→      ) {\n   353→        const unit = e as UnitEntity;\n   354→        obj[\"level\"] = unit.level;\n   355→        obj[\"health\"] = unit.health;\n   356→        obj[\"maxHealth\"] = unit.maxHealth;\n   357→      }\n   358→      if (e.position) {\n   359→        obj[\"x\"] = e.position.x;\n   360→        obj[\"y\"] = e.position.y;\n   361→        obj[\"z\"] = e.position.z;\n   362→      }\n   363→      return obj;\n   364→    }\n   365→    case \"disappear\":\n   366→      return {\n   367→        type: \"ENTITY_DISAPPEAR\",\n   368→        guid: `0x${event.guid.toString(16)}`,\n   369→        name: event.name,\n   370→      };\n   371→    case \"update\":\n   372→      return undefined;\n   373→  }\n   374→}\n   375→\n   376→const CLASS_NAMES: Record<number, string> = {\n   377→  1: \"Warrior\",\n   378→  2: \"Paladin\",\n   379→  3: \"Hunter\",\n   380→  4: \"Rogue\",\n   381→  5: \"Priest\",\n   382→  6: \"Death Knight\",\n   383→  7: \"Shaman\",\n   384→  8: \"Mage\",\n   385→  9: \"Warlock\",\n   386→  11: \"Druid\",\n   387→};\n   388→\n   389→function friendStatusLabel(status: number): string {\n   390→  if (status === FriendStatus.AFK) return \"AFK\";\n   391→  if (status === FriendStatus.DND) return \"DND\";\n   392→  if (status !== FriendStatus.OFFLINE) return \"Online\";\n   393→  return \"Offline\";\n   394→}\n   395→\n   396→export function formatFriendList(friends: FriendEntry[]): string {\n   397→  if (friends.length === 0) return \"[friends] No friends on your list\";\n   398→  const lines = friends.map((f) => {\n   399→    const name = f.name || `guid:${Number(f.guid & 0xffffffffn)}`;\n   400→    if (f.status === FriendStatus.OFFLINE) return `  ${name} — Offline`;\n   401→    const cls = CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`;\n   402→    const statusLabel = friendStatusLabel(f.status);\n   403→    return `  ${name} — ${statusLabel}, Level ${f.level} ${cls}`;\n   404→  });\n   405→  const online = friends.filter(\n   406→    (f) => f.status !== FriendStatus.OFFLINE,\n   407→  ).length;\n   408→  return `[friends] ${online}/${friends.length} online\\n${lines.join(\"\\n\")}`;\n   409→}\n   410→\n   411→export function formatFriendListJson(friends: FriendEntry[]): string {\n   412→  return JSON.stringify({\n   413→    type: \"FRIENDS\",\n   414→    count: friends.length,\n   415→    online: friends.filter((f) => f.status !== FriendStatus.OFFLINE).length,\n   416→    friends: friends.map((f) => ({\n   417→      guid: `0x${f.guid.toString(16)}`,\n   418→      name: f.name,\n   419→      note: f.note,\n   420→      status: friendStatusLabel(f.status).toUpperCase(),\n   421→      level: f.level,\n   422→      class: CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`,\n   423→      area: f.area,\n   424→    })),\n   425→  });\n   426→}\n   427→\n   428→function friendResultLabel(result: number): string {\n   429→  const labels: Record<number, string> = {\n   430→    0x00: \"database error\",\n   431→    0x01: \"friends list is full\",\n   432→    0x04: \"player not found\",\n   433→    0x08: \"already on friends list\",\n   434→    0x09: \"cannot add yourself\",\n   435→    0x0a: \"cannot add enemy faction\",\n   436→  };\n   437→  return labels[result] ?? `error ${result}`;\n   438→}\n   439→\n   440→export function formatFriendEvent(event: FriendEvent): string | undefined {\n   441→  switch (event.type) {\n   442→    case \"friend-online\": {\n   443→      const f = event.friend;\n   444→      const cls = CLASS_NAMES[f.playerClass] ?? \"\";\n   445→      const lvl = f.level ? `Level ${f.level}` : \"\";\n   446→      const detail = [lvl, cls].filter(Boolean).join(\" \");\n   447→      return `[friends] ${f.name || \"Unknown\"} is now online${detail ? ` (${detail})` : \"\"}`;\n   448→    }\n   449→    case \"friend-offline\":\n   450→      return `[friends] ${event.name || \"Unknown\"} went offline`;\n   451→    case \"friend-added\": {\n   452→      const f = event.friend;\n   453→      return `[friends] ${f.name || \"Unknown\"} added to friends list`;\n   454→    }\n   455→    case \"friend-removed\":\n   456→      return `[friends] ${event.name || \"Unknown\"} removed from friends list`;\n   457→    case \"friend-error\":\n   458→      return `[friends] Error: ${friendResultLabel(event.result)}`;\n   459→    case \"friend-list\":\n   460→      return undefined;\n   461→  }\n   462→}\n   463→\n   464→export function formatFriendEventObj(\n   465→  event: FriendEvent,\n   466→): Record<string, unknown> | undefined {\n   467→  switch (event.type) {\n   468→    case \"friend-online\":\n   469→      return {\n   470→        type: \"FRIEND_ONLINE\",\n   471→        name: event.friend.name,\n   472→        level: event.friend.level,\n   473→        class: CLASS_NAMES[event.friend.playerClass],\n   474→        area: event.friend.area,\n   475→      };\n   476→    case \"friend-offline\":\n   477→      return { type: \"FRIEND_OFFLINE\", name: event.name };\n   478→    case \"friend-added\":\n   479→      return { type: \"FRIEND_ADDED\", name: event.friend.name };\n   480→    case \"friend-removed\":\n   481→      return { type: \"FRIEND_REMOVED\", name: event.name };\n   482→    case \"friend-error\":\n   483→      return {\n   484→        type: \"FRIEND_ERROR\",\n   485→        result: event.result,\n   486→        message: friendResultLabel(event.result),\n   487→      };\n   488→    case \"friend-list\":\n   489→      return undefined;\n   490→  }\n   491→}\n   492→\n   493→export type TuiState = {\n   494→  handle: WorldHandle;\n   495→  write: (s: string) => void;\n   496→  lastWhisperFrom: string | undefined;\n   497→  showEntityEvents: boolean;\n   498→};\n   499→\n   500→export async function executeCommand(\n   501→  state: TuiState,\n   502→  cmd: Command,\n   503→): Promise<boolean> {\n   504→  switch (cmd.type) {\n   505→    case \"chat\":\n   506→      state.handle.sendInCurrentMode(cmd.message);\n   507→      break;\n   508→    case \"say\":\n   509→      state.handle.sendSay(cmd.message);\n   510→      break;\n   511→    case \"yell\":\n   512→      state.handle.sendYell(cmd.message);\n   513→      break;\n   514→    case \"guild\":\n   515→      state.handle.sendGuild(cmd.message);\n   516→      break;\n   517→    case \"party\":\n   518→      state.handle.sendParty(cmd.message);\n   519→      break;\n   520→    case \"raid\":\n   521→      state.handle.sendRaid(cmd.message);\n   522→      break;\n   523→    case \"whisper\":\n   524→      state.handle.sendWhisper(cmd.target, cmd.message);\n   525→      state.lastWhisperFrom = cmd.target;\n   526→      break;\n   527→    case \"reply\":\n   528→      if (!state.lastWhisperFrom) {\n   529→        state.write(formatError(\"No one has whispered you yet.\") + \"\\n\");\n   530→      } else {\n   531→        state.handle.sendWhisper(state.lastWhisperFrom, cmd.message);\n   532→      }\n   533→      break;\n   534→    case \"channel\": {\n   535→      const channel = /^\\d+$/.test(cmd.target)\n   536→        ? state.handle.getChannel(parseInt(cmd.target, 10))\n   537→        : cmd.target;\n   538→      if (!channel) {\n   539→        state.write(formatError(`Not in channel ${cmd.target}.`) + \"\\n\");\n   540→      } else {\n   541→        state.handle.sendChannel(channel, cmd.message);\n   542→      }\n   543→      break;\n   544→    }\n   545→    case \"who\": {\n   546→      const results = await state.handle.who(\n   547→        cmd.target ? { name: cmd.target } : {},\n   548→      );\n   549→      state.write(formatWhoResults(results) + \"\\n\");\n   550→      break;\n   551→    }\n   552→    case \"invite\":\n   553→      state.handle.invite(cmd.target);\n   554→      break;\n   555→    case \"kick\":\n   556→      state.handle.uninvite(cmd.target);\n   557→      break;\n   558→    case \"leave\":\n   559→      state.handle.leaveGroup();\n   560→      break;\n   561→    case \"leader\":\n   562→      state.handle.setLeader(cmd.target);\n   563→      break;\n   564→    case \"accept\":\n   565→      state.handle.acceptInvite();\n   566→      break;\n   567→    case \"decline\":\n   568→      state.handle.declineInvite();\n   569→      break;\n   570→    case \"quit\":\n   571→      return true;\n   572→    case \"tuicraft\":\n   573→      if (cmd.subcommand === \"entities\") {\n   574→        if (cmd.value === \"on\") {\n   575→          state.showEntityEvents = true;\n   576→          state.write(\"[system] Entity events enabled\\n\");\n   577→        } else if (cmd.value === \"off\") {\n   578→          state.showEntityEvents = false;\n   579→          state.write(\"[system] Entity events disabled\\n\");\n   580→        } else {\n   581→          state.write(\"[system] Usage: /tuicraft entities on|off\\n\");\n   582→        }\n   583→      } else {\n   584→        state.write(`[system] Unknown tuicraft command: ${cmd.subcommand}\\n`);\n   585→      }\n   586→      break;\n   587→    case \"friends\": {\n   588→      const friends = state.handle.getFriends();\n   589→      state.write(formatFriendList(friends) + \"\\n\");\n   590→      break;\n   591→    }\n   592→    case \"add-friend\":\n   593→      state.handle.addFriend(cmd.target);\n   594→      break;\n   595→    case \"remove-friend\":\n   596→      state.handle.removeFriend(cmd.target);\n   597→      break;\n   598→    case \"unimplemented\":\n   599→      state.write(formatError(`${cmd.feature} is not yet implemented`) + \"\\n\");\n   600→      break;\n   601→  }\n   602→  return false;\n   603→}\n   604→\n   605→export type TuiOptions = {\n   606→  input?: NodeJS.ReadableStream;\n   607→  write?: (s: string) => void;\n   608→};\n   609→\n   610→export function startTui(\n   611→  handle: WorldHandle,\n   612→  interactive: boolean,\n   613→  opts: TuiOptions = {},\n   614→): Promise<void> {\n   615→  const write = opts.write ?? ((s: string) => void process.stdout.write(s));\n   616→  const state: TuiState = {\n   617→    handle,\n   618→    write,\n   619→    lastWhisperFrom: undefined,\n   620→    showEntityEvents: false,\n   621→  };\n   622→\n   623→  return new Promise<void>((resolve) => {\n   624→    handle.onMessage((msg) => {\n   625→      if (msg.type === ChatType.WHISPER) state.lastWhisperFrom = msg.sender;\n   626→      const line = formatMessage(msg);\n   627→      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n   628→      if (interactive) rl.prompt(true);\n   629→    });\n   630→\n   631→    handle.onGroupEvent((event) => {\n   632→      const line = formatGroupEvent(event);\n   633→      if (!line) return;\n   634→      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n   635→      if (interactive) rl.prompt(true);\n   636→    });\n   637→\n   638→    handle.onEntityEvent((event) => {\n   639→      if (!state.showEntityEvents) return;\n   640→      const line = formatEntityEvent(event);\n   641→      if (!line) return;\n   642→      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n   643→      if (interactive) rl.prompt(true);\n   644→    });\n   645→\n   646→    const rl = createInterface({\n   647→      input: opts.input ?? process.stdin,\n   648→      output: interactive ? process.stdout : undefined,\n   649→      prompt: interactive ? formatPrompt(handle.getLastChatMode()) : \"\",\n   650→      terminal: interactive,\n   651→    });\n   652→\n   653→    if (interactive) rl.prompt();\n   654→\n   655→    rl.on(\"line\", async (input) => {\n   656→      try {\n   657→        if (await executeCommand(state, parseCommand(input.trim()))) {\n   658→          handle.close();\n   659→          rl.close();\n   660→          resolve();\n   661→          return;\n   662→        }\n   663→      } catch (err) {\n   664→        const msg = err instanceof Error ? err.message : String(err);\n   665→        write(formatError(msg) + \"\\n\");\n   666→      }\n   667→      if (interactive) {\n   668→        rl.setPrompt(formatPrompt(handle.getLastChatMode()));\n   669→        rl.prompt();\n   670→      }\n   671→    });\n   672→\n   673→    rl.on(\"SIGINT\", () => {\n   674→      handle.close();\n   675→      rl.close();\n   676→    });\n   677→\n   678→    rl.on(\"close\", () => {\n   679→      handle.close();\n   680→      resolve();\n   681→    });\n   682→\n   683→    handle.closed.then(() => rl.close());\n   684→  });\n   685→}\n   686→"}]},"uuid":"aa6c6d4c-42d0-4166-9cdb-db46651365b2","timestamp":"2026-02-28T23:41:44.778Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.ts","content":"import { createInterface } from \"node:readline\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  WhoResult,\n  GroupEvent,\n} from \"wow/client\";\nimport type { EntityEvent, UnitEntity } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { LogEntry } from \"lib/session-log\";\nimport { stripColorCodes } from \"lib/strip-colors\";\n\nexport type Command =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"raid\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"reply\"; message: string }\n  | { type: \"channel\"; target: string; message: string }\n  | { type: \"who\"; target?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"quit\" }\n  | { type: \"tuicraft\"; subcommand: string; value: string }\n  | { type: \"friends\" }\n  | { type: \"add-friend\"; target: string }\n  | { type: \"remove-friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseCommand(input: string): Command {\n  if (!input.startsWith(\"/\")) return { type: \"chat\", message: input };\n\n  const spaceIdx = input.indexOf(\" \");\n  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : input.slice(spaceIdx + 1);\n\n  switch (cmd) {\n    case \"/s\":\n    case \"/say\":\n      return { type: \"say\", message: rest };\n    case \"/y\":\n    case \"/yell\":\n      return { type: \"yell\", message: rest };\n    case \"/g\":\n    case \"/guild\":\n      return { type: \"guild\", message: rest };\n    case \"/p\":\n    case \"/party\":\n      return { type: \"party\", message: rest };\n    case \"/raid\":\n      return { type: \"raid\", message: rest };\n    case \"/w\":\n    case \"/whisper\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"/r\":\n      return { type: \"reply\", message: rest };\n    case \"/who\":\n      return rest ? { type: \"who\", target: rest } : { type: \"who\" };\n    case \"/invite\":\n      return rest\n        ? { type: \"invite\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/kick\":\n      return rest\n        ? { type: \"kick\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/leave\":\n      return { type: \"leave\" };\n    case \"/leader\":\n      return rest\n        ? { type: \"leader\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/accept\":\n      return { type: \"accept\" };\n    case \"/decline\":\n      return { type: \"decline\" };\n    case \"/quit\":\n      return { type: \"quit\" };\n    case \"/tuicraft\": {\n      const parts = rest.split(\" \");\n      return {\n        type: \"tuicraft\",\n        subcommand: parts[0] ?? \"\",\n        value: parts[1] ?? \"\",\n      };\n    }\n    case \"/friends\":\n      return { type: \"friends\" };\n    case \"/f\":\n      return { type: \"friends\" };\n    case \"/friend\": {\n      const parts = rest.split(\" \");\n      const sub = parts[0] ?? \"\";\n      const target = parts.slice(1).join(\" \");\n      if (sub === \"add\" && target) return { type: \"add-friend\", target };\n      if (sub === \"remove\" && target) return { type: \"remove-friend\", target };\n      return { type: \"friends\" };\n    }\n    case \"/ignore\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"/join\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"/ginvite\":\n    case \"/gkick\":\n    case \"/gleave\":\n    case \"/gpromote\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"/mail\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"/roll\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"/dnd\":\n    case \"/afk\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"/e\":\n    case \"/emote\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default: {\n      const channelMatch = cmd.match(/^\\/(\\d+)$/);\n      if (channelMatch) {\n        return { type: \"channel\", target: channelMatch[1]!, message: rest };\n      }\n      return { type: \"say\", message: input };\n    }\n  }\n}\n\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.OFFICER]: \"officer\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.CHANNEL]: \"channel\",\n  [ChatType.RAID_LEADER]: \"raid leader\",\n  [ChatType.RAID_WARNING]: \"raid warning\",\n  [ChatType.PARTY_LEADER]: \"party leader\",\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.WHISPER_INFORM) {\n    return `[whisper to ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.SYSTEM) {\n    return `[system] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"SYSTEM\",\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.PARTY]: \"PARTY\",\n  [ChatType.RAID]: \"RAID\",\n  [ChatType.GUILD]: \"GUILD\",\n  [ChatType.OFFICER]: \"OFFICER\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.WHISPER]: \"WHISPER_FROM\",\n  [ChatType.WHISPER_INFORM]: \"WHISPER_TO\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  [ChatType.CHANNEL]: \"CHANNEL\",\n  [ChatType.RAID_LEADER]: \"RAID_LEADER\",\n  [ChatType.RAID_WARNING]: \"RAID_WARNING\",\n  [ChatType.PARTY_LEADER]: \"PARTY_LEADER\",\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n\nexport function formatMessageJson(msg: ChatMessage): string {\n  return JSON.stringify(formatMessageObj(msg));\n}\n\nexport function formatError(message: string): string {\n  return `[system] ${message}`;\n}\n\nexport function formatWhoResults(results: WhoResult[]): string {\n  const names =\n    results.map((r) => `${r.name} (${r.level})`).join(\", \") || \"none\";\n  return `[who] ${results.length} results: ${names}`;\n}\n\nexport function formatWhoResultsJson(results: WhoResult[]): string {\n  return JSON.stringify({\n    type: \"WHO\",\n    count: results.length,\n    results: results.map((r) => ({\n      name: r.name,\n      guild: r.guild,\n      level: r.level,\n      classId: r.classId,\n      race: r.race,\n      gender: r.gender,\n      zone: r.zone,\n    })),\n  });\n}\n\nexport function formatPrompt(mode: ChatMode): string {\n  switch (mode.type) {\n    case \"whisper\":\n      return `[whisper: ${mode.target}] > `;\n    case \"channel\":\n      return `[${mode.channel}] > `;\n    default:\n      return `[${mode.type}] > `;\n  }\n}\n\nfunction partyResultLabel(result: number): string {\n  switch (result) {\n    case PartyResult.BAD_PLAYER_NAME:\n      return \"player not found\";\n    case PartyResult.GROUP_FULL:\n      return \"group is full\";\n    case PartyResult.ALREADY_IN_GROUP:\n      return \"already in a group\";\n    case PartyResult.NOT_LEADER:\n      return \"you are not the leader\";\n    case PartyResult.PLAYER_WRONG_FACTION:\n      return \"wrong faction\";\n    case PartyResult.IGNORING_YOU:\n      return \"player is ignoring you\";\n    default:\n      return `error ${result}`;\n  }\n}\n\nexport function formatGroupEvent(event: GroupEvent): string | undefined {\n  switch (event.type) {\n    case \"invite_received\":\n      return `[group] ${event.from} invites you to a group`;\n    case \"command_result\": {\n      const verb =\n        event.operation === PartyOperation.UNINVITE\n          ? \"kick\"\n          : event.operation === PartyOperation.LEAVE\n            ? \"leave\"\n            : \"invite\";\n      const label =\n        event.result === PartyResult.SUCCESS\n          ? verb === \"kick\"\n            ? `Removed ${event.target} from group`\n            : verb === \"leave\"\n              ? \"Left the group\"\n              : `Invited ${event.target}`\n          : `Cannot ${verb}${event.target ? ` ${event.target}` : \"\"}: ${partyResultLabel(event.result)}`;\n      return `[group] ${label}`;\n    }\n    case \"leader_changed\":\n      return `[group] ${event.name} is now the group leader`;\n    case \"group_destroyed\":\n      return \"[group] Group has been disbanded\";\n    case \"kicked\":\n      return \"[group] You have been removed from the group\";\n    case \"invite_declined\":\n      return `[group] ${event.name} has declined your invitation`;\n    case \"group_list\":\n    case \"member_stats\":\n      return undefined;\n  }\n}\n\nexport function formatEntityEvent(event: EntityEvent): string | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      if (!e.name) return undefined;\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        const kind = e.objectType === ObjectType.PLAYER ? \"Player\" : \"NPC\";\n        const levelStr = unit.level > 0 ? `, level ${unit.level}` : \"\";\n        return `[world] ${e.name} appeared (${kind}${levelStr})`;\n      }\n      if (e.objectType === ObjectType.GAMEOBJECT) {\n        return `[world] ${e.name} appeared (GameObject)`;\n      }\n      return undefined;\n    }\n    case \"disappear\": {\n      const name = event.name ?? \"Unknown entity\";\n      return `[world] ${name} left range`;\n    }\n    case \"update\": {\n      if (!event.changed.includes(\"name\") || !event.entity.name)\n        return undefined;\n      return formatEntityEvent({ type: \"appear\", entity: event.entity });\n    }\n  }\n}\n\nexport function formatEntityEventObj(\n  event: EntityEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      const obj: Record<string, unknown> = {\n        type: \"ENTITY_APPEAR\",\n        guid: `0x${e.guid.toString(16)}`,\n        objectType: e.objectType,\n        name: e.name,\n      };\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        obj[\"level\"] = unit.level;\n        obj[\"health\"] = unit.health;\n        obj[\"maxHealth\"] = unit.maxHealth;\n      }\n      if (e.position) {\n        obj[\"x\"] = e.position.x;\n        obj[\"y\"] = e.position.y;\n        obj[\"z\"] = e.position.z;\n      }\n      return obj;\n    }\n    case \"disappear\":\n      return {\n        type: \"ENTITY_DISAPPEAR\",\n        guid: `0x${event.guid.toString(16)}`,\n        name: event.name,\n      };\n    case \"update\":\n      return undefined;\n  }\n}\n\nconst CLASS_NAMES: Record<number, string> = {\n  1: \"Warrior\",\n  2: \"Paladin\",\n  3: \"Hunter\",\n  4: \"Rogue\",\n  5: \"Priest\",\n  6: \"Death Knight\",\n  7: \"Shaman\",\n  8: \"Mage\",\n  9: \"Warlock\",\n  11: \"Druid\",\n};\n\nfunction friendStatusLabel(status: number): string {\n  if (status === FriendStatus.AFK) return \"AFK\";\n  if (status === FriendStatus.DND) return \"DND\";\n  if (status !== FriendStatus.OFFLINE) return \"Online\";\n  return \"Offline\";\n}\n\nexport function formatFriendList(friends: FriendEntry[]): string {\n  if (friends.length === 0) return \"[friends] No friends on your list\";\n  const lines = friends.map((f) => {\n    const name = f.name || `guid:${Number(f.guid & 0xffffffffn)}`;\n    if (f.status === FriendStatus.OFFLINE) return `  ${name} — Offline`;\n    const cls = CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`;\n    const statusLabel = friendStatusLabel(f.status);\n    return `  ${name} — ${statusLabel}, Level ${f.level} ${cls}`;\n  });\n  const online = friends.filter(\n    (f) => f.status !== FriendStatus.OFFLINE,\n  ).length;\n  return `[friends] ${online}/${friends.length} online\\n${lines.join(\"\\n\")}`;\n}\n\nexport function formatFriendListJson(friends: FriendEntry[]): string {\n  return JSON.stringify({\n    type: \"FRIENDS\",\n    count: friends.length,\n    online: friends.filter((f) => f.status !== FriendStatus.OFFLINE).length,\n    friends: friends.map((f) => ({\n      guid: `0x${f.guid.toString(16)}`,\n      name: f.name,\n      note: f.note,\n      status: friendStatusLabel(f.status).toUpperCase(),\n      level: f.level,\n      class: CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`,\n      area: f.area,\n    })),\n  });\n}\n\nfunction friendResultLabel(result: number): string {\n  const labels: Record<number, string> = {\n    0x00: \"database error\",\n    0x01: \"friends list is full\",\n    0x04: \"player not found\",\n    0x08: \"already on friends list\",\n    0x09: \"cannot add yourself\",\n    0x0a: \"cannot add enemy faction\",\n  };\n  return labels[result] ?? `error ${result}`;\n}\n\nexport function formatFriendEvent(event: FriendEvent): string | undefined {\n  switch (event.type) {\n    case \"friend-online\": {\n      const f = event.friend;\n      const cls = CLASS_NAMES[f.playerClass] ?? \"\";\n      const lvl = f.level ? `Level ${f.level}` : \"\";\n      const detail = [lvl, cls].filter(Boolean).join(\" \");\n      return `[friends] ${f.name || \"Unknown\"} is now online${detail ? ` (${detail})` : \"\"}`;\n    }\n    case \"friend-offline\":\n      return `[friends] ${event.name || \"Unknown\"} went offline`;\n    case \"friend-added\": {\n      const f = event.friend;\n      return `[friends] ${f.name || \"Unknown\"} added to friends list`;\n    }\n    case \"friend-removed\":\n      return `[friends] ${event.name || \"Unknown\"} removed from friends list`;\n    case \"friend-error\":\n      return `[friends] Error: ${friendResultLabel(event.result)}`;\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport function formatFriendEventObj(\n  event: FriendEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"friend-online\":\n      return {\n        type: \"FRIEND_ONLINE\",\n        name: event.friend.name,\n        level: event.friend.level,\n        class: CLASS_NAMES[event.friend.playerClass],\n        area: event.friend.area,\n      };\n    case \"friend-offline\":\n      return { type: \"FRIEND_OFFLINE\", name: event.name };\n    case \"friend-added\":\n      return { type: \"FRIEND_ADDED\", name: event.friend.name };\n    case \"friend-removed\":\n      return { type: \"FRIEND_REMOVED\", name: event.name };\n    case \"friend-error\":\n      return {\n        type: \"FRIEND_ERROR\",\n        result: event.result,\n        message: friendResultLabel(event.result),\n      };\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport type TuiState = {\n  handle: WorldHandle;\n  write: (s: string) => void;\n  lastWhisperFrom: string | undefined;\n  showEntityEvents: boolean;\n};\n\nexport async function executeCommand(\n  state: TuiState,\n  cmd: Command,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\":\n      state.handle.sendInCurrentMode(cmd.message);\n      break;\n    case \"say\":\n      state.handle.sendSay(cmd.message);\n      break;\n    case \"yell\":\n      state.handle.sendYell(cmd.message);\n      break;\n    case \"guild\":\n      state.handle.sendGuild(cmd.message);\n      break;\n    case \"party\":\n      state.handle.sendParty(cmd.message);\n      break;\n    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"whisper\":\n      state.handle.sendWhisper(cmd.target, cmd.message);\n      state.lastWhisperFrom = cmd.target;\n      break;\n    case \"reply\":\n      if (!state.lastWhisperFrom) {\n        state.write(formatError(\"No one has whispered you yet.\") + \"\\n\");\n      } else {\n        state.handle.sendWhisper(state.lastWhisperFrom, cmd.message);\n      }\n      break;\n    case \"channel\": {\n      const channel = /^\\d+$/.test(cmd.target)\n        ? state.handle.getChannel(parseInt(cmd.target, 10))\n        : cmd.target;\n      if (!channel) {\n        state.write(formatError(`Not in channel ${cmd.target}.`) + \"\\n\");\n      } else {\n        state.handle.sendChannel(channel, cmd.message);\n      }\n      break;\n    }\n    case \"who\": {\n      const results = await state.handle.who(\n        cmd.target ? { name: cmd.target } : {},\n      );\n      state.write(formatWhoResults(results) + \"\\n\");\n      break;\n    }\n    case \"invite\":\n      state.handle.invite(cmd.target);\n      break;\n    case \"kick\":\n      state.handle.uninvite(cmd.target);\n      break;\n    case \"leave\":\n      state.handle.leaveGroup();\n      break;\n    case \"leader\":\n      state.handle.setLeader(cmd.target);\n      break;\n    case \"accept\":\n      state.handle.acceptInvite();\n      break;\n    case \"decline\":\n      state.handle.declineInvite();\n      break;\n    case \"quit\":\n      return true;\n    case \"tuicraft\":\n      if (cmd.subcommand === \"entities\") {\n        if (cmd.value === \"on\") {\n          state.showEntityEvents = true;\n          state.write(\"[system] Entity events enabled\\n\");\n        } else if (cmd.value === \"off\") {\n          state.showEntityEvents = false;\n          state.write(\"[system] Entity events disabled\\n\");\n        } else {\n          state.write(\"[system] Usage: /tuicraft entities on|off\\n\");\n        }\n      } else {\n        state.write(`[system] Unknown tuicraft command: ${cmd.subcommand}\\n`);\n      }\n      break;\n    case \"friends\": {\n      const friends = state.handle.getFriends();\n      state.write(formatFriendList(friends) + \"\\n\");\n      break;\n    }\n    case \"add-friend\":\n      state.handle.addFriend(cmd.target);\n      break;\n    case \"remove-friend\":\n      state.handle.removeFriend(cmd.target);\n      break;\n    case \"unimplemented\":\n      state.write(formatError(`${cmd.feature} is not yet implemented`) + \"\\n\");\n      break;\n  }\n  return false;\n}\n\nexport type TuiOptions = {\n  input?: NodeJS.ReadableStream;\n  write?: (s: string) => void;\n};\n\nexport function startTui(\n  handle: WorldHandle,\n  interactive: boolean,\n  opts: TuiOptions = {},\n): Promise<void> {\n  const write = opts.write ?? ((s: string) => void process.stdout.write(s));\n  const state: TuiState = {\n    handle,\n    write,\n    lastWhisperFrom: undefined,\n    showEntityEvents: false,\n  };\n\n  return new Promise<void>((resolve) => {\n    handle.onMessage((msg) => {\n      if (msg.type === ChatType.WHISPER) state.lastWhisperFrom = msg.sender;\n      const line = formatMessage(msg);\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onGroupEvent((event) => {\n      const line = formatGroupEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onEntityEvent((event) => {\n      if (!state.showEntityEvents) return;\n      const line = formatEntityEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    const rl = createInterface({\n      input: opts.input ?? process.stdin,\n      output: interactive ? process.stdout : undefined,\n      prompt: interactive ? formatPrompt(handle.getLastChatMode()) : \"\",\n      terminal: interactive,\n    });\n\n    if (interactive) rl.prompt();\n\n    rl.on(\"line\", async (input) => {\n      try {\n        if (await executeCommand(state, parseCommand(input.trim()))) {\n          handle.close();\n          rl.close();\n          resolve();\n          return;\n        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        write(formatError(msg) + \"\\n\");\n      }\n      if (interactive) {\n        rl.setPrompt(formatPrompt(handle.getLastChatMode()));\n        rl.prompt();\n      }\n    });\n\n    rl.on(\"SIGINT\", () => {\n      handle.close();\n      rl.close();\n    });\n\n    rl.on(\"close\", () => {\n      handle.close();\n      resolve();\n    });\n\n    handle.closed.then(() => rl.close());\n  });\n}\n","numLines":686,"startLine":1,"totalLines":686}},"sourceToolAssistantUUID":"61ea908a-b7cc-494e-8bdd-70bf2cbdba17"}
{"parentUuid":"aa6c6d4c-42d0-4166-9cdb-db46651365b2","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01L8BPY4eheJsSLZzbttpNXc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LzpJSe4RLH9dJ7F3cSX3Fx","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":468,"cache_read_input_tokens":35387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":468},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPFQpd9dxLN3WxBFjP","type":"assistant","uuid":"a58218af-e4e2-4db1-80a3-64dc4d5dc9d1","timestamp":"2026-02-28T23:41:45.040Z"}
{"parentUuid":"a58218af-e4e2-4db1-80a3-64dc4d5dc9d1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LzpJSe4RLH9dJ7F3cSX3Fx","type":"tool_result","content":"     1→import { RingBuffer } from \"lib/ring-buffer\";\n     2→import {\n     3→  formatMessage,\n     4→  formatMessageObj,\n     5→  formatWhoResults,\n     6→  formatWhoResultsJson,\n     7→  formatGroupEvent,\n     8→  formatEntityEvent,\n     9→  formatEntityEventObj,\n    10→  formatFriendList,\n    11→  formatFriendListJson,\n    12→  formatFriendEvent,\n    13→  formatFriendEventObj,\n    14→  parseCommand,\n    15→} from \"ui/tui\";\n    16→import type { FriendEvent } from \"wow/friend-store\";\n    17→import { SessionLog, type LogEntry } from \"lib/session-log\";\n    18→import type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\n    19→import { ObjectType } from \"wow/protocol/entity-fields\";\n    20→import type {\n    21→  Entity,\n    22→  UnitEntity,\n    23→  GameObjectEntity,\n    24→  EntityEvent,\n    25→} from \"wow/entity-store\";\n    26→\n    27→export type EventEntry = { text: string | undefined; json: string };\n    28→\n    29→export type IpcSocket = {\n    30→  write(data: string | Uint8Array): number;\n    31→  end(): void;\n    32→};\n    33→\n    34→export type IpcCommand =\n    35→  | { type: \"chat\"; message: string }\n    36→  | { type: \"say\"; message: string }\n    37→  | { type: \"yell\"; message: string }\n    38→  | { type: \"guild\"; message: string }\n    39→  | { type: \"party\"; message: string }\n    40→  | { type: \"whisper\"; target: string; message: string }\n    41→  | { type: \"read\" }\n    42→  | { type: \"read_json\" }\n    43→  | { type: \"read_wait\"; ms: number }\n    44→  | { type: \"read_wait_json\"; ms: number }\n    45→  | { type: \"stop\" }\n    46→  | { type: \"status\" }\n    47→  | { type: \"who\"; filter?: string }\n    48→  | { type: \"who_json\"; filter?: string }\n    49→  | { type: \"invite\"; target: string }\n    50→  | { type: \"kick\"; target: string }\n    51→  | { type: \"leave\" }\n    52→  | { type: \"leader\"; target: string }\n    53→  | { type: \"accept\" }\n    54→  | { type: \"decline\" }\n    55→  | { type: \"nearby\" }\n    56→  | { type: \"nearby_json\" }\n    57→  | { type: \"friends\" }\n    58→  | { type: \"friends_json\" }\n    59→  | { type: \"add_friend\"; target: string }\n    60→  | { type: \"del_friend\"; target: string }\n    61→  | { type: \"unimplemented\"; feature: string };\n    62→\n    63→export function parseIpcCommand(line: string): IpcCommand | undefined {\n    64→  if (line.startsWith(\"/\")) {\n    65→    const parsed = parseCommand(line);\n    66→    switch (parsed.type) {\n    67→      case \"say\":\n    68→      case \"yell\":\n    69→      case \"guild\":\n    70→      case \"party\":\n    71→        return parsed;\n    72→      case \"whisper\":\n    73→        return parsed;\n    74→      case \"who\":\n    75→        return parsed.target\n    76→          ? { type: \"who\", filter: parsed.target }\n    77→          : { type: \"who\" };\n    78→      case \"invite\":\n    79→      case \"kick\":\n    80→      case \"leave\":\n    81→      case \"leader\":\n    82→      case \"accept\":\n    83→      case \"decline\":\n    84→        return parsed;\n    85→      case \"friends\":\n    86→        return { type: \"friends\" };\n    87→      case \"add-friend\":\n    88→        return { type: \"add_friend\", target: parsed.target };\n    89→      case \"remove-friend\":\n    90→        return { type: \"del_friend\", target: parsed.target };\n    91→      case \"unimplemented\":\n    92→        return parsed;\n    93→      default:\n    94→        return { type: \"say\", message: line };\n    95→    }\n    96→  }\n    97→\n    98→  const spaceIdx = line.indexOf(\" \");\n    99→  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n   100→  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n   101→\n   102→  switch (verb) {\n   103→    case \"SAY\":\n   104→    case \"YELL\":\n   105→    case \"GUILD\":\n   106→    case \"PARTY\":\n   107→      return {\n   108→        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n   109→        message: rest,\n   110→      };\n   111→    case \"WHISPER\": {\n   112→      const targetEnd = rest.indexOf(\" \");\n   113→      if (targetEnd === -1)\n   114→        return { type: \"whisper\", target: rest, message: \"\" };\n   115→      return {\n   116→        type: \"whisper\",\n   117→        target: rest.slice(0, targetEnd),\n   118→        message: rest.slice(targetEnd + 1),\n   119→      };\n   120→    }\n   121→    case \"READ\":\n   122→      return { type: \"read\" };\n   123→    case \"READ_JSON\":\n   124→      return { type: \"read_json\" };\n   125→    case \"READ_WAIT\": {\n   126→      const ms = parseInt(rest, 10);\n   127→      if (!Number.isFinite(ms) || ms < 0) return undefined;\n   128→      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n   129→    }\n   130→    case \"READ_WAIT_JSON\": {\n   131→      const ms = parseInt(rest, 10);\n   132→      if (!Number.isFinite(ms) || ms < 0) return undefined;\n   133→      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n   134→    }\n   135→    case \"STOP\":\n   136→      return { type: \"stop\" };\n   137→    case \"STATUS\":\n   138→      return { type: \"status\" };\n   139→    case \"WHO\":\n   140→      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n   141→    case \"WHO_JSON\":\n   142→      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n   143→    case \"INVITE\":\n   144→      return rest ? { type: \"invite\", target: rest } : undefined;\n   145→    case \"KICK\":\n   146→      return rest ? { type: \"kick\", target: rest } : undefined;\n   147→    case \"LEAVE\":\n   148→      return { type: \"leave\" };\n   149→    case \"LEADER\":\n   150→      return rest ? { type: \"leader\", target: rest } : undefined;\n   151→    case \"ACCEPT\":\n   152→      return { type: \"accept\" };\n   153→    case \"DECLINE\":\n   154→      return { type: \"decline\" };\n   155→    case \"NEARBY\":\n   156→      return { type: \"nearby\" };\n   157→    case \"NEARBY_JSON\":\n   158→      return { type: \"nearby_json\" };\n   159→    case \"FRIENDS\":\n   160→      return { type: \"friends\" };\n   161→    case \"FRIENDS_JSON\":\n   162→      return { type: \"friends_json\" };\n   163→    case \"ADD_FRIEND\":\n   164→      return rest ? { type: \"add_friend\", target: rest } : undefined;\n   165→    case \"DEL_FRIEND\":\n   166→      return rest ? { type: \"del_friend\", target: rest } : undefined;\n   167→    case \"IGNORE\":\n   168→      return { type: \"unimplemented\", feature: \"Ignore list\" };\n   169→    case \"JOIN\":\n   170→      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n   171→    case \"GINVITE\":\n   172→    case \"GKICK\":\n   173→    case \"GLEAVE\":\n   174→    case \"GPROMOTE\":\n   175→      return { type: \"unimplemented\", feature: \"Guild management\" };\n   176→    case \"MAIL\":\n   177→      return { type: \"unimplemented\", feature: \"Mail\" };\n   178→    case \"ROLL\":\n   179→      return { type: \"unimplemented\", feature: \"Random roll\" };\n   180→    case \"DND\":\n   181→    case \"AFK\":\n   182→      return { type: \"unimplemented\", feature: \"Player status\" };\n   183→    case \"EMOTE\":\n   184→      return { type: \"unimplemented\", feature: \"Text emotes\" };\n   185→    default:\n   186→      return line ? { type: \"chat\", message: line } : undefined;\n   187→  }\n   188→}\n   189→\n   190→export function writeLines(socket: IpcSocket, lines: string[]): void {\n   191→  for (const line of lines) socket.write(line + \"\\n\");\n   192→  socket.write(\"\\n\");\n   193→}\n   194→\n   195→function drainText(events: RingBuffer<EventEntry>): string[] {\n   196→  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n   197→}\n   198→\n   199→function drainJson(events: RingBuffer<EventEntry>): string[] {\n   200→  return events.drain().map((e) => e.json);\n   201→}\n   202→\n   203→function sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n   204→  return events\n   205→    .slice(from)\n   206→    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n   207→}\n   208→\n   209→function sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n   210→  return events.slice(from).map((e) => e.json);\n   211→}\n   212→\n   213→export async function dispatchCommand(\n   214→  cmd: IpcCommand,\n   215→  handle: WorldHandle,\n   216→  events: RingBuffer<EventEntry>,\n   217→  socket: IpcSocket,\n   218→  cleanup: () => void,\n   219→): Promise<boolean> {\n   220→  switch (cmd.type) {\n   221→    case \"chat\": {\n   222→      handle.sendInCurrentMode(cmd.message);\n   223→      const mode = handle.getLastChatMode();\n   224→      const label =\n   225→        mode.type === \"whisper\"\n   226→          ? `WHISPER ${mode.target}`\n   227→          : mode.type === \"channel\"\n   228→            ? `CHANNEL ${mode.channel}`\n   229→            : mode.type.toUpperCase();\n   230→      writeLines(socket, [`OK ${label}`]);\n   231→      return false;\n   232→    }\n   233→    case \"say\":\n   234→      handle.sendSay(cmd.message);\n   235→      writeLines(socket, [\"OK\"]);\n   236→      return false;\n   237→    case \"yell\":\n   238→      handle.sendYell(cmd.message);\n   239→      writeLines(socket, [\"OK\"]);\n   240→      return false;\n   241→    case \"guild\":\n   242→      handle.sendGuild(cmd.message);\n   243→      writeLines(socket, [\"OK\"]);\n   244→      return false;\n   245→    case \"party\":\n   246→      handle.sendParty(cmd.message);\n   247→      writeLines(socket, [\"OK\"]);\n   248→      return false;\n   249→    case \"whisper\":\n   250→      handle.sendWhisper(cmd.target, cmd.message);\n   251→      writeLines(socket, [\"OK\"]);\n   252→      return false;\n   253→    case \"read\":\n   254→      writeLines(socket, drainText(events));\n   255→      return false;\n   256→    case \"read_json\":\n   257→      writeLines(socket, drainJson(events));\n   258→      return false;\n   259→    case \"read_wait\": {\n   260→      const start = events.writePos;\n   261→      await new Promise<void>((resolve) => {\n   262→        setTimeout(() => {\n   263→          writeLines(socket, sliceText(events, start));\n   264→          resolve();\n   265→        }, cmd.ms);\n   266→      });\n   267→      return false;\n   268→    }\n   269→    case \"read_wait_json\": {\n   270→      const start = events.writePos;\n   271→      await new Promise<void>((resolve) => {\n   272→        setTimeout(() => {\n   273→          writeLines(socket, sliceJson(events, start));\n   274→          resolve();\n   275→        }, cmd.ms);\n   276→      });\n   277→      return false;\n   278→    }\n   279→    case \"stop\":\n   280→      writeLines(socket, [\"OK\"]);\n   281→      cleanup();\n   282→      return true;\n   283→    case \"status\":\n   284→      writeLines(socket, [\"CONNECTED\"]);\n   285→      return false;\n   286→    case \"who\": {\n   287→      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n   288→      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n   289→      return false;\n   290→    }\n   291→    case \"who_json\": {\n   292→      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n   293→      writeLines(socket, [formatWhoResultsJson(results)]);\n   294→      return false;\n   295→    }\n   296→    case \"invite\":\n   297→      handle.invite(cmd.target);\n   298→      writeLines(socket, [\"OK\"]);\n   299→      return false;\n   300→    case \"kick\":\n   301→      handle.uninvite(cmd.target);\n   302→      writeLines(socket, [\"OK\"]);\n   303→      return false;\n   304→    case \"leave\":\n   305→      handle.leaveGroup();\n   306→      writeLines(socket, [\"OK\"]);\n   307→      return false;\n   308→    case \"leader\":\n   309→      handle.setLeader(cmd.target);\n   310→      writeLines(socket, [\"OK\"]);\n   311→      return false;\n   312→    case \"accept\":\n   313→      handle.acceptInvite();\n   314→      writeLines(socket, [\"OK\"]);\n   315→      return false;\n   316→    case \"decline\":\n   317→      handle.declineInvite();\n   318→      writeLines(socket, [\"OK\"]);\n   319→      return false;\n   320→    case \"nearby\": {\n   321→      const entities = handle.getNearbyEntities();\n   322→      writeLines(socket, entities.map(formatNearbyLine));\n   323→      return false;\n   324→    }\n   325→    case \"nearby_json\": {\n   326→      const entities = handle.getNearbyEntities();\n   327→      writeLines(\n   328→        socket,\n   329→        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n   330→      );\n   331→      return false;\n   332→    }\n   333→    case \"friends\": {\n   334→      const friends = handle.getFriends();\n   335→      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n   336→      return false;\n   337→    }\n   338→    case \"friends_json\": {\n   339→      const friends = handle.getFriends();\n   340→      writeLines(socket, [formatFriendListJson(friends)]);\n   341→      return false;\n   342→    }\n   343→    case \"add_friend\":\n   344→      handle.addFriend(cmd.target);\n   345→      writeLines(socket, [\"OK\"]);\n   346→      return false;\n   347→    case \"del_friend\":\n   348→      handle.removeFriend(cmd.target);\n   349→      writeLines(socket, [\"OK\"]);\n   350→      return false;\n   351→    case \"unimplemented\":\n   352→      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n   353→      return false;\n   354→  }\n   355→}\n   356→\n   357→function objectTypeName(type: ObjectType): string {\n   358→  switch (type) {\n   359→    case ObjectType.UNIT:\n   360→      return \"NPC\";\n   361→    case ObjectType.PLAYER:\n   362→      return \"Player\";\n   363→    default:\n   364→      return `type ${type}`;\n   365→  }\n   366→}\n   367→\n   368→function formatNearbyLine(entity: Entity): string {\n   369→  if (\n   370→    entity.objectType === ObjectType.UNIT ||\n   371→    entity.objectType === ObjectType.PLAYER\n   372→  ) {\n   373→    const unit = entity as UnitEntity;\n   374→    const name = entity.name ?? \"Unknown\";\n   375→    const kind = objectTypeName(entity.objectType);\n   376→    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n   377→    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n   378→    const pos = entity.position\n   379→      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n   380→      : \"\";\n   381→    return `${name} (${kind}${level}) ${hp}${pos}`;\n   382→  }\n   383→  if (entity.objectType === ObjectType.GAMEOBJECT) {\n   384→    const name = entity.name ?? \"Unknown\";\n   385→    const pos = entity.position\n   386→      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n   387→      : \"\";\n   388→    return `${name} (GameObject)${pos}`;\n   389→  }\n   390→  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n   391→}\n   392→\n   393→function objectTypeString(type: ObjectType): string {\n   394→  switch (type) {\n   395→    case ObjectType.UNIT:\n   396→      return \"unit\";\n   397→    case ObjectType.PLAYER:\n   398→      return \"player\";\n   399→    case ObjectType.GAMEOBJECT:\n   400→      return \"gameobject\";\n   401→    default:\n   402→      return \"object\";\n   403→  }\n   404→}\n   405→\n   406→function formatNearbyObj(entity: Entity): Record<string, unknown> {\n   407→  const obj: Record<string, unknown> = {\n   408→    guid: `0x${entity.guid.toString(16)}`,\n   409→    type: objectTypeString(entity.objectType),\n   410→    name: entity.name,\n   411→  };\n   412→  if (\n   413→    entity.objectType === ObjectType.UNIT ||\n   414→    entity.objectType === ObjectType.PLAYER\n   415→  ) {\n   416→    const unit = entity as UnitEntity;\n   417→    obj[\"level\"] = unit.level;\n   418→    obj[\"health\"] = unit.health;\n   419→    obj[\"maxHealth\"] = unit.maxHealth;\n   420→  }\n   421→  if (entity.objectType === ObjectType.GAMEOBJECT) {\n   422→    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n   423→  }\n   424→  if (entity.position) {\n   425→    obj[\"x\"] = entity.position.x;\n   426→    obj[\"y\"] = entity.position.y;\n   427→    obj[\"z\"] = entity.position.z;\n   428→  }\n   429→  return obj;\n   430→}\n   431→\n   432→function formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n   433→  switch (event.type) {\n   434→    case \"invite_received\":\n   435→      return { type: \"GROUP_INVITE\", from: event.from };\n   436→    case \"command_result\":\n   437→      return {\n   438→        type: \"GROUP_COMMAND_RESULT\",\n   439→        operation: event.operation,\n   440→        target: event.target,\n   441→        result: event.result,\n   442→      };\n   443→    case \"leader_changed\":\n   444→      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n   445→    case \"group_destroyed\":\n   446→      return { type: \"GROUP_DESTROYED\" };\n   447→    case \"kicked\":\n   448→      return { type: \"GROUP_KICKED\" };\n   449→    case \"invite_declined\":\n   450→      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n   451→    case \"group_list\":\n   452→      return {\n   453→        type: \"GROUP_LIST\",\n   454→        members: event.members.map((m) => ({\n   455→          name: m.name,\n   456→          online: m.online,\n   457→        })),\n   458→        leader: event.leader,\n   459→      };\n   460→    case \"member_stats\":\n   461→      return {\n   462→        type: \"PARTY_MEMBER_STATS\",\n   463→        guidLow: event.guidLow,\n   464→        online: event.online,\n   465→        hp: event.hp,\n   466→        maxHp: event.maxHp,\n   467→        level: event.level,\n   468→      };\n   469→  }\n   470→}\n   471→\n   472→export function onGroupEvent(\n   473→  event: GroupEvent,\n   474→  events: RingBuffer<EventEntry>,\n   475→  log: SessionLog,\n   476→): void {\n   477→  const text = formatGroupEvent(event);\n   478→  const obj = formatGroupEventObj(event);\n   479→  events.push({ text, json: JSON.stringify(obj) });\n   480→  log.append(obj as LogEntry).catch(() => {});\n   481→}\n   482→\n   483→export function onChatMessage(\n   484→  msg: ChatMessage,\n   485→  events: RingBuffer<EventEntry>,\n   486→  log: SessionLog,\n   487→): void {\n   488→  const obj = formatMessageObj(msg);\n   489→  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n   490→  log.append(obj).catch(() => {});\n   491→}\n   492→\n   493→export function onEntityEvent(\n   494→  event: EntityEvent,\n   495→  events: RingBuffer<EventEntry>,\n   496→  log: SessionLog,\n   497→): void {\n   498→  const text = formatEntityEvent(event);\n   499→  const obj = formatEntityEventObj(event);\n   500→  if (obj) {\n   501→    events.push({ text, json: JSON.stringify(obj) });\n   502→    log.append(obj as LogEntry).catch(() => {});\n   503→  }\n   504→}\n   505→\n   506→export function onFriendEvent(\n   507→  event: FriendEvent,\n   508→  events: RingBuffer<EventEntry>,\n   509→  log: SessionLog,\n   510→): void {\n   511→  const text = formatFriendEvent(event);\n   512→  const obj = formatFriendEventObj(event);\n   513→  if (obj) {\n   514→    events.push({ text, json: JSON.stringify(obj) });\n   515→    log.append(obj as LogEntry).catch(() => {});\n   516→  }\n   517→}\n   518→"}]},"uuid":"ee40c2f9-bb24-45bd-a7ae-35eae6b89467","timestamp":"2026-02-28T23:41:45.043Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","content":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","numLines":518,"startLine":1,"totalLines":518}},"sourceToolAssistantUUID":"a58218af-e4e2-4db1-80a3-64dc4d5dc9d1"}
{"parentUuid":"ee40c2f9-bb24-45bd-a7ae-35eae6b89467","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01L8BPY4eheJsSLZzbttpNXc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MpwuNL8BZBxjSjmuqyLyni","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/wow/client.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":468,"cache_read_input_tokens":35387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":468},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPFQpd9dxLN3WxBFjP","type":"assistant","uuid":"76935d9f-cf6e-4b78-abf4-8a367ce9896f","timestamp":"2026-02-28T23:41:45.547Z"}
{"parentUuid":"76935d9f-cf6e-4b78-abf4-8a367ce9896f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MpwuNL8BZBxjSjmuqyLyni","type":"tool_result","content":"     1→import type { Socket } from \"bun\";\n     2→import { inflateSync } from \"node:zlib\";\n     3→import { PacketReader, PacketWriter } from \"wow/protocol/packet\";\n     4→import { SRP, type SRPResult } from \"wow/crypto/srp\";\n     5→import { Arc4 } from \"wow/crypto/arc4\";\n     6→import {\n     7→  GameOpcode,\n     8→  ChatType,\n     9→  Language,\n    10→  AuthOpcode,\n    11→} from \"wow/protocol/opcodes\";\n    12→import {\n    13→  parseChatMessage,\n    14→  buildChatMessage,\n    15→  buildNameQuery,\n    16→  parseNameQueryResponse,\n    17→  parseChannelNotify,\n    18→  buildWhoRequest,\n    19→  parseWhoResponse,\n    20→  type ChatMessage as RawChatMessage,\n    21→  type WhoResult,\n    22→} from \"wow/protocol/chat\";\n    23→import {\n    24→  buildLogonChallenge,\n    25→  parseLogonChallengeResponse,\n    26→  buildLogonProof,\n    27→  parseLogonProofResponse,\n    28→  buildRealmListRequest,\n    29→  parseRealmList,\n    30→  parseReconnectChallengeResponse,\n    31→  buildReconnectProof,\n    32→} from \"wow/protocol/auth\";\n    33→import {\n    34→  buildWorldAuthPacket,\n    35→  parseCharacterList,\n    36→  OpcodeDispatch,\n    37→  AccumulatorBuffer,\n    38→  INCOMING_HEADER_SIZE,\n    39→  buildOutgoingPacket,\n    40→  decryptIncomingHeader,\n    41→} from \"wow/protocol/world\";\n    42→import {\n    43→  buildGroupInvite,\n    44→  buildGroupAccept,\n    45→  buildGroupDecline,\n    46→  buildGroupUninvite,\n    47→  buildGroupDisband,\n    48→  buildGroupSetLeader,\n    49→  parsePartyCommandResult,\n    50→  parseGroupInvite,\n    51→  parseGroupSetLeader,\n    52→  parseGroupDecline,\n    53→  parseGroupList,\n    54→  parsePartyMemberStats,\n    55→} from \"wow/protocol/group\";\n    56→import { registerStubs } from \"wow/protocol/stubs\";\n    57→import { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\n    58→import {\n    59→  FriendStore,\n    60→  type FriendEntry,\n    61→  type FriendEvent,\n    62→} from \"wow/friend-store\";\n    63→import {\n    64→  parseContactList,\n    65→  parseFriendStatus,\n    66→  buildAddFriend,\n    67→  buildDelFriend,\n    68→  SocialFlag,\n    69→  FriendStatus,\n    70→  FriendResult,\n    71→} from \"wow/protocol/social\";\n    72→import { parseUpdateObject } from \"wow/protocol/update-object\";\n    73→import { ObjectType } from \"wow/protocol/entity-fields\";\n    74→import {\n    75→  extractObjectFields,\n    76→  extractUnitFields,\n    77→  extractGameObjectFields,\n    78→} from \"wow/protocol/extract-fields\";\n    79→import {\n    80→  buildCreatureQuery,\n    81→  parseCreatureQueryResponse,\n    82→  buildGameObjectQuery,\n    83→  parseGameObjectQueryResponse,\n    84→} from \"wow/protocol/entity-queries\";\n    85→\n    86→export type ClientConfig = {\n    87→  host: string;\n    88→  port: number;\n    89→  account: string;\n    90→  password: string;\n    91→  character: string;\n    92→  srpPrivateKey?: bigint;\n    93→  clientSeed?: Uint8Array;\n    94→  pingIntervalMs?: number;\n    95→  language?: number;\n    96→  cachedSessionKey?: Uint8Array;\n    97→};\n    98→\n    99→export type AuthResult = {\n   100→  sessionKey: Uint8Array;\n   101→  realmHost: string;\n   102→  realmPort: number;\n   103→  realmId: number;\n   104→};\n   105→\n   106→export type ChatMessage = {\n   107→  type: number;\n   108→  sender: string;\n   109→  message: string;\n   110→  channel?: string;\n   111→};\n   112→\n   113→export type GroupEvent =\n   114→  | { type: \"invite_received\"; from: string }\n   115→  | {\n   116→      type: \"command_result\";\n   117→      operation: number;\n   118→      target: string;\n   119→      result: number;\n   120→    }\n   121→  | { type: \"leader_changed\"; name: string }\n   122→  | {\n   123→      type: \"group_list\";\n   124→      members: Array<{\n   125→        name: string;\n   126→        guidLow: number;\n   127→        guidHigh: number;\n   128→        online: boolean;\n   129→      }>;\n   130→      leader: string;\n   131→    }\n   132→  | { type: \"group_destroyed\" }\n   133→  | { type: \"kicked\" }\n   134→  | { type: \"invite_declined\"; name: string }\n   135→  | {\n   136→      type: \"member_stats\";\n   137→      guidLow: number;\n   138→      online?: boolean;\n   139→      hp?: number;\n   140→      maxHp?: number;\n   141→      level?: number;\n   142→    };\n   143→\n   144→export type { WhoResult };\n   145→export type { Entity, EntityEvent };\n   146→export type { FriendEntry, FriendEvent };\n   147→\n   148→export type ChatMode =\n   149→  | { type: \"say\" }\n   150→  | { type: \"yell\" }\n   151→  | { type: \"guild\" }\n   152→  | { type: \"party\" }\n   153→  | { type: \"raid\" }\n   154→  | { type: \"whisper\"; target: string }\n   155→  | { type: \"channel\"; channel: string };\n   156→\n   157→export type WorldHandle = {\n   158→  closed: Promise<void>;\n   159→  close(): void;\n   160→  onMessage(cb: (msg: ChatMessage) => void): void;\n   161→  sendWhisper(target: string, message: string): void;\n   162→  sendSay(message: string): void;\n   163→  sendYell(message: string): void;\n   164→  sendGuild(message: string): void;\n   165→  sendParty(message: string): void;\n   166→  sendRaid(message: string): void;\n   167→  sendChannel(channel: string, message: string): void;\n   168→  getChannel(index: number): string | undefined;\n   169→  who(opts?: {\n   170→    name?: string;\n   171→    minLevel?: number;\n   172→    maxLevel?: number;\n   173→  }): Promise<WhoResult[]>;\n   174→  getLastChatMode(): ChatMode;\n   175→  setLastChatMode(mode: ChatMode): void;\n   176→  sendInCurrentMode(message: string): void;\n   177→  invite(name: string): void;\n   178→  uninvite(name: string): void;\n   179→  leaveGroup(): void;\n   180→  setLeader(name: string): void;\n   181→  acceptInvite(): void;\n   182→  declineInvite(): void;\n   183→  onGroupEvent(cb: (event: GroupEvent) => void): void;\n   184→  onEntityEvent(cb: (event: EntityEvent) => void): void;\n   185→  onPacketError(cb: (opcode: number, err: Error) => void): void;\n   186→  getNearbyEntities(): Entity[];\n   187→  getFriends(): FriendEntry[];\n   188→  addFriend(name: string): void;\n   189→  removeFriend(name: string): void;\n   190→  onFriendEvent(cb: (event: FriendEvent) => void): void;\n   191→};\n   192→\n   193→type WorldConn = {\n   194→  socket: Socket;\n   195→  dispatch: OpcodeDispatch;\n   196→  buf: AccumulatorBuffer;\n   197→  arc4?: Arc4;\n   198→  startTime: number;\n   199→  pendingHeader?: { size: number; opcode: number };\n   200→  nameCache: Map<number, string>;\n   201→  pendingMessages: Map<number, RawChatMessage[]>;\n   202→  channels: string[];\n   203→  lastChatMode: ChatMode;\n   204→  onMessage?: (msg: ChatMessage) => void;\n   205→  selfName: string;\n   206→  selfGuidLow: number;\n   207→  selfGuidHigh: number;\n   208→  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n   209→  onGroupEvent?: (event: GroupEvent) => void;\n   210→  entityStore: EntityStore;\n   211→  creatureNameCache: Map<number, string>;\n   212→  gameObjectNameCache: Map<number, string>;\n   213→  onEntityEvent?: (event: EntityEvent) => void;\n   214→  onPacketError?: (opcode: number, err: Error) => void;\n   215→  pendingNameQueries: Set<string>;\n   216→  friendStore: FriendStore;\n   217→  onFriendEvent?: (event: FriendEvent) => void;\n   218→};\n   219→\n   220→function handleChallenge(\n   221→  raw: Uint8Array,\n   222→  config: ClientConfig,\n   223→  srp: SRP,\n   224→): SRPResult {\n   225→  const r = new PacketReader(raw);\n   226→  r.skip(1);\n   227→  const result = parseLogonChallengeResponse(r);\n   228→  if (result.status !== 0x00) {\n   229→    throw new Error(\n   230→      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n   231→    );\n   232→  }\n   233→  return srp.calculate(\n   234→    result.g!,\n   235→    result.N!,\n   236→    result.salt!,\n   237→    result.B!,\n   238→    config.srpPrivateKey,\n   239→  );\n   240→}\n   241→\n   242→function handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n   243→  const r = new PacketReader(raw);\n   244→  r.skip(1);\n   245→  const result = parseLogonProofResponse(r);\n   246→  if (result.status !== 0x00) {\n   247→    throw new Error(\n   248→      `Auth proof failed: status 0x${result.status.toString(16)}`,\n   249→    );\n   250→  }\n   251→  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n   252→}\n   253→\n   254→function handleRealms(\n   255→  raw: Uint8Array,\n   256→): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n   257→  const realms = parseRealmList(new PacketReader(raw, 1));\n   258→  if (realms.length === 0) throw new Error(\"No realms available\");\n   259→  const realm = realms[0]!;\n   260→  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n   261→}\n   262→\n   263→export class ReconnectRequiredError extends Error {\n   264→  constructor() {\n   265→    super(\"Server requires reconnect but no cached session key is available\");\n   266→    this.name = \"ReconnectRequiredError\";\n   267→  }\n   268→}\n   269→\n   270→function handleReconnectChallenge(\n   271→  raw: Uint8Array,\n   272→  config: ClientConfig,\n   273→): Uint8Array {\n   274→  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n   275→  const r = new PacketReader(raw);\n   276→  const result = parseReconnectChallengeResponse(r);\n   277→  if (result.status !== 0x00) {\n   278→    throw new Error(\n   279→      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n   280→    );\n   281→  }\n   282→  return buildReconnectProof(\n   283→    config.account,\n   284→    result.challengeData!,\n   285→    config.cachedSessionKey,\n   286→  );\n   287→}\n   288→\n   289→function handleReconnectProof(raw: Uint8Array): void {\n   290→  const r = new PacketReader(raw);\n   291→  r.skip(1);\n   292→  const status = r.uint8();\n   293→  if (status !== 0x00) {\n   294→    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n   295→  }\n   296→}\n   297→\n   298→export async function authWithRetry(\n   299→  config: ClientConfig,\n   300→  opts?: { maxAttempts?: number; baseDelayMs?: number },\n   301→): Promise<AuthResult> {\n   302→  const maxAttempts = opts?.maxAttempts ?? 5;\n   303→  const baseDelay = opts?.baseDelayMs ?? 5000;\n   304→  let lastError: unknown;\n   305→  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n   306→    try {\n   307→      return await authHandshake(config);\n   308→    } catch (err) {\n   309→      if (!(err instanceof ReconnectRequiredError)) throw err;\n   310→      lastError = err;\n   311→      if (attempt + 1 < maxAttempts) {\n   312→        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n   313→        await Bun.sleep(delay);\n   314→      }\n   315→    }\n   316→  }\n   317→  throw lastError;\n   318→}\n   319→\n   320→type AuthContext = {\n   321→  buf: AccumulatorBuffer;\n   322→  srp: SRP;\n   323→  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n   324→  config: ClientConfig;\n   325→  srpResult?: SRPResult;\n   326→  sessionKey?: Uint8Array;\n   327→};\n   328→\n   329→function advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n   330→  const raw = ctx.buf.peek(ctx.buf.length);\n   331→  let result: AuthResult | undefined;\n   332→\n   333→  if (ctx.phase === \"challenge\") {\n   334→    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n   335→      socket.write(handleReconnectChallenge(raw, ctx.config));\n   336→      ctx.sessionKey = ctx.config.cachedSessionKey!;\n   337→      ctx.phase = \"reconnect_proof\";\n   338→    } else {\n   339→      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n   340→      ctx.sessionKey = ctx.srpResult.K;\n   341→      socket.write(buildLogonProof(ctx.srpResult));\n   342→      ctx.phase = \"proof\";\n   343→    }\n   344→  } else if (ctx.phase === \"proof\") {\n   345→    handleProof(raw, ctx.srpResult!);\n   346→    socket.write(buildRealmListRequest());\n   347→    ctx.phase = \"realms\";\n   348→  } else if (ctx.phase === \"reconnect_proof\") {\n   349→    handleReconnectProof(raw);\n   350→    socket.write(buildRealmListRequest());\n   351→    ctx.phase = \"realms\";\n   352→  } else {\n   353→    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n   354→  }\n   355→\n   356→  ctx.buf.drain(ctx.buf.length);\n   357→  return result;\n   358→}\n   359→\n   360→export function authHandshake(config: ClientConfig): Promise<AuthResult> {\n   361→  return new Promise((resolve, reject) => {\n   362→    const ctx: AuthContext = {\n   363→      buf: new AccumulatorBuffer(),\n   364→      srp: new SRP(config.account, config.password),\n   365→      phase: \"challenge\",\n   366→      config,\n   367→    };\n   368→    let done = false;\n   369→\n   370→    Bun.connect({\n   371→      hostname: config.host,\n   372→      port: config.port,\n   373→      socket: {\n   374→        open(socket) {\n   375→          socket.write(buildLogonChallenge(config.account));\n   376→        },\n   377→        data(socket, data) {\n   378→          ctx.buf.append(new Uint8Array(data));\n   379→          try {\n   380→            const result = advanceAuth(ctx, socket);\n   381→            if (result) {\n   382→              done = true;\n   383→              socket.end();\n   384→              resolve(result);\n   385→            }\n   386→          } catch (err) {\n   387→            if (err instanceof RangeError) return;\n   388→            done = true;\n   389→            reject(err);\n   390→            socket.end();\n   391→          }\n   392→        },\n   393→        close() {\n   394→          if (!done) reject(new Error(\"Auth connection closed\"));\n   395→        },\n   396→      },\n   397→    }).catch(reject);\n   398→  });\n   399→}\n   400→\n   401→function sendPacket(\n   402→  conn: WorldConn,\n   403→  opcode: number,\n   404→  body: Uint8Array = new Uint8Array(0),\n   405→): void {\n   406→  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n   407→}\n   408→\n   409→function drainWorldPackets(conn: WorldConn): void {\n   410→  while (true) {\n   411→    if (!conn.pendingHeader) {\n   412→      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n   413→      conn.pendingHeader = decryptIncomingHeader(\n   414→        conn.buf.drain(INCOMING_HEADER_SIZE),\n   415→        conn.arc4,\n   416→      );\n   417→    }\n   418→    const bodySize = conn.pendingHeader.size - 2;\n   419→    if (conn.buf.length < bodySize) break;\n   420→\n   421→    const { opcode } = conn.pendingHeader;\n   422→    conn.pendingHeader = undefined;\n   423→    try {\n   424→      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n   425→    } catch (err) {\n   426→      if (err instanceof Error) {\n   427→        conn.onPacketError?.(opcode, err);\n   428→      }\n   429→    }\n   430→  }\n   431→}\n   432→\n   433→function handleTimeSync(conn: WorldConn, r: PacketReader): void {\n   434→  const counter = r.uint32LE();\n   435→  const elapsed = Date.now() - conn.startTime;\n   436→  const w = new PacketWriter();\n   437→  w.uint32LE(counter);\n   438→  w.uint32LE(elapsed);\n   439→  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n   440→}\n   441→\n   442→function deliverMessage(\n   443→  conn: WorldConn,\n   444→  raw: RawChatMessage,\n   445→  name: string,\n   446→): void {\n   447→  conn.onMessage?.({\n   448→    type: raw.type,\n   449→    sender: name,\n   450→    message: raw.message,\n   451→    channel: raw.channel,\n   452→  });\n   453→}\n   454→\n   455→function handleChatMessage(conn: WorldConn, r: PacketReader): void {\n   456→  const raw = parseChatMessage(r);\n   457→\n   458→  if (raw.senderGuidLow === 0) {\n   459→    deliverMessage(conn, raw, \"\");\n   460→    return;\n   461→  }\n   462→\n   463→  const cached = conn.nameCache.get(raw.senderGuidLow);\n   464→  if (cached !== undefined) {\n   465→    deliverMessage(conn, raw, cached);\n   466→    return;\n   467→  }\n   468→\n   469→  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n   470→  if (pending) {\n   471→    pending.push(raw);\n   472→  } else {\n   473→    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n   474→    sendPacket(\n   475→      conn,\n   476→      GameOpcode.CMSG_NAME_QUERY,\n   477→      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n   478→    );\n   479→  }\n   480→}\n   481→\n   482→function handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n   483→  const raw = parseChatMessage(r, true);\n   484→  deliverMessage(conn, raw, raw.senderName ?? \"\");\n   485→}\n   486→\n   487→function handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n   488→  const result = parseNameQueryResponse(r);\n   489→\n   490→  const name = result.found && result.name ? result.name : \"\";\n   491→  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n   492→  if (result.found && result.name) {\n   493→    conn.nameCache.set(result.guidLow, result.name);\n   494→    for (const entity of conn.entityStore.all()) {\n   495→      if (\n   496→        entity.objectType === ObjectType.PLAYER &&\n   497→        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n   498→        !entity.name\n   499→      ) {\n   500→        conn.entityStore.setName(entity.guid, result.name);\n   501→      }\n   502→    }\n   503→    for (const friend of conn.friendStore.all()) {\n   504→      if (\n   505→        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n   506→        !friend.name\n   507→      ) {\n   508→        conn.friendStore.setName(friend.guid, result.name);\n   509→      }\n   510→    }\n   511→  }\n   512→\n   513→  const pending = conn.pendingMessages.get(result.guidLow);\n   514→  if (!pending) return;\n   515→  for (const raw of pending) deliverMessage(conn, raw, name);\n   516→  conn.pendingMessages.delete(result.guidLow);\n   517→}\n   518→\n   519→function handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n   520→  const event = parseChannelNotify(r);\n   521→  if (event.type === \"joined\") {\n   522→    conn.channels.push(event.channel);\n   523→  } else if (event.type === \"left\") {\n   524→    const idx = conn.channels.indexOf(event.channel);\n   525→    if (idx !== -1) conn.channels.splice(idx, 1);\n   526→  }\n   527→}\n   528→\n   529→function handleMotd(conn: WorldConn, r: PacketReader): void {\n   530→  const lineCount = r.uint32LE();\n   531→  const lines: string[] = [];\n   532→  for (let i = 0; i < lineCount; i++) {\n   533→    lines.push(r.cString());\n   534→  }\n   535→  conn.onMessage?.({\n   536→    type: ChatType.SYSTEM,\n   537→    sender: \"\",\n   538→    message: lines.join(\"\\n\"),\n   539→  });\n   540→}\n   541→\n   542→function handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n   543→  const name = r.cString();\n   544→  conn.onMessage?.({\n   545→    type: ChatType.SYSTEM,\n   546→    sender: \"\",\n   547→    message: `No player named \"${name}\" is currently playing.`,\n   548→  });\n   549→}\n   550→\n   551→function handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n   552→  const result = parsePartyCommandResult(r);\n   553→  conn.onGroupEvent?.({\n   554→    type: \"command_result\",\n   555→    operation: result.operation,\n   556→    target: result.member,\n   557→    result: result.result,\n   558→  });\n   559→}\n   560→\n   561→function handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n   562→  const invite = parseGroupInvite(r);\n   563→  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n   564→}\n   565→\n   566→function handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n   567→  const { name } = parseGroupSetLeader(r);\n   568→  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n   569→}\n   570→\n   571→function handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n   572→  const list = parseGroupList(r);\n   573→  conn.partyMembers.clear();\n   574→  let leaderName = \"\";\n   575→  if (\n   576→    conn.selfGuidLow === list.leaderGuidLow &&\n   577→    conn.selfGuidHigh === list.leaderGuidHigh\n   578→  ) {\n   579→    leaderName = conn.selfName;\n   580→  }\n   581→  for (const m of list.members) {\n   582→    conn.partyMembers.set(m.name, {\n   583→      guidLow: m.guidLow,\n   584→      guidHigh: m.guidHigh,\n   585→    });\n   586→    if (\n   587→      m.guidLow === list.leaderGuidLow &&\n   588→      m.guidHigh === list.leaderGuidHigh\n   589→    ) {\n   590→      leaderName = m.name;\n   591→    }\n   592→  }\n   593→  conn.onGroupEvent?.({\n   594→    type: \"group_list\",\n   595→    members: list.members,\n   596→    leader: leaderName,\n   597→  });\n   598→}\n   599→\n   600→function handleGroupDestroyed(conn: WorldConn): void {\n   601→  conn.partyMembers.clear();\n   602→  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n   603→}\n   604→\n   605→function handleGroupUninvite(conn: WorldConn): void {\n   606→  conn.partyMembers.clear();\n   607→  conn.onGroupEvent?.({ type: \"kicked\" });\n   608→}\n   609→\n   610→function handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n   611→  const { name } = parseGroupDecline(r);\n   612→  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n   613→}\n   614→\n   615→function handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n   616→  const entries = parseUpdateObject(r);\n   617→  for (const entry of entries) {\n   618→    switch (entry.type) {\n   619→      case \"create\": {\n   620→        const { _changed: _co, ...objFields } = extractObjectFields(\n   621→          entry.fields,\n   622→        );\n   623→        let extraFields: Record<string, unknown> = {};\n   624→        if (\n   625→          entry.objectType === ObjectType.UNIT ||\n   626→          entry.objectType === ObjectType.PLAYER\n   627→        ) {\n   628→          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n   629→          extraFields = rest;\n   630→        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n   631→          const { _changed: _cg, ...rest } = extractGameObjectFields(\n   632→            entry.fields,\n   633→          );\n   634→          extraFields = rest;\n   635→        }\n   636→        const cachedName = lookupCachedName(\n   637→          conn,\n   638→          entry.guid,\n   639→          entry.objectType,\n   640→          objFields.entry,\n   641→        );\n   642→        conn.entityStore.create(entry.guid, entry.objectType, {\n   643→          ...objFields,\n   644→          ...extraFields,\n   645→          ...(cachedName ? { name: cachedName } : {}),\n   646→          ...(entry.position ? { position: entry.position } : {}),\n   647→          rawFields: new Map(entry.fields),\n   648→        } as any);\n   649→        if (!cachedName) {\n   650→          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n   651→        }\n   652→        break;\n   653→      }\n   654→      case \"values\": {\n   655→        const entity = conn.entityStore.get(entry.guid);\n   656→        if (!entity) break;\n   657→        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n   658→        let extraFields: Record<string, unknown> = {};\n   659→        if (\n   660→          entity.objectType === ObjectType.UNIT ||\n   661→          entity.objectType === ObjectType.PLAYER\n   662→        ) {\n   663→          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n   664→        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n   665→          extraFields = extractGameObjectFields(entry.fields);\n   666→        }\n   667→        const allChanged = [\n   668→          ...(objFields._changed || []),\n   669→          ...((extraFields as any)._changed || []),\n   670→        ];\n   671→        const merged: Record<string, unknown> = {};\n   672→        for (const key of allChanged) {\n   673→          if (key in extraFields) merged[key] = (extraFields as any)[key];\n   674→          else if (key in objFields) merged[key] = (objFields as any)[key];\n   675→        }\n   676→        conn.entityStore.update(entry.guid, merged);\n   677→        for (const [k, v] of entry.fields) {\n   678→          const existing = conn.entityStore.get(entry.guid);\n   679→          if (existing) existing.rawFields.set(k, v);\n   680→        }\n   681→        break;\n   682→      }\n   683→      case \"movement\": {\n   684→        conn.entityStore.setPosition(entry.guid, entry.position);\n   685→        break;\n   686→      }\n   687→      case \"outOfRange\": {\n   688→        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n   689→        break;\n   690→      }\n   691→      case \"nearObjects\": {\n   692→        break;\n   693→      }\n   694→    }\n   695→  }\n   696→}\n   697→\n   698→function handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n   699→  const uncompressedSize = r.uint32LE();\n   700→  const compressed = r.bytes(r.remaining);\n   701→  const decompressed = inflateSync(compressed);\n   702→  if (decompressed.length !== uncompressedSize) {\n   703→    throw new Error(\n   704→      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n   705→    );\n   706→  }\n   707→  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n   708→}\n   709→\n   710→function handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n   711→  const guid = r.uint64LE();\n   712→  r.skip(1);\n   713→  conn.entityStore.destroy(guid);\n   714→}\n   715→\n   716→function lookupCachedName(\n   717→  conn: WorldConn,\n   718→  guid: bigint,\n   719→  objectType: number,\n   720→  entry: number | undefined,\n   721→): string | undefined {\n   722→  if (objectType === ObjectType.PLAYER) {\n   723→    const guidLow = Number(guid & 0xffffffffn);\n   724→    return conn.nameCache.get(guidLow);\n   725→  }\n   726→  if (entry === undefined) return undefined;\n   727→  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n   728→  if (objectType === ObjectType.GAMEOBJECT)\n   729→    return conn.gameObjectNameCache.get(entry);\n   730→  return undefined;\n   731→}\n   732→\n   733→function queryEntityName(\n   734→  conn: WorldConn,\n   735→  guid: bigint,\n   736→  objectType: number,\n   737→  entry: number | undefined,\n   738→): void {\n   739→  if (objectType === ObjectType.PLAYER) {\n   740→    const guidLow = Number(guid & 0xffffffffn);\n   741→    const key = `player:${guidLow}`;\n   742→    if (conn.pendingNameQueries.has(key)) return;\n   743→    conn.pendingNameQueries.add(key);\n   744→    const w = new PacketWriter();\n   745→    w.uint64LE(guid);\n   746→    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n   747→    return;\n   748→  }\n   749→  if (entry === undefined) return;\n   750→  const key = `${objectType}:${entry}`;\n   751→  if (conn.pendingNameQueries.has(key)) return;\n   752→  conn.pendingNameQueries.add(key);\n   753→  if (objectType === ObjectType.UNIT) {\n   754→    sendPacket(\n   755→      conn,\n   756→      GameOpcode.CMSG_CREATURE_QUERY,\n   757→      buildCreatureQuery(entry, guid),\n   758→    );\n   759→    return;\n   760→  }\n   761→  if (objectType === ObjectType.GAMEOBJECT) {\n   762→    sendPacket(\n   763→      conn,\n   764→      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n   765→      buildGameObjectQuery(entry, guid),\n   766→    );\n   767→    return;\n   768→  }\n   769→}\n   770→\n   771→function handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n   772→  const result = parseCreatureQueryResponse(r);\n   773→  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n   774→  if (!result.name) return;\n   775→  conn.creatureNameCache.set(result.entry, result.name);\n   776→  for (const entity of conn.entityStore.all()) {\n   777→    if (entity.entry === result.entry && !entity.name) {\n   778→      conn.entityStore.setName(entity.guid, result.name);\n   779→    }\n   780→  }\n   781→}\n   782→\n   783→function handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n   784→  const result = parseGameObjectQueryResponse(r);\n   785→  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n   786→  if (!result.name) return;\n   787→  conn.gameObjectNameCache.set(result.entry, result.name);\n   788→  for (const entity of conn.entityStore.all()) {\n   789→    if (entity.entry === result.entry) {\n   790→      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n   791→      if (result.gameObjectType !== undefined) {\n   792→        conn.entityStore.update(entity.guid, {\n   793→          gameObjectType: result.gameObjectType,\n   794→        });\n   795→      }\n   796→    }\n   797→  }\n   798→}\n   799→\n   800→function handlePartyMemberStatsMsg(\n   801→  conn: WorldConn,\n   802→  r: PacketReader,\n   803→  isFull = false,\n   804→): void {\n   805→  const stats = parsePartyMemberStats(r, isFull);\n   806→  conn.onGroupEvent?.({\n   807→    type: \"member_stats\",\n   808→    guidLow: stats.guidLow,\n   809→    online: stats.online,\n   810→    hp: stats.hp,\n   811→    maxHp: stats.maxHp,\n   812→    level: stats.level,\n   813→  });\n   814→}\n   815→\n   816→function handleContactList(conn: WorldConn, r: PacketReader): void {\n   817→  const list = parseContactList(r);\n   818→  const friends: FriendEntry[] = [];\n   819→  for (const contact of list.contacts) {\n   820→    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n   821→    const guidLow = Number(contact.guid & 0xffffffffn);\n   822→    const name = conn.nameCache.get(guidLow) ?? \"\";\n   823→    friends.push({\n   824→      guid: contact.guid,\n   825→      name,\n   826→      note: contact.note,\n   827→      status: contact.status ?? 0,\n   828→      area: contact.area ?? 0,\n   829→      level: contact.level ?? 0,\n   830→      playerClass: contact.playerClass ?? 0,\n   831→    });\n   832→    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n   833→      conn.pendingNameQueries.add(`player:${guidLow}`);\n   834→      sendPacket(\n   835→        conn,\n   836→        GameOpcode.CMSG_NAME_QUERY,\n   837→        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n   838→      );\n   839→    }\n   840→  }\n   841→  conn.friendStore.set(friends);\n   842→}\n   843→\n   844→function handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n   845→  const packet = parseFriendStatus(r);\n   846→  const guidLow = Number(packet.guid & 0xffffffffn);\n   847→\n   848→  switch (packet.result) {\n   849→    case FriendResult.ADDED_ONLINE:\n   850→    case FriendResult.ADDED_OFFLINE: {\n   851→      const name = conn.nameCache.get(guidLow) ?? \"\";\n   852→      conn.friendStore.add({\n   853→        guid: packet.guid,\n   854→        name,\n   855→        note: packet.note ?? \"\",\n   856→        status: packet.status ?? 0,\n   857→        area: packet.area ?? 0,\n   858→        level: packet.level ?? 0,\n   859→        playerClass: packet.playerClass ?? 0,\n   860→      });\n   861→      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n   862→        conn.pendingNameQueries.add(`player:${guidLow}`);\n   863→        sendPacket(\n   864→          conn,\n   865→          GameOpcode.CMSG_NAME_QUERY,\n   866→          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n   867→        );\n   868→      }\n   869→      break;\n   870→    }\n   871→    case FriendResult.ONLINE:\n   872→      conn.friendStore.update(packet.guid, {\n   873→        status: packet.status ?? FriendStatus.ONLINE,\n   874→        area: packet.area ?? 0,\n   875→        level: packet.level ?? 0,\n   876→        playerClass: packet.playerClass ?? 0,\n   877→      });\n   878→      break;\n   879→    case FriendResult.OFFLINE:\n   880→      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n   881→      break;\n   882→    case FriendResult.REMOVED:\n   883→      conn.friendStore.remove(packet.guid);\n   884→      break;\n   885→    default: {\n   886→      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n   887→      conn.onFriendEvent?.({\n   888→        type: \"friend-error\",\n   889→        result: packet.result,\n   890→        name,\n   891→      });\n   892→      break;\n   893→    }\n   894→  }\n   895→}\n   896→\n   897→async function authenticateWorld(\n   898→  conn: WorldConn,\n   899→  config: ClientConfig,\n   900→  auth: AuthResult,\n   901→): Promise<void> {\n   902→  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n   903→  challenge.uint32LE();\n   904→  const serverSeed = challenge.bytes(4);\n   905→\n   906→  const body = await buildWorldAuthPacket(\n   907→    config.account,\n   908→    auth.sessionKey,\n   909→    serverSeed,\n   910→    auth.realmId,\n   911→    config.clientSeed,\n   912→  );\n   913→  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n   914→  conn.arc4 = new Arc4(auth.sessionKey);\n   915→\n   916→  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n   917→  const status = resp.uint8();\n   918→  if (status !== 0x0c) {\n   919→    const names: Record<number, string> = {\n   920→      0x0d: \"system error\",\n   921→      0x15: \"account in use\",\n   922→    };\n   923→    const label = names[status] ?? `status 0x${status.toString(16)}`;\n   924→    throw new Error(`World auth failed: ${label}`);\n   925→  }\n   926→}\n   927→\n   928→async function selectCharacter(\n   929→  conn: WorldConn,\n   930→  config: ClientConfig,\n   931→): Promise<void> {\n   932→  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n   933→\n   934→  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n   935→  const chars = parseCharacterList(enumReader);\n   936→  const char = chars.find(\n   937→    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n   938→  );\n   939→  if (!char) {\n   940→    throw new Error(\n   941→      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n   942→    );\n   943→  }\n   944→\n   945→  conn.selfName = char.name;\n   946→  conn.selfGuidLow = char.guidLow;\n   947→  conn.selfGuidHigh = char.guidHigh;\n   948→\n   949→  const w = new PacketWriter();\n   950→  w.uint32LE(char.guidLow);\n   951→  w.uint32LE(char.guidHigh);\n   952→  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n   953→\n   954→  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n   955→}\n   956→\n   957→function startPingLoop(\n   958→  conn: WorldConn,\n   959→  intervalMs: number,\n   960→): ReturnType<typeof setInterval> {\n   961→  return setInterval(() => {\n   962→    const w = new PacketWriter();\n   963→    w.uint32LE(0);\n   964→    w.uint32LE(0);\n   965→    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n   966→  }, intervalMs);\n   967→}\n   968→\n   969→export function worldSession(\n   970→  config: ClientConfig,\n   971→  auth: AuthResult,\n   972→): Promise<WorldHandle> {\n   973→  return new Promise((resolve, reject) => {\n   974→    const conn: WorldConn = {\n   975→      socket: undefined!,\n   976→      dispatch: new OpcodeDispatch(),\n   977→      buf: new AccumulatorBuffer(),\n   978→      startTime: Date.now(),\n   979→      nameCache: new Map(),\n   980→      pendingMessages: new Map(),\n   981→      channels: [],\n   982→      lastChatMode: { type: \"say\" },\n   983→      selfName: \"\",\n   984→      selfGuidLow: 0,\n   985→      selfGuidHigh: 0,\n   986→      partyMembers: new Map(),\n   987→      entityStore: new EntityStore(),\n   988→      creatureNameCache: new Map(),\n   989→      gameObjectNameCache: new Map(),\n   990→      pendingNameQueries: new Set(),\n   991→      friendStore: new FriendStore(),\n   992→    };\n   993→    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n   994→    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n   995→\n   996→    let pingInterval: ReturnType<typeof setInterval>;\n   997→    let done = false;\n   998→    let closedResolve: () => void;\n   999→    const closed = new Promise<void>((r) => {\n  1000→      closedResolve = r;\n  1001→    });\n  1002→\n  1003→    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n  1004→      handleTimeSync(conn, r),\n  1005→    );\n  1006→    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n  1007→      handleChatMessage(conn, r),\n  1008→    );\n  1009→    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n  1010→      handleGmChatMessage(conn, r),\n  1011→    );\n  1012→    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n  1013→      handleNameQueryResponse(conn, r),\n  1014→    );\n  1015→    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n  1016→    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n  1017→      handlePlayerNotFound(conn, r),\n  1018→    );\n  1019→    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n  1020→      handleChannelNotify(conn, r),\n  1021→    );\n  1022→    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n  1023→      handlePartyCommandResult(conn, r),\n  1024→    );\n  1025→    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n  1026→      handleGroupInviteReceived(conn, r),\n  1027→    );\n  1028→    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n  1029→      handleGroupSetLeaderMsg(conn, r),\n  1030→    );\n  1031→    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n  1032→      handleGroupListMsg(conn, r),\n  1033→    );\n  1034→    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n  1035→      handleGroupDestroyed(conn),\n  1036→    );\n  1037→    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n  1038→      handleGroupUninvite(conn),\n  1039→    );\n  1040→    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n  1041→      handleGroupDeclineMsg(conn, r),\n  1042→    );\n  1043→    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n  1044→      handlePartyMemberStatsMsg(conn, r),\n  1045→    );\n  1046→    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n  1047→      handlePartyMemberStatsMsg(conn, r, true),\n  1048→    );\n  1049→    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n  1050→      handleUpdateObject(conn, r),\n  1051→    );\n  1052→    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n  1053→      handleCompressedUpdateObject(conn, r),\n  1054→    );\n  1055→    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n  1056→      handleDestroyObject(conn, r),\n  1057→    );\n  1058→    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n  1059→      handleCreatureQueryResponse(conn, r),\n  1060→    );\n  1061→    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n  1062→      handleGameObjectQueryResponse(conn, r),\n  1063→    );\n  1064→\n  1065→    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n  1066→      handleContactList(conn, r),\n  1067→    );\n  1068→    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n  1069→      handleFriendStatus(conn, r),\n  1070→    );\n  1071→\n  1072→    registerStubs(conn.dispatch, (msg) => {\n  1073→      if (!conn.onMessage) return false;\n  1074→      conn.onMessage({\n  1075→        type: ChatType.SYSTEM,\n  1076→        sender: \"\",\n  1077→        message: msg,\n  1078→      });\n  1079→      return true;\n  1080→    });\n  1081→\n  1082→    async function login() {\n  1083→      await authenticateWorld(conn, config, auth);\n  1084→      await selectCharacter(conn, config);\n  1085→      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n  1086→      const lang = config.language ?? Language.COMMON;\n  1087→      done = true;\n  1088→      const handle: WorldHandle = {\n  1089→        closed,\n  1090→        close() {\n  1091→          clearInterval(pingInterval);\n  1092→          conn.onEntityEvent = undefined;\n  1093→          conn.onFriendEvent = undefined;\n  1094→          conn.socket.end();\n  1095→        },\n  1096→        onMessage(cb) {\n  1097→          conn.onMessage = cb;\n  1098→        },\n  1099→        sendWhisper(target, message) {\n  1100→          if (target) conn.lastChatMode = { type: \"whisper\", target };\n  1101→          sendPacket(\n  1102→            conn,\n  1103→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1104→            buildChatMessage(ChatType.WHISPER, lang, message, target),\n  1105→          );\n  1106→        },\n  1107→        sendSay(message) {\n  1108→          conn.lastChatMode = { type: \"say\" };\n  1109→          sendPacket(\n  1110→            conn,\n  1111→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1112→            buildChatMessage(ChatType.SAY, lang, message),\n  1113→          );\n  1114→        },\n  1115→        sendYell(message) {\n  1116→          conn.lastChatMode = { type: \"yell\" };\n  1117→          sendPacket(\n  1118→            conn,\n  1119→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1120→            buildChatMessage(ChatType.YELL, lang, message),\n  1121→          );\n  1122→        },\n  1123→        sendGuild(message) {\n  1124→          conn.lastChatMode = { type: \"guild\" };\n  1125→          sendPacket(\n  1126→            conn,\n  1127→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1128→            buildChatMessage(ChatType.GUILD, lang, message),\n  1129→          );\n  1130→        },\n  1131→        sendParty(message) {\n  1132→          conn.lastChatMode = { type: \"party\" };\n  1133→          sendPacket(\n  1134→            conn,\n  1135→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1136→            buildChatMessage(ChatType.PARTY, lang, message),\n  1137→          );\n  1138→        },\n  1139→        sendRaid(message) {\n  1140→          conn.lastChatMode = { type: \"raid\" };\n  1141→          sendPacket(\n  1142→            conn,\n  1143→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1144→            buildChatMessage(ChatType.RAID, lang, message),\n  1145→          );\n  1146→        },\n  1147→        sendChannel(channel, message) {\n  1148→          conn.lastChatMode = { type: \"channel\", channel };\n  1149→          sendPacket(\n  1150→            conn,\n  1151→            GameOpcode.CMSG_MESSAGE_CHAT,\n  1152→            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n  1153→          );\n  1154→        },\n  1155→        getChannel(index) {\n  1156→          return conn.channels[index - 1];\n  1157→        },\n  1158→        async who(opts = {}) {\n  1159→          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n  1160→          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n  1161→          return parseWhoResponse(r);\n  1162→        },\n  1163→        getLastChatMode() {\n  1164→          return conn.lastChatMode;\n  1165→        },\n  1166→        setLastChatMode(mode) {\n  1167→          conn.lastChatMode = mode;\n  1168→        },\n  1169→        sendInCurrentMode(message) {\n  1170→          const mode = conn.lastChatMode;\n  1171→          switch (mode.type) {\n  1172→            case \"say\":\n  1173→              handle.sendSay(message);\n  1174→              break;\n  1175→            case \"yell\":\n  1176→              handle.sendYell(message);\n  1177→              break;\n  1178→            case \"guild\":\n  1179→              handle.sendGuild(message);\n  1180→              break;\n  1181→            case \"party\":\n  1182→              handle.sendParty(message);\n  1183→              break;\n  1184→            case \"raid\":\n  1185→              handle.sendRaid(message);\n  1186→              break;\n  1187→            case \"whisper\":\n  1188→              handle.sendWhisper(mode.target, message);\n  1189→              break;\n  1190→            case \"channel\":\n  1191→              handle.sendChannel(mode.channel, message);\n  1192→              break;\n  1193→          }\n  1194→        },\n  1195→        invite(name) {\n  1196→          sendPacket(\n  1197→            conn,\n  1198→            GameOpcode.CMSG_GROUP_INVITE,\n  1199→            buildGroupInvite(name),\n  1200→          );\n  1201→        },\n  1202→        uninvite(name) {\n  1203→          sendPacket(\n  1204→            conn,\n  1205→            GameOpcode.CMSG_GROUP_UNINVITE,\n  1206→            buildGroupUninvite(name),\n  1207→          );\n  1208→        },\n  1209→        leaveGroup() {\n  1210→          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n  1211→        },\n  1212→        setLeader(name) {\n  1213→          const member = conn.partyMembers.get(name);\n  1214→          if (!member) {\n  1215→            conn.onMessage?.({\n  1216→              type: ChatType.SYSTEM,\n  1217→              sender: \"\",\n  1218→              message: `\"${name}\" is not in your party.`,\n  1219→            });\n  1220→            return;\n  1221→          }\n  1222→          sendPacket(\n  1223→            conn,\n  1224→            GameOpcode.CMSG_GROUP_SET_LEADER,\n  1225→            buildGroupSetLeader(member.guidLow, member.guidHigh),\n  1226→          );\n  1227→        },\n  1228→        acceptInvite() {\n  1229→          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n  1230→        },\n  1231→        declineInvite() {\n  1232→          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n  1233→        },\n  1234→        onGroupEvent(cb) {\n  1235→          conn.onGroupEvent = cb;\n  1236→        },\n  1237→        onEntityEvent(cb) {\n  1238→          conn.onEntityEvent = cb;\n  1239→        },\n  1240→        onPacketError(cb) {\n  1241→          conn.onPacketError = cb;\n  1242→        },\n  1243→        getNearbyEntities() {\n  1244→          return conn.entityStore.all();\n  1245→        },\n  1246→        getFriends() {\n  1247→          return conn.friendStore.all();\n  1248→        },\n  1249→        addFriend(name) {\n  1250→          sendPacket(\n  1251→            conn,\n  1252→            GameOpcode.CMSG_ADD_FRIEND,\n  1253→            buildAddFriend(name, \"\"),\n  1254→          );\n  1255→        },\n  1256→        removeFriend(name) {\n  1257→          const friend = conn.friendStore.findByName(name);\n  1258→          if (!friend) {\n  1259→            conn.onMessage?.({\n  1260→              type: ChatType.SYSTEM,\n  1261→              sender: \"\",\n  1262→              message: `\"${name}\" is not on your friends list.`,\n  1263→            });\n  1264→            return;\n  1265→          }\n  1266→          sendPacket(\n  1267→            conn,\n  1268→            GameOpcode.CMSG_DEL_FRIEND,\n  1269→            buildDelFriend(friend.guid),\n  1270→          );\n  1271→        },\n  1272→        onFriendEvent(cb) {\n  1273→          conn.onFriendEvent = cb;\n  1274→        },\n  1275→      };\n  1276→      resolve(handle);\n  1277→    }\n  1278→\n  1279→    login().catch((err) => {\n  1280→      done = true;\n  1281→      clearInterval(pingInterval);\n  1282→      reject(err);\n  1283→      conn.socket?.end();\n  1284→    });\n  1285→\n  1286→    Bun.connect({\n  1287→      hostname: auth.realmHost,\n  1288→      port: auth.realmPort,\n  1289→      socket: {\n  1290→        open(s) {\n  1291→          conn.socket = s;\n  1292→        },\n  1293→        data(_s, data) {\n  1294→          conn.buf.append(new Uint8Array(data));\n  1295→          drainWorldPackets(conn);\n  1296→        },\n  1297→        close() {\n  1298→          clearInterval(pingInterval);\n  1299→          conn.entityStore.clear();\n  1300→          if (!done) reject(new Error(\"World connection closed\"));\n  1301→          closedResolve();\n  1302→        },\n  1303→      },\n  1304→    }).catch(reject);\n  1305→  });\n  1306→}\n  1307→"}]},"uuid":"64e68462-4c8e-4e2f-9adc-14bd3d0c3d86","timestamp":"2026-02-28T23:41:45.882Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.ts","content":"import type { Socket } from \"bun\";\nimport { inflateSync } from \"node:zlib\";\nimport { PacketReader, PacketWriter } from \"wow/protocol/packet\";\nimport { SRP, type SRPResult } from \"wow/crypto/srp\";\nimport { Arc4 } from \"wow/crypto/arc4\";\nimport {\n  GameOpcode,\n  ChatType,\n  Language,\n  AuthOpcode,\n} from \"wow/protocol/opcodes\";\nimport {\n  parseChatMessage,\n  buildChatMessage,\n  buildNameQuery,\n  parseNameQueryResponse,\n  parseChannelNotify,\n  buildWhoRequest,\n  parseWhoResponse,\n  type ChatMessage as RawChatMessage,\n  type WhoResult,\n} from \"wow/protocol/chat\";\nimport {\n  buildLogonChallenge,\n  parseLogonChallengeResponse,\n  buildLogonProof,\n  parseLogonProofResponse,\n  buildRealmListRequest,\n  parseRealmList,\n  parseReconnectChallengeResponse,\n  buildReconnectProof,\n} from \"wow/protocol/auth\";\nimport {\n  buildWorldAuthPacket,\n  parseCharacterList,\n  OpcodeDispatch,\n  AccumulatorBuffer,\n  INCOMING_HEADER_SIZE,\n  buildOutgoingPacket,\n  decryptIncomingHeader,\n} from \"wow/protocol/world\";\nimport {\n  buildGroupInvite,\n  buildGroupAccept,\n  buildGroupDecline,\n  buildGroupUninvite,\n  buildGroupDisband,\n  buildGroupSetLeader,\n  parsePartyCommandResult,\n  parseGroupInvite,\n  parseGroupSetLeader,\n  parseGroupDecline,\n  parseGroupList,\n  parsePartyMemberStats,\n} from \"wow/protocol/group\";\nimport { registerStubs } from \"wow/protocol/stubs\";\nimport { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\nimport {\n  FriendStore,\n  type FriendEntry,\n  type FriendEvent,\n} from \"wow/friend-store\";\nimport {\n  parseContactList,\n  parseFriendStatus,\n  buildAddFriend,\n  buildDelFriend,\n  SocialFlag,\n  FriendStatus,\n  FriendResult,\n} from \"wow/protocol/social\";\nimport { parseUpdateObject } from \"wow/protocol/update-object\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport {\n  extractObjectFields,\n  extractUnitFields,\n  extractGameObjectFields,\n} from \"wow/protocol/extract-fields\";\nimport {\n  buildCreatureQuery,\n  parseCreatureQueryResponse,\n  buildGameObjectQuery,\n  parseGameObjectQueryResponse,\n} from \"wow/protocol/entity-queries\";\n\nexport type ClientConfig = {\n  host: string;\n  port: number;\n  account: string;\n  password: string;\n  character: string;\n  srpPrivateKey?: bigint;\n  clientSeed?: Uint8Array;\n  pingIntervalMs?: number;\n  language?: number;\n  cachedSessionKey?: Uint8Array;\n};\n\nexport type AuthResult = {\n  sessionKey: Uint8Array;\n  realmHost: string;\n  realmPort: number;\n  realmId: number;\n};\n\nexport type ChatMessage = {\n  type: number;\n  sender: string;\n  message: string;\n  channel?: string;\n};\n\nexport type GroupEvent =\n  | { type: \"invite_received\"; from: string }\n  | {\n      type: \"command_result\";\n      operation: number;\n      target: string;\n      result: number;\n    }\n  | { type: \"leader_changed\"; name: string }\n  | {\n      type: \"group_list\";\n      members: Array<{\n        name: string;\n        guidLow: number;\n        guidHigh: number;\n        online: boolean;\n      }>;\n      leader: string;\n    }\n  | { type: \"group_destroyed\" }\n  | { type: \"kicked\" }\n  | { type: \"invite_declined\"; name: string }\n  | {\n      type: \"member_stats\";\n      guidLow: number;\n      online?: boolean;\n      hp?: number;\n      maxHp?: number;\n      level?: number;\n    };\n\nexport type { WhoResult };\nexport type { Entity, EntityEvent };\nexport type { FriendEntry, FriendEvent };\n\nexport type ChatMode =\n  | { type: \"say\" }\n  | { type: \"yell\" }\n  | { type: \"guild\" }\n  | { type: \"party\" }\n  | { type: \"raid\" }\n  | { type: \"whisper\"; target: string }\n  | { type: \"channel\"; channel: string };\n\nexport type WorldHandle = {\n  closed: Promise<void>;\n  close(): void;\n  onMessage(cb: (msg: ChatMessage) => void): void;\n  sendWhisper(target: string, message: string): void;\n  sendSay(message: string): void;\n  sendYell(message: string): void;\n  sendGuild(message: string): void;\n  sendParty(message: string): void;\n  sendRaid(message: string): void;\n  sendChannel(channel: string, message: string): void;\n  getChannel(index: number): string | undefined;\n  who(opts?: {\n    name?: string;\n    minLevel?: number;\n    maxLevel?: number;\n  }): Promise<WhoResult[]>;\n  getLastChatMode(): ChatMode;\n  setLastChatMode(mode: ChatMode): void;\n  sendInCurrentMode(message: string): void;\n  invite(name: string): void;\n  uninvite(name: string): void;\n  leaveGroup(): void;\n  setLeader(name: string): void;\n  acceptInvite(): void;\n  declineInvite(): void;\n  onGroupEvent(cb: (event: GroupEvent) => void): void;\n  onEntityEvent(cb: (event: EntityEvent) => void): void;\n  onPacketError(cb: (opcode: number, err: Error) => void): void;\n  getNearbyEntities(): Entity[];\n  getFriends(): FriendEntry[];\n  addFriend(name: string): void;\n  removeFriend(name: string): void;\n  onFriendEvent(cb: (event: FriendEvent) => void): void;\n};\n\ntype WorldConn = {\n  socket: Socket;\n  dispatch: OpcodeDispatch;\n  buf: AccumulatorBuffer;\n  arc4?: Arc4;\n  startTime: number;\n  pendingHeader?: { size: number; opcode: number };\n  nameCache: Map<number, string>;\n  pendingMessages: Map<number, RawChatMessage[]>;\n  channels: string[];\n  lastChatMode: ChatMode;\n  onMessage?: (msg: ChatMessage) => void;\n  selfName: string;\n  selfGuidLow: number;\n  selfGuidHigh: number;\n  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n  onGroupEvent?: (event: GroupEvent) => void;\n  entityStore: EntityStore;\n  creatureNameCache: Map<number, string>;\n  gameObjectNameCache: Map<number, string>;\n  onEntityEvent?: (event: EntityEvent) => void;\n  onPacketError?: (opcode: number, err: Error) => void;\n  pendingNameQueries: Set<string>;\n  friendStore: FriendStore;\n  onFriendEvent?: (event: FriendEvent) => void;\n};\n\nfunction handleChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n  srp: SRP,\n): SRPResult {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return srp.calculate(\n    result.g!,\n    result.N!,\n    result.salt!,\n    result.B!,\n    config.srpPrivateKey,\n  );\n}\n\nfunction handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonProofResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth proof failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n}\n\nfunction handleRealms(\n  raw: Uint8Array,\n): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n  const realms = parseRealmList(new PacketReader(raw, 1));\n  if (realms.length === 0) throw new Error(\"No realms available\");\n  const realm = realms[0]!;\n  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n}\n\nexport class ReconnectRequiredError extends Error {\n  constructor() {\n    super(\"Server requires reconnect but no cached session key is available\");\n    this.name = \"ReconnectRequiredError\";\n  }\n}\n\nfunction handleReconnectChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n): Uint8Array {\n  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n  const r = new PacketReader(raw);\n  const result = parseReconnectChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return buildReconnectProof(\n    config.account,\n    result.challengeData!,\n    config.cachedSessionKey,\n  );\n}\n\nfunction handleReconnectProof(raw: Uint8Array): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const status = r.uint8();\n  if (status !== 0x00) {\n    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n  }\n}\n\nexport async function authWithRetry(\n  config: ClientConfig,\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\n): Promise<AuthResult> {\n  const maxAttempts = opts?.maxAttempts ?? 5;\n  const baseDelay = opts?.baseDelayMs ?? 5000;\n  let lastError: unknown;\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await authHandshake(config);\n    } catch (err) {\n      if (!(err instanceof ReconnectRequiredError)) throw err;\n      lastError = err;\n      if (attempt + 1 < maxAttempts) {\n        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n        await Bun.sleep(delay);\n      }\n    }\n  }\n  throw lastError;\n}\n\ntype AuthContext = {\n  buf: AccumulatorBuffer;\n  srp: SRP;\n  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n  config: ClientConfig;\n  srpResult?: SRPResult;\n  sessionKey?: Uint8Array;\n};\n\nfunction advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n  const raw = ctx.buf.peek(ctx.buf.length);\n  let result: AuthResult | undefined;\n\n  if (ctx.phase === \"challenge\") {\n    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n      socket.write(handleReconnectChallenge(raw, ctx.config));\n      ctx.sessionKey = ctx.config.cachedSessionKey!;\n      ctx.phase = \"reconnect_proof\";\n    } else {\n      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n      ctx.sessionKey = ctx.srpResult.K;\n      socket.write(buildLogonProof(ctx.srpResult));\n      ctx.phase = \"proof\";\n    }\n  } else if (ctx.phase === \"proof\") {\n    handleProof(raw, ctx.srpResult!);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else if (ctx.phase === \"reconnect_proof\") {\n    handleReconnectProof(raw);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else {\n    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n  }\n\n  ctx.buf.drain(ctx.buf.length);\n  return result;\n}\n\nexport function authHandshake(config: ClientConfig): Promise<AuthResult> {\n  return new Promise((resolve, reject) => {\n    const ctx: AuthContext = {\n      buf: new AccumulatorBuffer(),\n      srp: new SRP(config.account, config.password),\n      phase: \"challenge\",\n      config,\n    };\n    let done = false;\n\n    Bun.connect({\n      hostname: config.host,\n      port: config.port,\n      socket: {\n        open(socket) {\n          socket.write(buildLogonChallenge(config.account));\n        },\n        data(socket, data) {\n          ctx.buf.append(new Uint8Array(data));\n          try {\n            const result = advanceAuth(ctx, socket);\n            if (result) {\n              done = true;\n              socket.end();\n              resolve(result);\n            }\n          } catch (err) {\n            if (err instanceof RangeError) return;\n            done = true;\n            reject(err);\n            socket.end();\n          }\n        },\n        close() {\n          if (!done) reject(new Error(\"Auth connection closed\"));\n        },\n      },\n    }).catch(reject);\n  });\n}\n\nfunction sendPacket(\n  conn: WorldConn,\n  opcode: number,\n  body: Uint8Array = new Uint8Array(0),\n): void {\n  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n}\n\nfunction drainWorldPackets(conn: WorldConn): void {\n  while (true) {\n    if (!conn.pendingHeader) {\n      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n      conn.pendingHeader = decryptIncomingHeader(\n        conn.buf.drain(INCOMING_HEADER_SIZE),\n        conn.arc4,\n      );\n    }\n    const bodySize = conn.pendingHeader.size - 2;\n    if (conn.buf.length < bodySize) break;\n\n    const { opcode } = conn.pendingHeader;\n    conn.pendingHeader = undefined;\n    try {\n      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n    } catch (err) {\n      if (err instanceof Error) {\n        conn.onPacketError?.(opcode, err);\n      }\n    }\n  }\n}\n\nfunction handleTimeSync(conn: WorldConn, r: PacketReader): void {\n  const counter = r.uint32LE();\n  const elapsed = Date.now() - conn.startTime;\n  const w = new PacketWriter();\n  w.uint32LE(counter);\n  w.uint32LE(elapsed);\n  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,\n    sender: name,\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n  if (pending) {\n    pending.push(raw);\n  } else {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  }\n}\n\nfunction handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r, true);\n  deliverMessage(conn, raw, raw.senderName ?? \"\");\n}\n\nfunction handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseNameQueryResponse(r);\n\n  const name = result.found && result.name ? result.name : \"\";\n  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n  if (result.found && result.name) {\n    conn.nameCache.set(result.guidLow, result.name);\n    for (const entity of conn.entityStore.all()) {\n      if (\n        entity.objectType === ObjectType.PLAYER &&\n        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n        !entity.name\n      ) {\n        conn.entityStore.setName(entity.guid, result.name);\n      }\n    }\n    for (const friend of conn.friendStore.all()) {\n      if (\n        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n        !friend.name\n      ) {\n        conn.friendStore.setName(friend.guid, result.name);\n      }\n    }\n  }\n\n  const pending = conn.pendingMessages.get(result.guidLow);\n  if (!pending) return;\n  for (const raw of pending) deliverMessage(conn, raw, name);\n  conn.pendingMessages.delete(result.guidLow);\n}\n\nfunction handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n  const event = parseChannelNotify(r);\n  if (event.type === \"joined\") {\n    conn.channels.push(event.channel);\n  } else if (event.type === \"left\") {\n    const idx = conn.channels.indexOf(event.channel);\n    if (idx !== -1) conn.channels.splice(idx, 1);\n  }\n}\n\nfunction handleMotd(conn: WorldConn, r: PacketReader): void {\n  const lineCount = r.uint32LE();\n  const lines: string[] = [];\n  for (let i = 0; i < lineCount; i++) {\n    lines.push(r.cString());\n  }\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: lines.join(\"\\n\"),\n  });\n}\n\nfunction handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n  const name = r.cString();\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: `No player named \"${name}\" is currently playing.`,\n  });\n}\n\nfunction handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n  const result = parsePartyCommandResult(r);\n  conn.onGroupEvent?.({\n    type: \"command_result\",\n    operation: result.operation,\n    target: result.member,\n    result: result.result,\n  });\n}\n\nfunction handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n  const invite = parseGroupInvite(r);\n  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n}\n\nfunction handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupSetLeader(r);\n  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n}\n\nfunction handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n  const list = parseGroupList(r);\n  conn.partyMembers.clear();\n  let leaderName = \"\";\n  if (\n    conn.selfGuidLow === list.leaderGuidLow &&\n    conn.selfGuidHigh === list.leaderGuidHigh\n  ) {\n    leaderName = conn.selfName;\n  }\n  for (const m of list.members) {\n    conn.partyMembers.set(m.name, {\n      guidLow: m.guidLow,\n      guidHigh: m.guidHigh,\n    });\n    if (\n      m.guidLow === list.leaderGuidLow &&\n      m.guidHigh === list.leaderGuidHigh\n    ) {\n      leaderName = m.name;\n    }\n  }\n  conn.onGroupEvent?.({\n    type: \"group_list\",\n    members: list.members,\n    leader: leaderName,\n  });\n}\n\nfunction handleGroupDestroyed(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n}\n\nfunction handleGroupUninvite(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"kicked\" });\n}\n\nfunction handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupDecline(r);\n  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n}\n\nfunction handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const entries = parseUpdateObject(r);\n  for (const entry of entries) {\n    switch (entry.type) {\n      case \"create\": {\n        const { _changed: _co, ...objFields } = extractObjectFields(\n          entry.fields,\n        );\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entry.objectType === ObjectType.UNIT ||\n          entry.objectType === ObjectType.PLAYER\n        ) {\n          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n          extraFields = rest;\n        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n          const { _changed: _cg, ...rest } = extractGameObjectFields(\n            entry.fields,\n          );\n          extraFields = rest;\n        }\n        const cachedName = lookupCachedName(\n          conn,\n          entry.guid,\n          entry.objectType,\n          objFields.entry,\n        );\n        conn.entityStore.create(entry.guid, entry.objectType, {\n          ...objFields,\n          ...extraFields,\n          ...(cachedName ? { name: cachedName } : {}),\n          ...(entry.position ? { position: entry.position } : {}),\n          rawFields: new Map(entry.fields),\n        } as any);\n        if (!cachedName) {\n          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n        }\n        break;\n      }\n      case \"values\": {\n        const entity = conn.entityStore.get(entry.guid);\n        if (!entity) break;\n        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entity.objectType === ObjectType.UNIT ||\n          entity.objectType === ObjectType.PLAYER\n        ) {\n          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n          extraFields = extractGameObjectFields(entry.fields);\n        }\n        const allChanged = [\n          ...(objFields._changed || []),\n          ...((extraFields as any)._changed || []),\n        ];\n        const merged: Record<string, unknown> = {};\n        for (const key of allChanged) {\n          if (key in extraFields) merged[key] = (extraFields as any)[key];\n          else if (key in objFields) merged[key] = (objFields as any)[key];\n        }\n        conn.entityStore.update(entry.guid, merged);\n        for (const [k, v] of entry.fields) {\n          const existing = conn.entityStore.get(entry.guid);\n          if (existing) existing.rawFields.set(k, v);\n        }\n        break;\n      }\n      case \"movement\": {\n        conn.entityStore.setPosition(entry.guid, entry.position);\n        break;\n      }\n      case \"outOfRange\": {\n        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n        break;\n      }\n      case \"nearObjects\": {\n        break;\n      }\n    }\n  }\n}\n\nfunction handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const uncompressedSize = r.uint32LE();\n  const compressed = r.bytes(r.remaining);\n  const decompressed = inflateSync(compressed);\n  if (decompressed.length !== uncompressedSize) {\n    throw new Error(\n      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n    );\n  }\n  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n}\n\nfunction handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n  const guid = r.uint64LE();\n  r.skip(1);\n  conn.entityStore.destroy(guid);\n}\n\nfunction lookupCachedName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): string | undefined {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    return conn.nameCache.get(guidLow);\n  }\n  if (entry === undefined) return undefined;\n  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n  if (objectType === ObjectType.GAMEOBJECT)\n    return conn.gameObjectNameCache.get(entry);\n  return undefined;\n}\n\nfunction queryEntityName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): void {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    const key = `player:${guidLow}`;\n    if (conn.pendingNameQueries.has(key)) return;\n    conn.pendingNameQueries.add(key);\n    const w = new PacketWriter();\n    w.uint64LE(guid);\n    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n    return;\n  }\n  if (entry === undefined) return;\n  const key = `${objectType}:${entry}`;\n  if (conn.pendingNameQueries.has(key)) return;\n  conn.pendingNameQueries.add(key);\n  if (objectType === ObjectType.UNIT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_CREATURE_QUERY,\n      buildCreatureQuery(entry, guid),\n    );\n    return;\n  }\n  if (objectType === ObjectType.GAMEOBJECT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n      buildGameObjectQuery(entry, guid),\n    );\n    return;\n  }\n}\n\nfunction handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseCreatureQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n  if (!result.name) return;\n  conn.creatureNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry && !entity.name) {\n      conn.entityStore.setName(entity.guid, result.name);\n    }\n  }\n}\n\nfunction handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseGameObjectQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n  if (!result.name) return;\n  conn.gameObjectNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry) {\n      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n      if (result.gameObjectType !== undefined) {\n        conn.entityStore.update(entity.guid, {\n          gameObjectType: result.gameObjectType,\n        });\n      }\n    }\n  }\n}\n\nfunction handlePartyMemberStatsMsg(\n  conn: WorldConn,\n  r: PacketReader,\n  isFull = false,\n): void {\n  const stats = parsePartyMemberStats(r, isFull);\n  conn.onGroupEvent?.({\n    type: \"member_stats\",\n    guidLow: stats.guidLow,\n    online: stats.online,\n    hp: stats.hp,\n    maxHp: stats.maxHp,\n    level: stats.level,\n  });\n}\n\nfunction handleContactList(conn: WorldConn, r: PacketReader): void {\n  const list = parseContactList(r);\n  const friends: FriendEntry[] = [];\n  for (const contact of list.contacts) {\n    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n    const guidLow = Number(contact.guid & 0xffffffffn);\n    const name = conn.nameCache.get(guidLow) ?? \"\";\n    friends.push({\n      guid: contact.guid,\n      name,\n      note: contact.note,\n      status: contact.status ?? 0,\n      area: contact.area ?? 0,\n      level: contact.level ?? 0,\n      playerClass: contact.playerClass ?? 0,\n    });\n    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n      conn.pendingNameQueries.add(`player:${guidLow}`);\n      sendPacket(\n        conn,\n        GameOpcode.CMSG_NAME_QUERY,\n        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n      );\n    }\n  }\n  conn.friendStore.set(friends);\n}\n\nfunction handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n  const packet = parseFriendStatus(r);\n  const guidLow = Number(packet.guid & 0xffffffffn);\n\n  switch (packet.result) {\n    case FriendResult.ADDED_ONLINE:\n    case FriendResult.ADDED_OFFLINE: {\n      const name = conn.nameCache.get(guidLow) ?? \"\";\n      conn.friendStore.add({\n        guid: packet.guid,\n        name,\n        note: packet.note ?? \"\",\n        status: packet.status ?? 0,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n        conn.pendingNameQueries.add(`player:${guidLow}`);\n        sendPacket(\n          conn,\n          GameOpcode.CMSG_NAME_QUERY,\n          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n        );\n      }\n      break;\n    }\n    case FriendResult.ONLINE:\n      conn.friendStore.update(packet.guid, {\n        status: packet.status ?? FriendStatus.ONLINE,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      break;\n    case FriendResult.OFFLINE:\n      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n      break;\n    case FriendResult.REMOVED:\n      conn.friendStore.remove(packet.guid);\n      break;\n    default: {\n      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n      conn.onFriendEvent?.({\n        type: \"friend-error\",\n        result: packet.result,\n        name,\n      });\n      break;\n    }\n  }\n}\n\nasync function authenticateWorld(\n  conn: WorldConn,\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<void> {\n  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n  challenge.uint32LE();\n  const serverSeed = challenge.bytes(4);\n\n  const body = await buildWorldAuthPacket(\n    config.account,\n    auth.sessionKey,\n    serverSeed,\n    auth.realmId,\n    config.clientSeed,\n  );\n  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n  conn.arc4 = new Arc4(auth.sessionKey);\n\n  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n  const status = resp.uint8();\n  if (status !== 0x0c) {\n    const names: Record<number, string> = {\n      0x0d: \"system error\",\n      0x15: \"account in use\",\n    };\n    const label = names[status] ?? `status 0x${status.toString(16)}`;\n    throw new Error(`World auth failed: ${label}`);\n  }\n}\n\nasync function selectCharacter(\n  conn: WorldConn,\n  config: ClientConfig,\n): Promise<void> {\n  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n\n  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n  const chars = parseCharacterList(enumReader);\n  const char = chars.find(\n    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n  );\n  if (!char) {\n    throw new Error(\n      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n    );\n  }\n\n  conn.selfName = char.name;\n  conn.selfGuidLow = char.guidLow;\n  conn.selfGuidHigh = char.guidHigh;\n\n  const w = new PacketWriter();\n  w.uint32LE(char.guidLow);\n  w.uint32LE(char.guidHigh);\n  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n\n  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n}\n\nfunction startPingLoop(\n  conn: WorldConn,\n  intervalMs: number,\n): ReturnType<typeof setInterval> {\n  return setInterval(() => {\n    const w = new PacketWriter();\n    w.uint32LE(0);\n    w.uint32LE(0);\n    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n  }, intervalMs);\n}\n\nexport function worldSession(\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<WorldHandle> {\n  return new Promise((resolve, reject) => {\n    const conn: WorldConn = {\n      socket: undefined!,\n      dispatch: new OpcodeDispatch(),\n      buf: new AccumulatorBuffer(),\n      startTime: Date.now(),\n      nameCache: new Map(),\n      pendingMessages: new Map(),\n      channels: [],\n      lastChatMode: { type: \"say\" },\n      selfName: \"\",\n      selfGuidLow: 0,\n      selfGuidHigh: 0,\n      partyMembers: new Map(),\n      entityStore: new EntityStore(),\n      creatureNameCache: new Map(),\n      gameObjectNameCache: new Map(),\n      pendingNameQueries: new Set(),\n      friendStore: new FriendStore(),\n    };\n    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n\n    let pingInterval: ReturnType<typeof setInterval>;\n    let done = false;\n    let closedResolve: () => void;\n    const closed = new Promise<void>((r) => {\n      closedResolve = r;\n    });\n\n    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n      handleTimeSync(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n      handleChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n      handleGmChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n      handleNameQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n      handlePlayerNotFound(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n      handleChannelNotify(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n      handlePartyCommandResult(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n      handleGroupInviteReceived(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n      handleGroupSetLeaderMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n      handleGroupListMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n      handleGroupDestroyed(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n      handleGroupUninvite(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n      handleGroupDeclineMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n      handlePartyMemberStatsMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n      handlePartyMemberStatsMsg(conn, r, true),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n      handleUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n      handleCompressedUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n      handleDestroyObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n      handleCreatureQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n      handleGameObjectQueryResponse(conn, r),\n    );\n\n    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n      handleContactList(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n      handleFriendStatus(conn, r),\n    );\n\n    registerStubs(conn.dispatch, (msg) => {\n      if (!conn.onMessage) return false;\n      conn.onMessage({\n        type: ChatType.SYSTEM,\n        sender: \"\",\n        message: msg,\n      });\n      return true;\n    });\n\n    async function login() {\n      await authenticateWorld(conn, config, auth);\n      await selectCharacter(conn, config);\n      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n      const lang = config.language ?? Language.COMMON;\n      done = true;\n      const handle: WorldHandle = {\n        closed,\n        close() {\n          clearInterval(pingInterval);\n          conn.onEntityEvent = undefined;\n          conn.onFriendEvent = undefined;\n          conn.socket.end();\n        },\n        onMessage(cb) {\n          conn.onMessage = cb;\n        },\n        sendWhisper(target, message) {\n          if (target) conn.lastChatMode = { type: \"whisper\", target };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.WHISPER, lang, message, target),\n          );\n        },\n        sendSay(message) {\n          conn.lastChatMode = { type: \"say\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.SAY, lang, message),\n          );\n        },\n        sendYell(message) {\n          conn.lastChatMode = { type: \"yell\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.YELL, lang, message),\n          );\n        },\n        sendGuild(message) {\n          conn.lastChatMode = { type: \"guild\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.GUILD, lang, message),\n          );\n        },\n        sendParty(message) {\n          conn.lastChatMode = { type: \"party\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.PARTY, lang, message),\n          );\n        },\n        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {\n          conn.lastChatMode = { type: \"channel\", channel };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n          );\n        },\n        getChannel(index) {\n          return conn.channels[index - 1];\n        },\n        async who(opts = {}) {\n          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n          return parseWhoResponse(r);\n        },\n        getLastChatMode() {\n          return conn.lastChatMode;\n        },\n        setLastChatMode(mode) {\n          conn.lastChatMode = mode;\n        },\n        sendInCurrentMode(message) {\n          const mode = conn.lastChatMode;\n          switch (mode.type) {\n            case \"say\":\n              handle.sendSay(message);\n              break;\n            case \"yell\":\n              handle.sendYell(message);\n              break;\n            case \"guild\":\n              handle.sendGuild(message);\n              break;\n            case \"party\":\n              handle.sendParty(message);\n              break;\n            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":\n              handle.sendWhisper(mode.target, message);\n              break;\n            case \"channel\":\n              handle.sendChannel(mode.channel, message);\n              break;\n          }\n        },\n        invite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_INVITE,\n            buildGroupInvite(name),\n          );\n        },\n        uninvite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_UNINVITE,\n            buildGroupUninvite(name),\n          );\n        },\n        leaveGroup() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n        },\n        setLeader(name) {\n          const member = conn.partyMembers.get(name);\n          if (!member) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not in your party.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_SET_LEADER,\n            buildGroupSetLeader(member.guidLow, member.guidHigh),\n          );\n        },\n        acceptInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n        },\n        declineInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n        },\n        onGroupEvent(cb) {\n          conn.onGroupEvent = cb;\n        },\n        onEntityEvent(cb) {\n          conn.onEntityEvent = cb;\n        },\n        onPacketError(cb) {\n          conn.onPacketError = cb;\n        },\n        getNearbyEntities() {\n          return conn.entityStore.all();\n        },\n        getFriends() {\n          return conn.friendStore.all();\n        },\n        addFriend(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_ADD_FRIEND,\n            buildAddFriend(name, \"\"),\n          );\n        },\n        removeFriend(name) {\n          const friend = conn.friendStore.findByName(name);\n          if (!friend) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not on your friends list.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_DEL_FRIEND,\n            buildDelFriend(friend.guid),\n          );\n        },\n        onFriendEvent(cb) {\n          conn.onFriendEvent = cb;\n        },\n      };\n      resolve(handle);\n    }\n\n    login().catch((err) => {\n      done = true;\n      clearInterval(pingInterval);\n      reject(err);\n      conn.socket?.end();\n    });\n\n    Bun.connect({\n      hostname: auth.realmHost,\n      port: auth.realmPort,\n      socket: {\n        open(s) {\n          conn.socket = s;\n        },\n        data(_s, data) {\n          conn.buf.append(new Uint8Array(data));\n          drainWorldPackets(conn);\n        },\n        close() {\n          clearInterval(pingInterval);\n          conn.entityStore.clear();\n          if (!done) reject(new Error(\"World connection closed\"));\n          closedResolve();\n        },\n      },\n    }).catch(reject);\n  });\n}\n","numLines":1307,"startLine":1,"totalLines":1307}},"sourceToolAssistantUUID":"76935d9f-cf6e-4b78-abf4-8a367ce9896f"}
{"parentUuid":"64e68462-4c8e-4e2f-9adc-14bd3d0c3d86","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01L8BPY4eheJsSLZzbttpNXc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015f9bVkjY1HHRNmLro4Vsdm","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/test/mock-handle.ts"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":468,"cache_read_input_tokens":35387,"output_tokens":236,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":468,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMPFQpd9dxLN3WxBFjP","type":"assistant","uuid":"5d83dbd3-10c5-4db3-82dd-a28c377e85c1","timestamp":"2026-02-28T23:41:46.102Z"}
{"parentUuid":"5d83dbd3-10c5-4db3-82dd-a28c377e85c1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015f9bVkjY1HHRNmLro4Vsdm","type":"tool_result","content":"     1→import { jest } from \"bun:test\";\n     2→import type {\n     3→  WorldHandle,\n     4→  ChatMessage,\n     5→  ChatMode,\n     6→  GroupEvent,\n     7→} from \"wow/client\";\n     8→import type { Entity, EntityEvent } from \"wow/entity-store\";\n     9→import type { FriendEntry, FriendEvent } from \"wow/friend-store\";\n    10→\n    11→export function createMockHandle(): WorldHandle & {\n    12→  triggerMessage(msg: ChatMessage): void;\n    13→  triggerGroupEvent(event: GroupEvent): void;\n    14→  triggerEntityEvent(event: EntityEvent): void;\n    15→  triggerFriendEvent(event: FriendEvent): void;\n    16→  resolveClosed(): void;\n    17→} {\n    18→  let messageCb: ((msg: ChatMessage) => void) | undefined;\n    19→  let groupEventCb: ((event: GroupEvent) => void) | undefined;\n    20→  let entityEventCb: ((event: EntityEvent) => void) | undefined;\n    21→  let friendEventCb: ((event: FriendEvent) => void) | undefined;\n    22→  let closeResolve: () => void;\n    23→  const closed = new Promise<void>((r) => {\n    24→    closeResolve = r;\n    25→  });\n    26→  let lastChatMode: ChatMode = { type: \"say\" };\n    27→\n    28→  return {\n    29→    closed,\n    30→    close: jest.fn(() => closeResolve()),\n    31→    onMessage(cb) {\n    32→      messageCb = cb;\n    33→    },\n    34→    sendWhisper: jest.fn(),\n    35→    sendSay: jest.fn(),\n    36→    sendYell: jest.fn(),\n    37→    sendGuild: jest.fn(),\n    38→    sendParty: jest.fn(),\n    39→    sendRaid: jest.fn(),\n    40→    sendChannel: jest.fn(),\n    41→    getChannel: jest.fn(),\n    42→    who: jest.fn(async () => []),\n    43→    getLastChatMode: jest.fn(() => lastChatMode),\n    44→    setLastChatMode: jest.fn((mode: ChatMode) => {\n    45→      lastChatMode = mode;\n    46→    }),\n    47→    sendInCurrentMode: jest.fn(),\n    48→    invite: jest.fn(),\n    49→    uninvite: jest.fn(),\n    50→    leaveGroup: jest.fn(),\n    51→    setLeader: jest.fn(),\n    52→    acceptInvite: jest.fn(),\n    53→    declineInvite: jest.fn(),\n    54→    onGroupEvent(cb) {\n    55→      groupEventCb = cb;\n    56→    },\n    57→    onEntityEvent(cb) {\n    58→      entityEventCb = cb;\n    59→    },\n    60→    onPacketError: jest.fn(),\n    61→    getNearbyEntities: jest.fn((): Entity[] => []),\n    62→    getFriends: jest.fn((): FriendEntry[] => []),\n    63→    addFriend: jest.fn(),\n    64→    removeFriend: jest.fn(),\n    65→    onFriendEvent(cb) {\n    66→      friendEventCb = cb;\n    67→    },\n    68→    triggerMessage(msg) {\n    69→      messageCb?.(msg);\n    70→    },\n    71→    triggerGroupEvent(event) {\n    72→      groupEventCb?.(event);\n    73→    },\n    74→    triggerEntityEvent(event) {\n    75→      entityEventCb?.(event);\n    76→    },\n    77→    triggerFriendEvent(event) {\n    78→      friendEventCb?.(event);\n    79→    },\n    80→    resolveClosed() {\n    81→      closeResolve();\n    82→    },\n    83→  };\n    84→}\n    85→"}]},"uuid":"84df0349-bf60-4057-abd0-83db3a123fc0","timestamp":"2026-02-28T23:41:46.104Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/test/mock-handle.ts","content":"import { jest } from \"bun:test\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  GroupEvent,\n} from \"wow/client\";\nimport type { Entity, EntityEvent } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\n\nexport function createMockHandle(): WorldHandle & {\n  triggerMessage(msg: ChatMessage): void;\n  triggerGroupEvent(event: GroupEvent): void;\n  triggerEntityEvent(event: EntityEvent): void;\n  triggerFriendEvent(event: FriendEvent): void;\n  resolveClosed(): void;\n} {\n  let messageCb: ((msg: ChatMessage) => void) | undefined;\n  let groupEventCb: ((event: GroupEvent) => void) | undefined;\n  let entityEventCb: ((event: EntityEvent) => void) | undefined;\n  let friendEventCb: ((event: FriendEvent) => void) | undefined;\n  let closeResolve: () => void;\n  const closed = new Promise<void>((r) => {\n    closeResolve = r;\n  });\n  let lastChatMode: ChatMode = { type: \"say\" };\n\n  return {\n    closed,\n    close: jest.fn(() => closeResolve()),\n    onMessage(cb) {\n      messageCb = cb;\n    },\n    sendWhisper: jest.fn(),\n    sendSay: jest.fn(),\n    sendYell: jest.fn(),\n    sendGuild: jest.fn(),\n    sendParty: jest.fn(),\n    sendRaid: jest.fn(),\n    sendChannel: jest.fn(),\n    getChannel: jest.fn(),\n    who: jest.fn(async () => []),\n    getLastChatMode: jest.fn(() => lastChatMode),\n    setLastChatMode: jest.fn((mode: ChatMode) => {\n      lastChatMode = mode;\n    }),\n    sendInCurrentMode: jest.fn(),\n    invite: jest.fn(),\n    uninvite: jest.fn(),\n    leaveGroup: jest.fn(),\n    setLeader: jest.fn(),\n    acceptInvite: jest.fn(),\n    declineInvite: jest.fn(),\n    onGroupEvent(cb) {\n      groupEventCb = cb;\n    },\n    onEntityEvent(cb) {\n      entityEventCb = cb;\n    },\n    onPacketError: jest.fn(),\n    getNearbyEntities: jest.fn((): Entity[] => []),\n    getFriends: jest.fn((): FriendEntry[] => []),\n    addFriend: jest.fn(),\n    removeFriend: jest.fn(),\n    onFriendEvent(cb) {\n      friendEventCb = cb;\n    },\n    triggerMessage(msg) {\n      messageCb?.(msg);\n    },\n    triggerGroupEvent(event) {\n      groupEventCb?.(event);\n    },\n    triggerEntityEvent(event) {\n      entityEventCb?.(event);\n    },\n    triggerFriendEvent(event) {\n      friendEventCb?.(event);\n    },\n    resolveClosed() {\n      closeResolve();\n    },\n  };\n}\n","numLines":85,"startLine":1,"totalLines":85}},"sourceToolAssistantUUID":"5d83dbd3-10c5-4db3-82dd-a28c377e85c1"}
{"parentUuid":"84df0349-bf60-4057-abd0-83db3a123fc0","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I need to also read the inline mock in `start.test.ts` and the existing test files. Let me also check help.ts, manual.md, SKILL.md, and README.md since the CLAUDE.md says I need to update all four when adding user-visible features.","signature":"EpQDCkYICxgCKkAuKx7tPBojgMuEJgUdK/uMJprfMMDxFxsbsmHHVJ0WZM4MYUB399o74Wy7YxqLC53xSs+0dVwSJu7ZlYOh+SypEgwaCh8TloQMxVTBCPEaDFzxZxvBt0glq+OpnSIwi5m5F9YP9DVu+/tehNX2eFOtiuL+69qE1ttbxo0occ+9zi4Bpocdo18T5/V6iZqdKvsBXo6FOAo/PUdc5ndFTTu5iKWtr1mIQF/F6PvyD0kPqQjFBRQ19s5HteSsZ7J8Q9oju/CxKQbTRRivJREofmlP/VaMuodi5bmWmH/teDIMZ8SFbdReY0fAvgJIQwJCgaUPyyj2ugANXlL0Xtc9jPjD0kxIzgJnW3OtGbsM7AaoD7+RkCTCeEVmL7ghYLO5jNYSuCZADiGxjF8HLJ6z+5qO2fHtmS5n8gmAofeMXGS2CYWAUU48xD7PVe3xZBLeCy5cRd+GCmLNMnrqG8tA5q3aDVRNQdm+G3WK7h/YBJrr1ZNhlnIDBrR+wXvcGdumuPEZ84j1Y5bATHNLjPgYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33298},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"07663a09-9541-49b8-a60e-6074f47b05c7","timestamp":"2026-02-28T23:41:51.720Z"}
{"parentUuid":"07663a09-9541-49b8-a60e-6074f47b05c7","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the test files and the files I need to update for docs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33298},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"a1fb1473-5d53-4e33-8879-b1008eed53b8","timestamp":"2026-02-28T23:41:52.525Z"}
{"parentUuid":"a1fb1473-5d53-4e33-8879-b1008eed53b8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RLf3hLQqSrMuJ9Qw7awM3s","name":"Grep","input":{"pattern":"sendSay|sendYell|sendRaid|sendGuild|sendParty","path":"/home/openclaw/code/tuicraft/src/daemon/start.test.ts","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33298},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"667e5ee1-f6aa-42f8-9cc7-f58a940310c3","timestamp":"2026-02-28T23:41:54.296Z"}
{"parentUuid":"667e5ee1-f6aa-42f8-9cc7-f58a940310c3","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RLf3hLQqSrMuJ9Qw7awM3s","type":"tool_result","content":"45-        closed,\n46-        close: mockHandleClose,\n47-        onMessage: jest.fn(),\n48:        sendSay: jest.fn(),\n49:        sendYell: jest.fn(),\n50:        sendGuild: jest.fn(),\n51:        sendParty: jest.fn(),\n52:        sendRaid: jest.fn(),\n53-        sendWhisper: jest.fn(),\n54-        sendChannel: jest.fn(),\n55-        getChannel: jest.fn(),"}]},"uuid":"b0375f4f-55a5-4d77-95c2-d0190a77aee8","timestamp":"2026-02-28T23:41:54.375Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"45-        closed,\n46-        close: mockHandleClose,\n47-        onMessage: jest.fn(),\n48:        sendSay: jest.fn(),\n49:        sendYell: jest.fn(),\n50:        sendGuild: jest.fn(),\n51:        sendParty: jest.fn(),\n52:        sendRaid: jest.fn(),\n53-        sendWhisper: jest.fn(),\n54-        sendChannel: jest.fn(),\n55-        getChannel: jest.fn(),","numLines":11},"sourceToolAssistantUUID":"667e5ee1-f6aa-42f8-9cc7-f58a940310c3"}
{"parentUuid":"b0375f4f-55a5-4d77-95c2-d0190a77aee8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019eG3Q5JSqqeruP8jgpanhY","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/cli/help.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33298},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"236a22be-5e81-4c73-8ba2-5bec5faace50","timestamp":"2026-02-28T23:41:54.815Z"}
{"parentUuid":"236a22be-5e81-4c73-8ba2-5bec5faace50","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019eG3Q5JSqqeruP8jgpanhY","type":"tool_result","content":"     1→export function helpText(): string {\n     2→  return `tuicraft — WoW 3.3.5a chat client\n     3→\n     4→USAGE\n     5→  tuicraft                    Interactive TUI mode\n     6→  tuicraft setup [flags]      Configure account credentials\n     7→  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n     8→  tuicraft send -w <name> \"m\" Whisper a player\n     9→  tuicraft send -y \"message\"  Yell\n    10→  tuicraft send -g \"message\"  Guild chat\n    11→  tuicraft send -p \"message\"  Party chat\n    12→  tuicraft who [filter]       Who query\n    13→  tuicraft read [--wait N]    Read buffered events\n    14→  tuicraft tail               Continuous event stream\n    15→  tuicraft status             Show daemon status\n    16→  tuicraft stop               Stop the daemon\n    17→  tuicraft logs               Print session log\n    18→  tuicraft skill              Print SKILL.md for AI agents\n    19→  tuicraft version            Print version and exit\n    20→  tuicraft help               Show this help\n    21→\n    22→FLAGS\n    23→  -v, --version   Print version and exit\n    24→  -h, --help      Show this help\n    25→  --json          Output events as JSONL (for read, tail, chat, who)\n    26→  --wait N        Wait N seconds for events (for read and send commands)\n    27→  --daemon        Start as background daemon (internal)\n    28→\n    29→SETUP FLAGS\n    30→  --account NAME  Account name (required)\n    31→  --password PASS Password (required)\n    32→  --character NAME Character name (required)\n    33→  --host HOST     Auth server hostname (default: t1)\n    34→  --port PORT     Auth server port (default: 3724)\n    35→  --language ID   Chat language code (default: 1/Orcish)\n    36→  --timeout_minutes N  Daemon idle timeout (default: 30)\n    37→\n    38→INTERACTIVE COMMANDS (TUI mode)\n    39→  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n    40→  /r              Reply to last whisper\n    41→  /who [filter]   Who search\n    42→  /invite <name>  Invite player to group\n    43→  /kick <name>    Remove player from group\n    44→  /leave          Leave the current group\n    45→  /leader <name>  Transfer group leadership\n    46→  /accept         Accept a group invitation\n    47→  /decline        Decline a group invitation\n    48→  /friends        Show your friends list\n    49→  /friend add <n> Add a player to friends\n    50→  /friend remove  Remove a player from friends\n    51→  /tuicraft entities on|off  Toggle entity event display\n    52→  /quit           Disconnect and exit\n    53→\n    54→DAEMON\n    55→  The daemon starts automatically when needed and stays running\n    56→  for 30 minutes of inactivity. It maintains the WoW connection\n    57→  and buffers events for CLI clients.\n    58→\n    59→FILES\n    60→  ~/.config/tuicraft/config.toml  Account config\n    61→  $TMPDIR/tuicraft-<uid>/sock     Daemon socket\n    62→  $TMPDIR/tuicraft-<uid>/pid     Daemon pidfile\n    63→  ~/.local/state/tuicraft/session.log  Session log`;\n    64→}\n    65→"}]},"uuid":"960f6c97-3204-4d82-8f88-38a46262bb91","timestamp":"2026-02-28T23:41:54.817Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/cli/help.ts","content":"export function helpText(): string {\n  return `tuicraft — WoW 3.3.5a chat client\n\nUSAGE\n  tuicraft                    Interactive TUI mode\n  tuicraft setup [flags]      Configure account credentials\n  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n  tuicraft send -w <name> \"m\" Whisper a player\n  tuicraft send -y \"message\"  Yell\n  tuicraft send -g \"message\"  Guild chat\n  tuicraft send -p \"message\"  Party chat\n  tuicraft who [filter]       Who query\n  tuicraft read [--wait N]    Read buffered events\n  tuicraft tail               Continuous event stream\n  tuicraft status             Show daemon status\n  tuicraft stop               Stop the daemon\n  tuicraft logs               Print session log\n  tuicraft skill              Print SKILL.md for AI agents\n  tuicraft version            Print version and exit\n  tuicraft help               Show this help\n\nFLAGS\n  -v, --version   Print version and exit\n  -h, --help      Show this help\n  --json          Output events as JSONL (for read, tail, chat, who)\n  --wait N        Wait N seconds for events (for read and send commands)\n  --daemon        Start as background daemon (internal)\n\nSETUP FLAGS\n  --account NAME  Account name (required)\n  --password PASS Password (required)\n  --character NAME Character name (required)\n  --host HOST     Auth server hostname (default: t1)\n  --port PORT     Auth server port (default: 3724)\n  --language ID   Chat language code (default: 1/Orcish)\n  --timeout_minutes N  Daemon idle timeout (default: 30)\n\nINTERACTIVE COMMANDS (TUI mode)\n  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n  /r              Reply to last whisper\n  /who [filter]   Who search\n  /invite <name>  Invite player to group\n  /kick <name>    Remove player from group\n  /leave          Leave the current group\n  /leader <name>  Transfer group leadership\n  /accept         Accept a group invitation\n  /decline        Decline a group invitation\n  /friends        Show your friends list\n  /friend add <n> Add a player to friends\n  /friend remove  Remove a player from friends\n  /tuicraft entities on|off  Toggle entity event display\n  /quit           Disconnect and exit\n\nDAEMON\n  The daemon starts automatically when needed and stays running\n  for 30 minutes of inactivity. It maintains the WoW connection\n  and buffers events for CLI clients.\n\nFILES\n  ~/.config/tuicraft/config.toml  Account config\n  $TMPDIR/tuicraft-<uid>/sock     Daemon socket\n  $TMPDIR/tuicraft-<uid>/pid     Daemon pidfile\n  ~/.local/state/tuicraft/session.log  Session log`;\n}\n","numLines":65,"startLine":1,"totalLines":65}},"sourceToolAssistantUUID":"236a22be-5e81-4c73-8ba2-5bec5faace50"}
{"parentUuid":"960f6c97-3204-4d82-8f88-38a46262bb91","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KnPjA1eeXCiriFnvZYUBGS","name":"Grep","input":{"pattern":"/emote|/e |text emote|EMOTE","path":"/home/openclaw/code/tuicraft/docs/manual.md","output_mode":"content","-C":2,"-i":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33298},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"6df3f6bd-bdbf-4435-8405-c33ab7ba8ad5","timestamp":"2026-02-28T23:41:56.274Z"}
{"parentUuid":"6df3f6bd-bdbf-4435-8405-c33ab7ba8ad5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KnPjA1eeXCiriFnvZYUBGS","type":"tool_result","content":"No matches found"}]},"uuid":"c35631e0-d7c3-4ce1-ab2a-1265baf0a4bc","timestamp":"2026-02-28T23:41:56.355Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"6df3f6bd-bdbf-4435-8405-c33ab7ba8ad5"}
{"parentUuid":"c35631e0-d7c3-4ce1-ab2a-1265baf0a4bc","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_019nxrSg4VcAtpj6JxUp95tt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mq9STwv4hf33dkWU7kH4rm","name":"Grep","input":{"pattern":"/emote|/e |text emote|EMOTE","path":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","output_mode":"content","-C":2,"-i":true},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":33298,"cache_read_input_tokens":35855,"output_tokens":574,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":33298,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMPZhfLnz19KPH6JkLN","type":"assistant","uuid":"7b049254-edec-4bc9-a549-81507b85b4e2","timestamp":"2026-02-28T23:41:57.499Z"}
{"parentUuid":"7b049254-edec-4bc9-a549-81507b85b4e2","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mq9STwv4hf33dkWU7kH4rm","type":"tool_result","content":"54-| WHISPER_TO       | Outgoing whisper confirmation                    |\n55-| CHANNEL          | Custom channel message                           |\n56:| EMOTE            | Player emote                                     |\n57-| SYSTEM           | System messages and unimplemented packet notices |\n58-| ENTITY_APPEAR    | NPC/player/object appeared nearby (--json only)  |"}]},"uuid":"070373d0-741c-4cd0-a26c-a15886d9013b","timestamp":"2026-02-28T23:41:57.579Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"54-| WHISPER_TO       | Outgoing whisper confirmation                    |\n55-| CHANNEL          | Custom channel message                           |\n56:| EMOTE            | Player emote                                     |\n57-| SYSTEM           | System messages and unimplemented packet notices |\n58-| ENTITY_APPEAR    | NPC/player/object appeared nearby (--json only)  |","numLines":5},"sourceToolAssistantUUID":"7b049254-edec-4bc9-a549-81507b85b4e2"}
{"parentUuid":"070373d0-741c-4cd0-a26c-a15886d9013b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Q2oGyu9btkYLD39JUi21Sm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017TsJgDZdJGNBe5ZwL5Pw8K","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/start.test.ts","offset":30,"limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1822,"cache_read_input_tokens":69153,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1822},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQPnPMkm9cvtqTUPuQ","type":"assistant","uuid":"f552f595-a859-4e68-b44b-0b91fcf5023a","timestamp":"2026-02-28T23:42:00.560Z"}
{"parentUuid":"f552f595-a859-4e68-b44b-0b91fcf5023a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017TsJgDZdJGNBe5ZwL5Pw8K","type":"tool_result","content":"    30→  const mockHandleClose = jest.fn();\n    31→  const closed = new Promise<void>((r) => {\n    32→    closedResolve = r;\n    33→  });\n    34→  return {\n    35→    authHandshake: jest.fn(\n    36→      async (): Promise<AuthResult> => ({\n    37→        sessionKey: new Uint8Array(40),\n    38→        realmHost: \"localhost\",\n    39→        realmPort: 8085,\n    40→        realmId: 1,\n    41→      }),\n    42→    ),\n    43→    worldSession: jest.fn(\n    44→      async (): Promise<WorldHandle> => ({\n    45→        closed,\n    46→        close: mockHandleClose,\n    47→        onMessage: jest.fn(),\n    48→        sendSay: jest.fn(),\n    49→        sendYell: jest.fn(),\n    50→        sendGuild: jest.fn(),\n    51→        sendParty: jest.fn(),\n    52→        sendRaid: jest.fn(),\n    53→        sendWhisper: jest.fn(),\n    54→        sendChannel: jest.fn(),\n    55→        getChannel: jest.fn(),\n    56→        who: jest.fn(async () => []),\n    57→        getLastChatMode: jest.fn(() => ({ type: \"say\" as const })),\n    58→        setLastChatMode: jest.fn(),\n    59→        sendInCurrentMode: jest.fn(),\n    60→        invite: jest.fn(),\n    61→        uninvite: jest.fn(),\n    62→        leaveGroup: jest.fn(),\n    63→        setLeader: jest.fn(),\n    64→        acceptInvite: jest.fn(),\n    65→        declineInvite: jest.fn(),\n    66→        onGroupEvent: jest.fn(),\n    67→        onEntityEvent: jest.fn(),\n    68→        onPacketError: jest.fn(),\n    69→        getNearbyEntities: jest.fn(() => []),\n    70→        getFriends: jest.fn(() => []),\n    71→        addFriend: jest.fn(),\n    72→        removeFriend: jest.fn(),\n    73→        onFriendEvent: jest.fn(),\n    74→      }),\n    75→    ),\n    76→    mockHandleClose,\n    77→  };\n    78→}\n    79→"}]},"uuid":"ff9d06cc-a456-4c46-8214-9b8492342458","timestamp":"2026-02-28T23:42:00.565Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/start.test.ts","content":"  const mockHandleClose = jest.fn();\n  const closed = new Promise<void>((r) => {\n    closedResolve = r;\n  });\n  return {\n    authHandshake: jest.fn(\n      async (): Promise<AuthResult> => ({\n        sessionKey: new Uint8Array(40),\n        realmHost: \"localhost\",\n        realmPort: 8085,\n        realmId: 1,\n      }),\n    ),\n    worldSession: jest.fn(\n      async (): Promise<WorldHandle> => ({\n        closed,\n        close: mockHandleClose,\n        onMessage: jest.fn(),\n        sendSay: jest.fn(),\n        sendYell: jest.fn(),\n        sendGuild: jest.fn(),\n        sendParty: jest.fn(),\n        sendRaid: jest.fn(),\n        sendWhisper: jest.fn(),\n        sendChannel: jest.fn(),\n        getChannel: jest.fn(),\n        who: jest.fn(async () => []),\n        getLastChatMode: jest.fn(() => ({ type: \"say\" as const })),\n        setLastChatMode: jest.fn(),\n        sendInCurrentMode: jest.fn(),\n        invite: jest.fn(),\n        uninvite: jest.fn(),\n        leaveGroup: jest.fn(),\n        setLeader: jest.fn(),\n        acceptInvite: jest.fn(),\n        declineInvite: jest.fn(),\n        onGroupEvent: jest.fn(),\n        onEntityEvent: jest.fn(),\n        onPacketError: jest.fn(),\n        getNearbyEntities: jest.fn(() => []),\n        getFriends: jest.fn(() => []),\n        addFriend: jest.fn(),\n        removeFriend: jest.fn(),\n        onFriendEvent: jest.fn(),\n      }),\n    ),\n    mockHandleClose,\n  };\n}\n","numLines":50,"startLine":30,"totalLines":263}},"sourceToolAssistantUUID":"f552f595-a859-4e68-b44b-0b91fcf5023a"}
{"parentUuid":"ff9d06cc-a456-4c46-8214-9b8492342458","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Q2oGyu9btkYLD39JUi21Sm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019MgAjMTAcAEBbWUkmV17cX","name":"Grep","input":{"pattern":"/say|/yell|/emote|/e |emote|EMOTE|say|yell","path":"/home/openclaw/code/tuicraft/docs/manual.md","output_mode":"content","-C":1},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1822,"cache_read_input_tokens":69153,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1822},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQPnPMkm9cvtqTUPuQ","type":"assistant","uuid":"da5f94a7-1d48-4920-9e44-787892b25c88","timestamp":"2026-02-28T23:42:02.368Z"}
{"parentUuid":"da5f94a7-1d48-4920-9e44-787892b25c88","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019MgAjMTAcAEBbWUkmV17cX","type":"tool_result","content":"34-`tuicraft` _message_\n35:: Send a say message. Auto-starts the daemon if needed.\n36-\n--\n143-```\n144:[say] Xi: hello world\n145-[whisper from Xiara] Following Deity"}]},"uuid":"8eb5108b-a3de-43a3-b22e-f7f1f6d7ba52","timestamp":"2026-02-28T23:42:02.447Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"34-`tuicraft` _message_\n35:: Send a say message. Auto-starts the daemon if needed.\n36-\n--\n143-```\n144:[say] Xi: hello world\n145-[whisper from Xiara] Following Deity","numLines":7},"sourceToolAssistantUUID":"da5f94a7-1d48-4920-9e44-787892b25c88"}
{"parentUuid":"8eb5108b-a3de-43a3-b22e-f7f1f6d7ba52","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Q2oGyu9btkYLD39JUi21Sm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LkKxjvDods9LPR3NWSW9BD","name":"Grep","input":{"pattern":"/say|/yell|/emote|emote|say|yell","path":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","output_mode":"content","-C":1},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1822,"cache_read_input_tokens":69153,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1822},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQPnPMkm9cvtqTUPuQ","type":"assistant","uuid":"f9f543e2-8920-4d58-871f-91c53361fc48","timestamp":"2026-02-28T23:42:03.423Z"}
{"parentUuid":"f9f543e2-8920-4d58-871f-91c53361fc48","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LkKxjvDods9LPR3NWSW9BD","type":"tool_result","content":"17-\n18:    tuicraft send \"message\"               # say (nearby players)\n19:    tuicraft send -y \"message\"            # yell (wider range)\n20-    tuicraft send -p \"message\"            # party chat\n--\n43-| ---------------- | ------------------------------------------------ |\n44:| SAY              | Nearby /say chat                                 |\n45:| YELL             | /yell chat                                       |\n46-| PARTY            | Party member message                             |\n--\n55-| CHANNEL          | Custom channel message                           |\n56:| EMOTE            | Player emote                                     |\n57-| SYSTEM           | System messages and unimplemented packet notices |"}]},"uuid":"89d122dc-5a5c-4031-9816-bf5c7124ab63","timestamp":"2026-02-28T23:42:03.504Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"17-\n18:    tuicraft send \"message\"               # say (nearby players)\n19:    tuicraft send -y \"message\"            # yell (wider range)\n20-    tuicraft send -p \"message\"            # party chat\n--\n43-| ---------------- | ------------------------------------------------ |\n44:| SAY              | Nearby /say chat                                 |\n45:| YELL             | /yell chat                                       |\n46-| PARTY            | Party member message                             |\n--\n55-| CHANNEL          | Custom channel message                           |\n56:| EMOTE            | Player emote                                     |\n57-| SYSTEM           | System messages and unimplemented packet notices |","numLines":13},"sourceToolAssistantUUID":"f9f543e2-8920-4d58-871f-91c53361fc48"}
{"parentUuid":"89d122dc-5a5c-4031-9816-bf5c7124ab63","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Q2oGyu9btkYLD39JUi21Sm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G1sAXPJ1wf2FVEBkhZFQpx","name":"Grep","input":{"pattern":"/say|/yell|/emote|emote|say|yell","path":"/home/openclaw/code/tuicraft/README.md","output_mode":"content","-C":1},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1822,"cache_read_input_tokens":69153,"output_tokens":485,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1822,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMQPnPMkm9cvtqTUPuQ","type":"assistant","uuid":"e26e15fd-0ba9-47cd-96ce-12bf6910aab8","timestamp":"2026-02-28T23:42:04.298Z"}
{"parentUuid":"e26e15fd-0ba9-47cd-96ce-12bf6910aab8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G1sAXPJ1wf2FVEBkhZFQpx","type":"tool_result","content":"13-\n14:💬 **Chat** - Say, yell, whisper, guild, party, raid, and channel messages with\n15-`/r` reply support\n--\n88-tuicraft                   # interactive TUI\n89:tuicraft send \"Hello\"      # send a say message (auto-starts daemon)\n90-tuicraft send -w Hemet \"x\" # whisper\n--\n103-      character select, keepalive\n104:- [x] 💬 **0.2 - Chat:** Send/receive whispers, say, guild chat. TUI with\n105-      interactive and pipe modes\n--\n134-| --------------------------------------- | ------ |\n135:| Say, yell                               | ✅     |\n136-| Whisper (`/w`, `/r`)                    | ✅     |\n--\n142-| Chat restricted / wrong faction notices | ❌     |\n143:| Text emotes (`/e`, `/emote`)            | ❌     |\n144-| DND / AFK status                        | ❌     |"}]},"uuid":"de620709-c513-4331-baa1-5f8ce3f9b7ad","timestamp":"2026-02-28T23:42:04.376Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"13-\n14:💬 **Chat** - Say, yell, whisper, guild, party, raid, and channel messages with\n15-`/r` reply support\n--\n88-tuicraft                   # interactive TUI\n89:tuicraft send \"Hello\"      # send a say message (auto-starts daemon)\n90-tuicraft send -w Hemet \"x\" # whisper\n--\n103-      character select, keepalive\n104:- [x] 💬 **0.2 - Chat:** Send/receive whispers, say, guild chat. TUI with\n105-      interactive and pipe modes\n--\n134-| --------------------------------------- | ------ |\n135:| Say, yell                               | ✅     |\n136-| Whisper (`/w`, `/r`)                    | ✅     |\n--\n142-| Chat restricted / wrong faction notices | ❌     |\n143:| Text emotes (`/e`, `/emote`)            | ❌     |\n144-| DND / AFK status                        | ❌     |","numLines":19},"sourceToolAssistantUUID":"e26e15fd-0ba9-47cd-96ce-12bf6910aab8"}
{"parentUuid":"de620709-c513-4331-baa1-5f8ce3f9b7ad","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Rhx8Xzi4pp4YidU6PFcKMo","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have all the context I need. Let me implement the changes. The pattern is crystal clear. Let me make the edits:\n\n1. **tui.ts**: Change `/e`/`/emote` from `unimplemented` to `{ type: \"emote\", message: rest }`. Add `emote` to the `Command` union. Add `executeCommand` case for emote.\n\n2. **client.ts**: Add `sendEmote` to `WorldHandle` type and implementation. Add `emote` to `ChatMode`. Add emote case to `sendInCurrentMode`.\n\n3. **commands.ts**: Add `emote` to `IpcCommand` union. \n\nNow I need to wire through `parseIpcCommand` and `dispatchCommand`, then update the mock implementations and documentation. Let me start with the production code changes.","signature":"Er8HCkYICxgCKkDb6rnvrfD6bAGpGH0mHYzWKJuqzjde2U07oX8BH0s8WbGExGY/BM36ROEUyWZLnpRxZZ+D9OpqfzMUgnhrVhF/EgyE+dCloV/KW9Z6WQoaDNOXjIgcfFhZ7pTdMCIwhZ88ZnytGl8V6R8pZLDmGGSFmEQimOtz68vMXjc146FRTVgyoyi85prVRH+YRsROKqYGsfel/osqxsliFx5TyHAFx98GTV4Mih0QuPZRmiHiKYUKwhtt0+4YwCYnyLEHmSYINpdfnuvRIj91NPUJ0VX7l9znwR8JrctOXoH44ZcwjJXZ2vC5JP0SDlIijvQTfOmaiqLlMwY4pL6mBA2in3jnRWNdXzM7x2G/62zd2dpVGWp6wcJg5xSZIKlTY9NdrrUsLTbzw2ncF6AyxHoLlV8xEuz5Ga+YjTcwFik2Yu2BdCzi+aJ71ybpSomXZBFePGqePRTlLkfwrvVzGmjcv1/TQkLcuZd/cdFbO+kW2xymt7fswO7qX6EDTc154fE2agbUEs3Xvj2ViGAhZF/OrQ4Rd/0Am93HpXNvRhmwa/7R2a9W6ZBSGhYTeEQce1VPG5m19nQV+j0sDDCZjJj0HfrGMizzHsqseK8QFcrmPZYlURZDHeGQgAxIV40yQzMenqwvC58+Av6jBeKb56LgiHUxSoseNQ8GsKSLW8/y524Ov5eJ7kFVvgvf+Je52LdNQKwOcg59fxt+/cOjwW09+8cUPdl4UGXju7u2JW9yLJVeZ+wfPuOxfCiNC3xZdEfySkKPCIisnH7lRAERrTUObVDrRoJO1GBWXyWRhHYBjGbVJuOu3XxqLbInsf7xughPkkD+A1RPUcG8T9CHRymuvzK8RKHfDPDonNHJXRw/fxcqJKkZPGFI/krzVlp2rf1jPqA6aKYTfgWtLITF8HEfSd96g60E+MvIq1zOjyJVTOXeakVAmUmNhvD2X6aZKd6PPSvepUNX7F1OKX0mZbpaeB0xnoMV2d3uPcev+aIaAeFwv/tRAsEz08oRLhg4VpMav3SRvDGiyUVa2dFFWNDVG4sAG7lykiIVSFl1VUNg/Ee5zRmvCyWHZpuI1gTRFvtRT1tWQ9HOHkauKN7DhpHtkKByI4Mc4LfGl7aSmxUU3Ore1MZ9OJks+PaXbCyFb+44QQf2caniJ3mnnSmtx8H5H8fD3aI9MN/qsFkCN0u4wMak58/E85xQpO6s2hogyxygy+ppQ25u37eA4GWKNUDMjYoTyVbmFJCwVlSk7jcBPQjnz/sSLYkMJKsYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1962,"cache_read_input_tokens":70975,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1962},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQtpdZiMVEsei1PwHA","type":"assistant","uuid":"70768bda-d801-4e13-a9aa-2dec59ba4436","timestamp":"2026-02-28T23:42:12.410Z"}
{"parentUuid":"70768bda-d801-4e13-a9aa-2dec59ba4436","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Rhx8Xzi4pp4YidU6PFcKMo","type":"message","role":"assistant","content":[{"type":"text","text":"I have full context. Let me implement everything now."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1962,"cache_read_input_tokens":70975,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1962},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQtpdZiMVEsei1PwHA","type":"assistant","uuid":"f2c938d3-74bd-4ddf-b05a-ff4b886ca32a","timestamp":"2026-02-28T23:42:12.435Z"}
{"parentUuid":"f2c938d3-74bd-4ddf-b05a-ff4b886ca32a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Rhx8Xzi4pp4YidU6PFcKMo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SDtQS2f1B1c5KKHRTgQhrk","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.ts","old_string":"  | { type: \"raid\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }","new_string":"  | { type: \"raid\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1962,"cache_read_input_tokens":70975,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1962},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQtpdZiMVEsei1PwHA","type":"assistant","uuid":"224d2c04-988d-4666-86a2-81f47b6eb7d8","timestamp":"2026-02-28T23:42:14.192Z"}
{"parentUuid":"224d2c04-988d-4666-86a2-81f47b6eb7d8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SDtQS2f1B1c5KKHRTgQhrk","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/ui/tui.ts has been updated successfully."}]},"uuid":"fe83c642-525f-407f-a626-71a99d2f8212","timestamp":"2026-02-28T23:42:14.211Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.ts","oldString":"  | { type: \"raid\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }","newString":"  | { type: \"raid\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }","originalFile":"import { createInterface } from \"node:readline\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  WhoResult,\n  GroupEvent,\n} from \"wow/client\";\nimport type { EntityEvent, UnitEntity } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { LogEntry } from \"lib/session-log\";\nimport { stripColorCodes } from \"lib/strip-colors\";\n\nexport type Command =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"raid\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"reply\"; message: string }\n  | { type: \"channel\"; target: string; message: string }\n  | { type: \"who\"; target?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"quit\" }\n  | { type: \"tuicraft\"; subcommand: string; value: string }\n  | { type: \"friends\" }\n  | { type: \"add-friend\"; target: string }\n  | { type: \"remove-friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseCommand(input: string): Command {\n  if (!input.startsWith(\"/\")) return { type: \"chat\", message: input };\n\n  const spaceIdx = input.indexOf(\" \");\n  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : input.slice(spaceIdx + 1);\n\n  switch (cmd) {\n    case \"/s\":\n    case \"/say\":\n      return { type: \"say\", message: rest };\n    case \"/y\":\n    case \"/yell\":\n      return { type: \"yell\", message: rest };\n    case \"/g\":\n    case \"/guild\":\n      return { type: \"guild\", message: rest };\n    case \"/p\":\n    case \"/party\":\n      return { type: \"party\", message: rest };\n    case \"/raid\":\n      return { type: \"raid\", message: rest };\n    case \"/w\":\n    case \"/whisper\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"/r\":\n      return { type: \"reply\", message: rest };\n    case \"/who\":\n      return rest ? { type: \"who\", target: rest } : { type: \"who\" };\n    case \"/invite\":\n      return rest\n        ? { type: \"invite\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/kick\":\n      return rest\n        ? { type: \"kick\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/leave\":\n      return { type: \"leave\" };\n    case \"/leader\":\n      return rest\n        ? { type: \"leader\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/accept\":\n      return { type: \"accept\" };\n    case \"/decline\":\n      return { type: \"decline\" };\n    case \"/quit\":\n      return { type: \"quit\" };\n    case \"/tuicraft\": {\n      const parts = rest.split(\" \");\n      return {\n        type: \"tuicraft\",\n        subcommand: parts[0] ?? \"\",\n        value: parts[1] ?? \"\",\n      };\n    }\n    case \"/friends\":\n      return { type: \"friends\" };\n    case \"/f\":\n      return { type: \"friends\" };\n    case \"/friend\": {\n      const parts = rest.split(\" \");\n      const sub = parts[0] ?? \"\";\n      const target = parts.slice(1).join(\" \");\n      if (sub === \"add\" && target) return { type: \"add-friend\", target };\n      if (sub === \"remove\" && target) return { type: \"remove-friend\", target };\n      return { type: \"friends\" };\n    }\n    case \"/ignore\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"/join\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"/ginvite\":\n    case \"/gkick\":\n    case \"/gleave\":\n    case \"/gpromote\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"/mail\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"/roll\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"/dnd\":\n    case \"/afk\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"/e\":\n    case \"/emote\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default: {\n      const channelMatch = cmd.match(/^\\/(\\d+)$/);\n      if (channelMatch) {\n        return { type: \"channel\", target: channelMatch[1]!, message: rest };\n      }\n      return { type: \"say\", message: input };\n    }\n  }\n}\n\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.OFFICER]: \"officer\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.CHANNEL]: \"channel\",\n  [ChatType.RAID_LEADER]: \"raid leader\",\n  [ChatType.RAID_WARNING]: \"raid warning\",\n  [ChatType.PARTY_LEADER]: \"party leader\",\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.WHISPER_INFORM) {\n    return `[whisper to ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.SYSTEM) {\n    return `[system] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"SYSTEM\",\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.PARTY]: \"PARTY\",\n  [ChatType.RAID]: \"RAID\",\n  [ChatType.GUILD]: \"GUILD\",\n  [ChatType.OFFICER]: \"OFFICER\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.WHISPER]: \"WHISPER_FROM\",\n  [ChatType.WHISPER_INFORM]: \"WHISPER_TO\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  [ChatType.CHANNEL]: \"CHANNEL\",\n  [ChatType.RAID_LEADER]: \"RAID_LEADER\",\n  [ChatType.RAID_WARNING]: \"RAID_WARNING\",\n  [ChatType.PARTY_LEADER]: \"PARTY_LEADER\",\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n\nexport function formatMessageJson(msg: ChatMessage): string {\n  return JSON.stringify(formatMessageObj(msg));\n}\n\nexport function formatError(message: string): string {\n  return `[system] ${message}`;\n}\n\nexport function formatWhoResults(results: WhoResult[]): string {\n  const names =\n    results.map((r) => `${r.name} (${r.level})`).join(\", \") || \"none\";\n  return `[who] ${results.length} results: ${names}`;\n}\n\nexport function formatWhoResultsJson(results: WhoResult[]): string {\n  return JSON.stringify({\n    type: \"WHO\",\n    count: results.length,\n    results: results.map((r) => ({\n      name: r.name,\n      guild: r.guild,\n      level: r.level,\n      classId: r.classId,\n      race: r.race,\n      gender: r.gender,\n      zone: r.zone,\n    })),\n  });\n}\n\nexport function formatPrompt(mode: ChatMode): string {\n  switch (mode.type) {\n    case \"whisper\":\n      return `[whisper: ${mode.target}] > `;\n    case \"channel\":\n      return `[${mode.channel}] > `;\n    default:\n      return `[${mode.type}] > `;\n  }\n}\n\nfunction partyResultLabel(result: number): string {\n  switch (result) {\n    case PartyResult.BAD_PLAYER_NAME:\n      return \"player not found\";\n    case PartyResult.GROUP_FULL:\n      return \"group is full\";\n    case PartyResult.ALREADY_IN_GROUP:\n      return \"already in a group\";\n    case PartyResult.NOT_LEADER:\n      return \"you are not the leader\";\n    case PartyResult.PLAYER_WRONG_FACTION:\n      return \"wrong faction\";\n    case PartyResult.IGNORING_YOU:\n      return \"player is ignoring you\";\n    default:\n      return `error ${result}`;\n  }\n}\n\nexport function formatGroupEvent(event: GroupEvent): string | undefined {\n  switch (event.type) {\n    case \"invite_received\":\n      return `[group] ${event.from} invites you to a group`;\n    case \"command_result\": {\n      const verb =\n        event.operation === PartyOperation.UNINVITE\n          ? \"kick\"\n          : event.operation === PartyOperation.LEAVE\n            ? \"leave\"\n            : \"invite\";\n      const label =\n        event.result === PartyResult.SUCCESS\n          ? verb === \"kick\"\n            ? `Removed ${event.target} from group`\n            : verb === \"leave\"\n              ? \"Left the group\"\n              : `Invited ${event.target}`\n          : `Cannot ${verb}${event.target ? ` ${event.target}` : \"\"}: ${partyResultLabel(event.result)}`;\n      return `[group] ${label}`;\n    }\n    case \"leader_changed\":\n      return `[group] ${event.name} is now the group leader`;\n    case \"group_destroyed\":\n      return \"[group] Group has been disbanded\";\n    case \"kicked\":\n      return \"[group] You have been removed from the group\";\n    case \"invite_declined\":\n      return `[group] ${event.name} has declined your invitation`;\n    case \"group_list\":\n    case \"member_stats\":\n      return undefined;\n  }\n}\n\nexport function formatEntityEvent(event: EntityEvent): string | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      if (!e.name) return undefined;\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        const kind = e.objectType === ObjectType.PLAYER ? \"Player\" : \"NPC\";\n        const levelStr = unit.level > 0 ? `, level ${unit.level}` : \"\";\n        return `[world] ${e.name} appeared (${kind}${levelStr})`;\n      }\n      if (e.objectType === ObjectType.GAMEOBJECT) {\n        return `[world] ${e.name} appeared (GameObject)`;\n      }\n      return undefined;\n    }\n    case \"disappear\": {\n      const name = event.name ?? \"Unknown entity\";\n      return `[world] ${name} left range`;\n    }\n    case \"update\": {\n      if (!event.changed.includes(\"name\") || !event.entity.name)\n        return undefined;\n      return formatEntityEvent({ type: \"appear\", entity: event.entity });\n    }\n  }\n}\n\nexport function formatEntityEventObj(\n  event: EntityEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      const obj: Record<string, unknown> = {\n        type: \"ENTITY_APPEAR\",\n        guid: `0x${e.guid.toString(16)}`,\n        objectType: e.objectType,\n        name: e.name,\n      };\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        obj[\"level\"] = unit.level;\n        obj[\"health\"] = unit.health;\n        obj[\"maxHealth\"] = unit.maxHealth;\n      }\n      if (e.position) {\n        obj[\"x\"] = e.position.x;\n        obj[\"y\"] = e.position.y;\n        obj[\"z\"] = e.position.z;\n      }\n      return obj;\n    }\n    case \"disappear\":\n      return {\n        type: \"ENTITY_DISAPPEAR\",\n        guid: `0x${event.guid.toString(16)}`,\n        name: event.name,\n      };\n    case \"update\":\n      return undefined;\n  }\n}\n\nconst CLASS_NAMES: Record<number, string> = {\n  1: \"Warrior\",\n  2: \"Paladin\",\n  3: \"Hunter\",\n  4: \"Rogue\",\n  5: \"Priest\",\n  6: \"Death Knight\",\n  7: \"Shaman\",\n  8: \"Mage\",\n  9: \"Warlock\",\n  11: \"Druid\",\n};\n\nfunction friendStatusLabel(status: number): string {\n  if (status === FriendStatus.AFK) return \"AFK\";\n  if (status === FriendStatus.DND) return \"DND\";\n  if (status !== FriendStatus.OFFLINE) return \"Online\";\n  return \"Offline\";\n}\n\nexport function formatFriendList(friends: FriendEntry[]): string {\n  if (friends.length === 0) return \"[friends] No friends on your list\";\n  const lines = friends.map((f) => {\n    const name = f.name || `guid:${Number(f.guid & 0xffffffffn)}`;\n    if (f.status === FriendStatus.OFFLINE) return `  ${name} — Offline`;\n    const cls = CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`;\n    const statusLabel = friendStatusLabel(f.status);\n    return `  ${name} — ${statusLabel}, Level ${f.level} ${cls}`;\n  });\n  const online = friends.filter(\n    (f) => f.status !== FriendStatus.OFFLINE,\n  ).length;\n  return `[friends] ${online}/${friends.length} online\\n${lines.join(\"\\n\")}`;\n}\n\nexport function formatFriendListJson(friends: FriendEntry[]): string {\n  return JSON.stringify({\n    type: \"FRIENDS\",\n    count: friends.length,\n    online: friends.filter((f) => f.status !== FriendStatus.OFFLINE).length,\n    friends: friends.map((f) => ({\n      guid: `0x${f.guid.toString(16)}`,\n      name: f.name,\n      note: f.note,\n      status: friendStatusLabel(f.status).toUpperCase(),\n      level: f.level,\n      class: CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`,\n      area: f.area,\n    })),\n  });\n}\n\nfunction friendResultLabel(result: number): string {\n  const labels: Record<number, string> = {\n    0x00: \"database error\",\n    0x01: \"friends list is full\",\n    0x04: \"player not found\",\n    0x08: \"already on friends list\",\n    0x09: \"cannot add yourself\",\n    0x0a: \"cannot add enemy faction\",\n  };\n  return labels[result] ?? `error ${result}`;\n}\n\nexport function formatFriendEvent(event: FriendEvent): string | undefined {\n  switch (event.type) {\n    case \"friend-online\": {\n      const f = event.friend;\n      const cls = CLASS_NAMES[f.playerClass] ?? \"\";\n      const lvl = f.level ? `Level ${f.level}` : \"\";\n      const detail = [lvl, cls].filter(Boolean).join(\" \");\n      return `[friends] ${f.name || \"Unknown\"} is now online${detail ? ` (${detail})` : \"\"}`;\n    }\n    case \"friend-offline\":\n      return `[friends] ${event.name || \"Unknown\"} went offline`;\n    case \"friend-added\": {\n      const f = event.friend;\n      return `[friends] ${f.name || \"Unknown\"} added to friends list`;\n    }\n    case \"friend-removed\":\n      return `[friends] ${event.name || \"Unknown\"} removed from friends list`;\n    case \"friend-error\":\n      return `[friends] Error: ${friendResultLabel(event.result)}`;\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport function formatFriendEventObj(\n  event: FriendEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"friend-online\":\n      return {\n        type: \"FRIEND_ONLINE\",\n        name: event.friend.name,\n        level: event.friend.level,\n        class: CLASS_NAMES[event.friend.playerClass],\n        area: event.friend.area,\n      };\n    case \"friend-offline\":\n      return { type: \"FRIEND_OFFLINE\", name: event.name };\n    case \"friend-added\":\n      return { type: \"FRIEND_ADDED\", name: event.friend.name };\n    case \"friend-removed\":\n      return { type: \"FRIEND_REMOVED\", name: event.name };\n    case \"friend-error\":\n      return {\n        type: \"FRIEND_ERROR\",\n        result: event.result,\n        message: friendResultLabel(event.result),\n      };\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport type TuiState = {\n  handle: WorldHandle;\n  write: (s: string) => void;\n  lastWhisperFrom: string | undefined;\n  showEntityEvents: boolean;\n};\n\nexport async function executeCommand(\n  state: TuiState,\n  cmd: Command,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\":\n      state.handle.sendInCurrentMode(cmd.message);\n      break;\n    case \"say\":\n      state.handle.sendSay(cmd.message);\n      break;\n    case \"yell\":\n      state.handle.sendYell(cmd.message);\n      break;\n    case \"guild\":\n      state.handle.sendGuild(cmd.message);\n      break;\n    case \"party\":\n      state.handle.sendParty(cmd.message);\n      break;\n    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"whisper\":\n      state.handle.sendWhisper(cmd.target, cmd.message);\n      state.lastWhisperFrom = cmd.target;\n      break;\n    case \"reply\":\n      if (!state.lastWhisperFrom) {\n        state.write(formatError(\"No one has whispered you yet.\") + \"\\n\");\n      } else {\n        state.handle.sendWhisper(state.lastWhisperFrom, cmd.message);\n      }\n      break;\n    case \"channel\": {\n      const channel = /^\\d+$/.test(cmd.target)\n        ? state.handle.getChannel(parseInt(cmd.target, 10))\n        : cmd.target;\n      if (!channel) {\n        state.write(formatError(`Not in channel ${cmd.target}.`) + \"\\n\");\n      } else {\n        state.handle.sendChannel(channel, cmd.message);\n      }\n      break;\n    }\n    case \"who\": {\n      const results = await state.handle.who(\n        cmd.target ? { name: cmd.target } : {},\n      );\n      state.write(formatWhoResults(results) + \"\\n\");\n      break;\n    }\n    case \"invite\":\n      state.handle.invite(cmd.target);\n      break;\n    case \"kick\":\n      state.handle.uninvite(cmd.target);\n      break;\n    case \"leave\":\n      state.handle.leaveGroup();\n      break;\n    case \"leader\":\n      state.handle.setLeader(cmd.target);\n      break;\n    case \"accept\":\n      state.handle.acceptInvite();\n      break;\n    case \"decline\":\n      state.handle.declineInvite();\n      break;\n    case \"quit\":\n      return true;\n    case \"tuicraft\":\n      if (cmd.subcommand === \"entities\") {\n        if (cmd.value === \"on\") {\n          state.showEntityEvents = true;\n          state.write(\"[system] Entity events enabled\\n\");\n        } else if (cmd.value === \"off\") {\n          state.showEntityEvents = false;\n          state.write(\"[system] Entity events disabled\\n\");\n        } else {\n          state.write(\"[system] Usage: /tuicraft entities on|off\\n\");\n        }\n      } else {\n        state.write(`[system] Unknown tuicraft command: ${cmd.subcommand}\\n`);\n      }\n      break;\n    case \"friends\": {\n      const friends = state.handle.getFriends();\n      state.write(formatFriendList(friends) + \"\\n\");\n      break;\n    }\n    case \"add-friend\":\n      state.handle.addFriend(cmd.target);\n      break;\n    case \"remove-friend\":\n      state.handle.removeFriend(cmd.target);\n      break;\n    case \"unimplemented\":\n      state.write(formatError(`${cmd.feature} is not yet implemented`) + \"\\n\");\n      break;\n  }\n  return false;\n}\n\nexport type TuiOptions = {\n  input?: NodeJS.ReadableStream;\n  write?: (s: string) => void;\n};\n\nexport function startTui(\n  handle: WorldHandle,\n  interactive: boolean,\n  opts: TuiOptions = {},\n): Promise<void> {\n  const write = opts.write ?? ((s: string) => void process.stdout.write(s));\n  const state: TuiState = {\n    handle,\n    write,\n    lastWhisperFrom: undefined,\n    showEntityEvents: false,\n  };\n\n  return new Promise<void>((resolve) => {\n    handle.onMessage((msg) => {\n      if (msg.type === ChatType.WHISPER) state.lastWhisperFrom = msg.sender;\n      const line = formatMessage(msg);\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onGroupEvent((event) => {\n      const line = formatGroupEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onEntityEvent((event) => {\n      if (!state.showEntityEvents) return;\n      const line = formatEntityEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    const rl = createInterface({\n      input: opts.input ?? process.stdin,\n      output: interactive ? process.stdout : undefined,\n      prompt: interactive ? formatPrompt(handle.getLastChatMode()) : \"\",\n      terminal: interactive,\n    });\n\n    if (interactive) rl.prompt();\n\n    rl.on(\"line\", async (input) => {\n      try {\n        if (await executeCommand(state, parseCommand(input.trim()))) {\n          handle.close();\n          rl.close();\n          resolve();\n          return;\n        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        write(formatError(msg) + \"\\n\");\n      }\n      if (interactive) {\n        rl.setPrompt(formatPrompt(handle.getLastChatMode()));\n        rl.prompt();\n      }\n    });\n\n    rl.on(\"SIGINT\", () => {\n      handle.close();\n      rl.close();\n    });\n\n    rl.on(\"close\", () => {\n      handle.close();\n      resolve();\n    });\n\n    handle.closed.then(() => rl.close());\n  });\n}\n","structuredPatch":[{"oldStart":21,"oldLines":6,"newStart":21,"newLines":7,"lines":["   | { type: \"guild\"; message: string }","   | { type: \"party\"; message: string }","   | { type: \"raid\"; message: string }","+  | { type: \"emote\"; message: string }","   | { type: \"whisper\"; target: string; message: string }","   | { type: \"reply\"; message: string }","   | { type: \"channel\"; target: string; message: string }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"224d2c04-988d-4666-86a2-81f47b6eb7d8"}
{"parentUuid":"fe83c642-525f-407f-a626-71a99d2f8212","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Rhx8Xzi4pp4YidU6PFcKMo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015s7dTxMiY38y1NXeVvoW2P","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.ts","old_string":"    case \"/e\":\n    case \"/emote\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };","new_string":"    case \"/e\":\n    case \"/emote\":\n      return { type: \"emote\", message: rest };"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1962,"cache_read_input_tokens":70975,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1962},"output_tokens":10,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMQtpdZiMVEsei1PwHA","type":"assistant","uuid":"f284468b-ad5f-41bc-a661-8eda56ff23d5","timestamp":"2026-02-28T23:42:15.500Z"}
{"parentUuid":"f284468b-ad5f-41bc-a661-8eda56ff23d5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015s7dTxMiY38y1NXeVvoW2P","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/ui/tui.ts has been updated successfully."}]},"uuid":"c6c7e22d-ce65-4b32-8f92-3d8d651c5220","timestamp":"2026-02-28T23:42:15.508Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.ts","oldString":"    case \"/e\":\n    case \"/emote\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };","newString":"    case \"/e\":\n    case \"/emote\":\n      return { type: \"emote\", message: rest };","originalFile":"import { createInterface } from \"node:readline\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  WhoResult,\n  GroupEvent,\n} from \"wow/client\";\nimport type { EntityEvent, UnitEntity } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { LogEntry } from \"lib/session-log\";\nimport { stripColorCodes } from \"lib/strip-colors\";\n\nexport type Command =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"raid\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"reply\"; message: string }\n  | { type: \"channel\"; target: string; message: string }\n  | { type: \"who\"; target?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"quit\" }\n  | { type: \"tuicraft\"; subcommand: string; value: string }\n  | { type: \"friends\" }\n  | { type: \"add-friend\"; target: string }\n  | { type: \"remove-friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseCommand(input: string): Command {\n  if (!input.startsWith(\"/\")) return { type: \"chat\", message: input };\n\n  const spaceIdx = input.indexOf(\" \");\n  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : input.slice(spaceIdx + 1);\n\n  switch (cmd) {\n    case \"/s\":\n    case \"/say\":\n      return { type: \"say\", message: rest };\n    case \"/y\":\n    case \"/yell\":\n      return { type: \"yell\", message: rest };\n    case \"/g\":\n    case \"/guild\":\n      return { type: \"guild\", message: rest };\n    case \"/p\":\n    case \"/party\":\n      return { type: \"party\", message: rest };\n    case \"/raid\":\n      return { type: \"raid\", message: rest };\n    case \"/w\":\n    case \"/whisper\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"/r\":\n      return { type: \"reply\", message: rest };\n    case \"/who\":\n      return rest ? { type: \"who\", target: rest } : { type: \"who\" };\n    case \"/invite\":\n      return rest\n        ? { type: \"invite\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/kick\":\n      return rest\n        ? { type: \"kick\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/leave\":\n      return { type: \"leave\" };\n    case \"/leader\":\n      return rest\n        ? { type: \"leader\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/accept\":\n      return { type: \"accept\" };\n    case \"/decline\":\n      return { type: \"decline\" };\n    case \"/quit\":\n      return { type: \"quit\" };\n    case \"/tuicraft\": {\n      const parts = rest.split(\" \");\n      return {\n        type: \"tuicraft\",\n        subcommand: parts[0] ?? \"\",\n        value: parts[1] ?? \"\",\n      };\n    }\n    case \"/friends\":\n      return { type: \"friends\" };\n    case \"/f\":\n      return { type: \"friends\" };\n    case \"/friend\": {\n      const parts = rest.split(\" \");\n      const sub = parts[0] ?? \"\";\n      const target = parts.slice(1).join(\" \");\n      if (sub === \"add\" && target) return { type: \"add-friend\", target };\n      if (sub === \"remove\" && target) return { type: \"remove-friend\", target };\n      return { type: \"friends\" };\n    }\n    case \"/ignore\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"/join\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"/ginvite\":\n    case \"/gkick\":\n    case \"/gleave\":\n    case \"/gpromote\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"/mail\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"/roll\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"/dnd\":\n    case \"/afk\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"/e\":\n    case \"/emote\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default: {\n      const channelMatch = cmd.match(/^\\/(\\d+)$/);\n      if (channelMatch) {\n        return { type: \"channel\", target: channelMatch[1]!, message: rest };\n      }\n      return { type: \"say\", message: input };\n    }\n  }\n}\n\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.OFFICER]: \"officer\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.CHANNEL]: \"channel\",\n  [ChatType.RAID_LEADER]: \"raid leader\",\n  [ChatType.RAID_WARNING]: \"raid warning\",\n  [ChatType.PARTY_LEADER]: \"party leader\",\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.WHISPER_INFORM) {\n    return `[whisper to ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.SYSTEM) {\n    return `[system] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"SYSTEM\",\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.PARTY]: \"PARTY\",\n  [ChatType.RAID]: \"RAID\",\n  [ChatType.GUILD]: \"GUILD\",\n  [ChatType.OFFICER]: \"OFFICER\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.WHISPER]: \"WHISPER_FROM\",\n  [ChatType.WHISPER_INFORM]: \"WHISPER_TO\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  [ChatType.CHANNEL]: \"CHANNEL\",\n  [ChatType.RAID_LEADER]: \"RAID_LEADER\",\n  [ChatType.RAID_WARNING]: \"RAID_WARNING\",\n  [ChatType.PARTY_LEADER]: \"PARTY_LEADER\",\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n\nexport function formatMessageJson(msg: ChatMessage): string {\n  return JSON.stringify(formatMessageObj(msg));\n}\n\nexport function formatError(message: string): string {\n  return `[system] ${message}`;\n}\n\nexport function formatWhoResults(results: WhoResult[]): string {\n  const names =\n    results.map((r) => `${r.name} (${r.level})`).join(\", \") || \"none\";\n  return `[who] ${results.length} results: ${names}`;\n}\n\nexport function formatWhoResultsJson(results: WhoResult[]): string {\n  return JSON.stringify({\n    type: \"WHO\",\n    count: results.length,\n    results: results.map((r) => ({\n      name: r.name,\n      guild: r.guild,\n      level: r.level,\n      classId: r.classId,\n      race: r.race,\n      gender: r.gender,\n      zone: r.zone,\n    })),\n  });\n}\n\nexport function formatPrompt(mode: ChatMode): string {\n  switch (mode.type) {\n    case \"whisper\":\n      return `[whisper: ${mode.target}] > `;\n    case \"channel\":\n      return `[${mode.channel}] > `;\n    default:\n      return `[${mode.type}] > `;\n  }\n}\n\nfunction partyResultLabel(result: number): string {\n  switch (result) {\n    case PartyResult.BAD_PLAYER_NAME:\n      return \"player not found\";\n    case PartyResult.GROUP_FULL:\n      return \"group is full\";\n    case PartyResult.ALREADY_IN_GROUP:\n      return \"already in a group\";\n    case PartyResult.NOT_LEADER:\n      return \"you are not the leader\";\n    case PartyResult.PLAYER_WRONG_FACTION:\n      return \"wrong faction\";\n    case PartyResult.IGNORING_YOU:\n      return \"player is ignoring you\";\n    default:\n      return `error ${result}`;\n  }\n}\n\nexport function formatGroupEvent(event: GroupEvent): string | undefined {\n  switch (event.type) {\n    case \"invite_received\":\n      return `[group] ${event.from} invites you to a group`;\n    case \"command_result\": {\n      const verb =\n        event.operation === PartyOperation.UNINVITE\n          ? \"kick\"\n          : event.operation === PartyOperation.LEAVE\n            ? \"leave\"\n            : \"invite\";\n      const label =\n        event.result === PartyResult.SUCCESS\n          ? verb === \"kick\"\n            ? `Removed ${event.target} from group`\n            : verb === \"leave\"\n              ? \"Left the group\"\n              : `Invited ${event.target}`\n          : `Cannot ${verb}${event.target ? ` ${event.target}` : \"\"}: ${partyResultLabel(event.result)}`;\n      return `[group] ${label}`;\n    }\n    case \"leader_changed\":\n      return `[group] ${event.name} is now the group leader`;\n    case \"group_destroyed\":\n      return \"[group] Group has been disbanded\";\n    case \"kicked\":\n      return \"[group] You have been removed from the group\";\n    case \"invite_declined\":\n      return `[group] ${event.name} has declined your invitation`;\n    case \"group_list\":\n    case \"member_stats\":\n      return undefined;\n  }\n}\n\nexport function formatEntityEvent(event: EntityEvent): string | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      if (!e.name) return undefined;\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        const kind = e.objectType === ObjectType.PLAYER ? \"Player\" : \"NPC\";\n        const levelStr = unit.level > 0 ? `, level ${unit.level}` : \"\";\n        return `[world] ${e.name} appeared (${kind}${levelStr})`;\n      }\n      if (e.objectType === ObjectType.GAMEOBJECT) {\n        return `[world] ${e.name} appeared (GameObject)`;\n      }\n      return undefined;\n    }\n    case \"disappear\": {\n      const name = event.name ?? \"Unknown entity\";\n      return `[world] ${name} left range`;\n    }\n    case \"update\": {\n      if (!event.changed.includes(\"name\") || !event.entity.name)\n        return undefined;\n      return formatEntityEvent({ type: \"appear\", entity: event.entity });\n    }\n  }\n}\n\nexport function formatEntityEventObj(\n  event: EntityEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      const obj: Record<string, unknown> = {\n        type: \"ENTITY_APPEAR\",\n        guid: `0x${e.guid.toString(16)}`,\n        objectType: e.objectType,\n        name: e.name,\n      };\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        obj[\"level\"] = unit.level;\n        obj[\"health\"] = unit.health;\n        obj[\"maxHealth\"] = unit.maxHealth;\n      }\n      if (e.position) {\n        obj[\"x\"] = e.position.x;\n        obj[\"y\"] = e.position.y;\n        obj[\"z\"] = e.position.z;\n      }\n      return obj;\n    }\n    case \"disappear\":\n      return {\n        type: \"ENTITY_DISAPPEAR\",\n        guid: `0x${event.guid.toString(16)}`,\n        name: event.name,\n      };\n    case \"update\":\n      return undefined;\n  }\n}\n\nconst CLASS_NAMES: Record<number, string> = {\n  1: \"Warrior\",\n  2: \"Paladin\",\n  3: \"Hunter\",\n  4: \"Rogue\",\n  5: \"Priest\",\n  6: \"Death Knight\",\n  7: \"Shaman\",\n  8: \"Mage\",\n  9: \"Warlock\",\n  11: \"Druid\",\n};\n\nfunction friendStatusLabel(status: number): string {\n  if (status === FriendStatus.AFK) return \"AFK\";\n  if (status === FriendStatus.DND) return \"DND\";\n  if (status !== FriendStatus.OFFLINE) return \"Online\";\n  return \"Offline\";\n}\n\nexport function formatFriendList(friends: FriendEntry[]): string {\n  if (friends.length === 0) return \"[friends] No friends on your list\";\n  const lines = friends.map((f) => {\n    const name = f.name || `guid:${Number(f.guid & 0xffffffffn)}`;\n    if (f.status === FriendStatus.OFFLINE) return `  ${name} — Offline`;\n    const cls = CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`;\n    const statusLabel = friendStatusLabel(f.status);\n    return `  ${name} — ${statusLabel}, Level ${f.level} ${cls}`;\n  });\n  const online = friends.filter(\n    (f) => f.status !== FriendStatus.OFFLINE,\n  ).length;\n  return `[friends] ${online}/${friends.length} online\\n${lines.join(\"\\n\")}`;\n}\n\nexport function formatFriendListJson(friends: FriendEntry[]): string {\n  return JSON.stringify({\n    type: \"FRIENDS\",\n    count: friends.length,\n    online: friends.filter((f) => f.status !== FriendStatus.OFFLINE).length,\n    friends: friends.map((f) => ({\n      guid: `0x${f.guid.toString(16)}`,\n      name: f.name,\n      note: f.note,\n      status: friendStatusLabel(f.status).toUpperCase(),\n      level: f.level,\n      class: CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`,\n      area: f.area,\n    })),\n  });\n}\n\nfunction friendResultLabel(result: number): string {\n  const labels: Record<number, string> = {\n    0x00: \"database error\",\n    0x01: \"friends list is full\",\n    0x04: \"player not found\",\n    0x08: \"already on friends list\",\n    0x09: \"cannot add yourself\",\n    0x0a: \"cannot add enemy faction\",\n  };\n  return labels[result] ?? `error ${result}`;\n}\n\nexport function formatFriendEvent(event: FriendEvent): string | undefined {\n  switch (event.type) {\n    case \"friend-online\": {\n      const f = event.friend;\n      const cls = CLASS_NAMES[f.playerClass] ?? \"\";\n      const lvl = f.level ? `Level ${f.level}` : \"\";\n      const detail = [lvl, cls].filter(Boolean).join(\" \");\n      return `[friends] ${f.name || \"Unknown\"} is now online${detail ? ` (${detail})` : \"\"}`;\n    }\n    case \"friend-offline\":\n      return `[friends] ${event.name || \"Unknown\"} went offline`;\n    case \"friend-added\": {\n      const f = event.friend;\n      return `[friends] ${f.name || \"Unknown\"} added to friends list`;\n    }\n    case \"friend-removed\":\n      return `[friends] ${event.name || \"Unknown\"} removed from friends list`;\n    case \"friend-error\":\n      return `[friends] Error: ${friendResultLabel(event.result)}`;\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport function formatFriendEventObj(\n  event: FriendEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"friend-online\":\n      return {\n        type: \"FRIEND_ONLINE\",\n        name: event.friend.name,\n        level: event.friend.level,\n        class: CLASS_NAMES[event.friend.playerClass],\n        area: event.friend.area,\n      };\n    case \"friend-offline\":\n      return { type: \"FRIEND_OFFLINE\", name: event.name };\n    case \"friend-added\":\n      return { type: \"FRIEND_ADDED\", name: event.friend.name };\n    case \"friend-removed\":\n      return { type: \"FRIEND_REMOVED\", name: event.name };\n    case \"friend-error\":\n      return {\n        type: \"FRIEND_ERROR\",\n        result: event.result,\n        message: friendResultLabel(event.result),\n      };\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport type TuiState = {\n  handle: WorldHandle;\n  write: (s: string) => void;\n  lastWhisperFrom: string | undefined;\n  showEntityEvents: boolean;\n};\n\nexport async function executeCommand(\n  state: TuiState,\n  cmd: Command,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\":\n      state.handle.sendInCurrentMode(cmd.message);\n      break;\n    case \"say\":\n      state.handle.sendSay(cmd.message);\n      break;\n    case \"yell\":\n      state.handle.sendYell(cmd.message);\n      break;\n    case \"guild\":\n      state.handle.sendGuild(cmd.message);\n      break;\n    case \"party\":\n      state.handle.sendParty(cmd.message);\n      break;\n    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"whisper\":\n      state.handle.sendWhisper(cmd.target, cmd.message);\n      state.lastWhisperFrom = cmd.target;\n      break;\n    case \"reply\":\n      if (!state.lastWhisperFrom) {\n        state.write(formatError(\"No one has whispered you yet.\") + \"\\n\");\n      } else {\n        state.handle.sendWhisper(state.lastWhisperFrom, cmd.message);\n      }\n      break;\n    case \"channel\": {\n      const channel = /^\\d+$/.test(cmd.target)\n        ? state.handle.getChannel(parseInt(cmd.target, 10))\n        : cmd.target;\n      if (!channel) {\n        state.write(formatError(`Not in channel ${cmd.target}.`) + \"\\n\");\n      } else {\n        state.handle.sendChannel(channel, cmd.message);\n      }\n      break;\n    }\n    case \"who\": {\n      const results = await state.handle.who(\n        cmd.target ? { name: cmd.target } : {},\n      );\n      state.write(formatWhoResults(results) + \"\\n\");\n      break;\n    }\n    case \"invite\":\n      state.handle.invite(cmd.target);\n      break;\n    case \"kick\":\n      state.handle.uninvite(cmd.target);\n      break;\n    case \"leave\":\n      state.handle.leaveGroup();\n      break;\n    case \"leader\":\n      state.handle.setLeader(cmd.target);\n      break;\n    case \"accept\":\n      state.handle.acceptInvite();\n      break;\n    case \"decline\":\n      state.handle.declineInvite();\n      break;\n    case \"quit\":\n      return true;\n    case \"tuicraft\":\n      if (cmd.subcommand === \"entities\") {\n        if (cmd.value === \"on\") {\n          state.showEntityEvents = true;\n          state.write(\"[system] Entity events enabled\\n\");\n        } else if (cmd.value === \"off\") {\n          state.showEntityEvents = false;\n          state.write(\"[system] Entity events disabled\\n\");\n        } else {\n          state.write(\"[system] Usage: /tuicraft entities on|off\\n\");\n        }\n      } else {\n        state.write(`[system] Unknown tuicraft command: ${cmd.subcommand}\\n`);\n      }\n      break;\n    case \"friends\": {\n      const friends = state.handle.getFriends();\n      state.write(formatFriendList(friends) + \"\\n\");\n      break;\n    }\n    case \"add-friend\":\n      state.handle.addFriend(cmd.target);\n      break;\n    case \"remove-friend\":\n      state.handle.removeFriend(cmd.target);\n      break;\n    case \"unimplemented\":\n      state.write(formatError(`${cmd.feature} is not yet implemented`) + \"\\n\");\n      break;\n  }\n  return false;\n}\n\nexport type TuiOptions = {\n  input?: NodeJS.ReadableStream;\n  write?: (s: string) => void;\n};\n\nexport function startTui(\n  handle: WorldHandle,\n  interactive: boolean,\n  opts: TuiOptions = {},\n): Promise<void> {\n  const write = opts.write ?? ((s: string) => void process.stdout.write(s));\n  const state: TuiState = {\n    handle,\n    write,\n    lastWhisperFrom: undefined,\n    showEntityEvents: false,\n  };\n\n  return new Promise<void>((resolve) => {\n    handle.onMessage((msg) => {\n      if (msg.type === ChatType.WHISPER) state.lastWhisperFrom = msg.sender;\n      const line = formatMessage(msg);\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onGroupEvent((event) => {\n      const line = formatGroupEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onEntityEvent((event) => {\n      if (!state.showEntityEvents) return;\n      const line = formatEntityEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    const rl = createInterface({\n      input: opts.input ?? process.stdin,\n      output: interactive ? process.stdout : undefined,\n      prompt: interactive ? formatPrompt(handle.getLastChatMode()) : \"\",\n      terminal: interactive,\n    });\n\n    if (interactive) rl.prompt();\n\n    rl.on(\"line\", async (input) => {\n      try {\n        if (await executeCommand(state, parseCommand(input.trim()))) {\n          handle.close();\n          rl.close();\n          resolve();\n          return;\n        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        write(formatError(msg) + \"\\n\");\n      }\n      if (interactive) {\n        rl.setPrompt(formatPrompt(handle.getLastChatMode()));\n        rl.prompt();\n      }\n    });\n\n    rl.on(\"SIGINT\", () => {\n      handle.close();\n      rl.close();\n    });\n\n    rl.on(\"close\", () => {\n      handle.close();\n      resolve();\n    });\n\n    handle.closed.then(() => rl.close());\n  });\n}\n","structuredPatch":[{"oldStart":134,"oldLines":7,"newStart":134,"newLines":7,"lines":["       return { type: \"unimplemented\", feature: \"Player status\" };","     case \"/e\":","     case \"/emote\":","-      return { type: \"unimplemented\", feature: \"Text emotes\" };","+      return { type: \"emote\", message: rest };","     default: {","       const channelMatch = cmd.match(/^\\/(\\d+)$/);","       if (channelMatch) {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f284468b-ad5f-41bc-a661-8eda56ff23d5"}
{"parentUuid":"c6c7e22d-ce65-4b32-8f92-3d8d651c5220","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Rhx8Xzi4pp4YidU6PFcKMo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018XjXkLdq2EqokQdf59foMd","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.ts","old_string":"    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;","new_string":"    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"emote\":\n      state.handle.sendEmote(cmd.message);\n      break;"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1962,"cache_read_input_tokens":70975,"output_tokens":774,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1962,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMQtpdZiMVEsei1PwHA","type":"assistant","uuid":"6428ea08-9887-49af-9991-b88ec6e96ffb","timestamp":"2026-02-28T23:42:16.784Z"}
{"parentUuid":"6428ea08-9887-49af-9991-b88ec6e96ffb","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018XjXkLdq2EqokQdf59foMd","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/ui/tui.ts has been updated successfully."}]},"uuid":"77f015f0-f11e-441b-bc3e-7af392317b10","timestamp":"2026-02-28T23:42:16.792Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.ts","oldString":"    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;","newString":"    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"emote\":\n      state.handle.sendEmote(cmd.message);\n      break;","originalFile":"import { createInterface } from \"node:readline\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  WhoResult,\n  GroupEvent,\n} from \"wow/client\";\nimport type { EntityEvent, UnitEntity } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { LogEntry } from \"lib/session-log\";\nimport { stripColorCodes } from \"lib/strip-colors\";\n\nexport type Command =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"raid\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"reply\"; message: string }\n  | { type: \"channel\"; target: string; message: string }\n  | { type: \"who\"; target?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"quit\" }\n  | { type: \"tuicraft\"; subcommand: string; value: string }\n  | { type: \"friends\" }\n  | { type: \"add-friend\"; target: string }\n  | { type: \"remove-friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseCommand(input: string): Command {\n  if (!input.startsWith(\"/\")) return { type: \"chat\", message: input };\n\n  const spaceIdx = input.indexOf(\" \");\n  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : input.slice(spaceIdx + 1);\n\n  switch (cmd) {\n    case \"/s\":\n    case \"/say\":\n      return { type: \"say\", message: rest };\n    case \"/y\":\n    case \"/yell\":\n      return { type: \"yell\", message: rest };\n    case \"/g\":\n    case \"/guild\":\n      return { type: \"guild\", message: rest };\n    case \"/p\":\n    case \"/party\":\n      return { type: \"party\", message: rest };\n    case \"/raid\":\n      return { type: \"raid\", message: rest };\n    case \"/w\":\n    case \"/whisper\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"/r\":\n      return { type: \"reply\", message: rest };\n    case \"/who\":\n      return rest ? { type: \"who\", target: rest } : { type: \"who\" };\n    case \"/invite\":\n      return rest\n        ? { type: \"invite\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/kick\":\n      return rest\n        ? { type: \"kick\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/leave\":\n      return { type: \"leave\" };\n    case \"/leader\":\n      return rest\n        ? { type: \"leader\", target: rest }\n        : { type: \"say\", message: input };\n    case \"/accept\":\n      return { type: \"accept\" };\n    case \"/decline\":\n      return { type: \"decline\" };\n    case \"/quit\":\n      return { type: \"quit\" };\n    case \"/tuicraft\": {\n      const parts = rest.split(\" \");\n      return {\n        type: \"tuicraft\",\n        subcommand: parts[0] ?? \"\",\n        value: parts[1] ?? \"\",\n      };\n    }\n    case \"/friends\":\n      return { type: \"friends\" };\n    case \"/f\":\n      return { type: \"friends\" };\n    case \"/friend\": {\n      const parts = rest.split(\" \");\n      const sub = parts[0] ?? \"\";\n      const target = parts.slice(1).join(\" \");\n      if (sub === \"add\" && target) return { type: \"add-friend\", target };\n      if (sub === \"remove\" && target) return { type: \"remove-friend\", target };\n      return { type: \"friends\" };\n    }\n    case \"/ignore\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"/join\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"/ginvite\":\n    case \"/gkick\":\n    case \"/gleave\":\n    case \"/gpromote\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"/mail\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"/roll\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"/dnd\":\n    case \"/afk\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"/e\":\n    case \"/emote\":\n      return { type: \"emote\", message: rest };\n    default: {\n      const channelMatch = cmd.match(/^\\/(\\d+)$/);\n      if (channelMatch) {\n        return { type: \"channel\", target: channelMatch[1]!, message: rest };\n      }\n      return { type: \"say\", message: input };\n    }\n  }\n}\n\nconst CHAT_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"system\",\n  [ChatType.SAY]: \"say\",\n  [ChatType.PARTY]: \"party\",\n  [ChatType.RAID]: \"raid\",\n  [ChatType.GUILD]: \"guild\",\n  [ChatType.OFFICER]: \"officer\",\n  [ChatType.YELL]: \"yell\",\n  [ChatType.WHISPER]: \"whisper from\",\n  [ChatType.WHISPER_INFORM]: \"whisper to\",\n  [ChatType.EMOTE]: \"emote\",\n  [ChatType.CHANNEL]: \"channel\",\n  [ChatType.RAID_LEADER]: \"raid leader\",\n  [ChatType.RAID_WARNING]: \"raid warning\",\n  [ChatType.PARTY_LEADER]: \"party leader\",\n};\n\nexport function formatMessage(msg: ChatMessage): string {\n  const message = stripColorCodes(msg.message);\n  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;\n\n  if (msg.type === ChatType.WHISPER) {\n    return `[whisper from ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.WHISPER_INFORM) {\n    return `[whisper to ${msg.sender}] ${message}`;\n  }\n  if (msg.type === ChatType.SYSTEM) {\n    return `[system] ${message}`;\n  }\n  if (msg.type === ChatType.CHANNEL && msg.channel) {\n    return `[${msg.channel}] ${msg.sender}: ${message}`;\n  }\n  return `[${label}] ${msg.sender}: ${message}`;\n}\n\nconst JSON_TYPE_LABELS: Record<number, string> = {\n  [ChatType.SYSTEM]: \"SYSTEM\",\n  [ChatType.SAY]: \"SAY\",\n  [ChatType.PARTY]: \"PARTY\",\n  [ChatType.RAID]: \"RAID\",\n  [ChatType.GUILD]: \"GUILD\",\n  [ChatType.OFFICER]: \"OFFICER\",\n  [ChatType.YELL]: \"YELL\",\n  [ChatType.WHISPER]: \"WHISPER_FROM\",\n  [ChatType.WHISPER_INFORM]: \"WHISPER_TO\",\n  [ChatType.EMOTE]: \"EMOTE\",\n  [ChatType.CHANNEL]: \"CHANNEL\",\n  [ChatType.RAID_LEADER]: \"RAID_LEADER\",\n  [ChatType.RAID_WARNING]: \"RAID_WARNING\",\n  [ChatType.PARTY_LEADER]: \"PARTY_LEADER\",\n};\n\nexport function formatMessageObj(msg: ChatMessage): LogEntry {\n  const type = JSON_TYPE_LABELS[msg.type] ?? `TYPE_${msg.type}`;\n  const obj: LogEntry = {\n    type,\n    sender: msg.sender,\n    message: stripColorCodes(msg.message),\n  };\n  if (msg.channel) obj.channel = msg.channel;\n  return obj;\n}\n\nexport function formatMessageJson(msg: ChatMessage): string {\n  return JSON.stringify(formatMessageObj(msg));\n}\n\nexport function formatError(message: string): string {\n  return `[system] ${message}`;\n}\n\nexport function formatWhoResults(results: WhoResult[]): string {\n  const names =\n    results.map((r) => `${r.name} (${r.level})`).join(\", \") || \"none\";\n  return `[who] ${results.length} results: ${names}`;\n}\n\nexport function formatWhoResultsJson(results: WhoResult[]): string {\n  return JSON.stringify({\n    type: \"WHO\",\n    count: results.length,\n    results: results.map((r) => ({\n      name: r.name,\n      guild: r.guild,\n      level: r.level,\n      classId: r.classId,\n      race: r.race,\n      gender: r.gender,\n      zone: r.zone,\n    })),\n  });\n}\n\nexport function formatPrompt(mode: ChatMode): string {\n  switch (mode.type) {\n    case \"whisper\":\n      return `[whisper: ${mode.target}] > `;\n    case \"channel\":\n      return `[${mode.channel}] > `;\n    default:\n      return `[${mode.type}] > `;\n  }\n}\n\nfunction partyResultLabel(result: number): string {\n  switch (result) {\n    case PartyResult.BAD_PLAYER_NAME:\n      return \"player not found\";\n    case PartyResult.GROUP_FULL:\n      return \"group is full\";\n    case PartyResult.ALREADY_IN_GROUP:\n      return \"already in a group\";\n    case PartyResult.NOT_LEADER:\n      return \"you are not the leader\";\n    case PartyResult.PLAYER_WRONG_FACTION:\n      return \"wrong faction\";\n    case PartyResult.IGNORING_YOU:\n      return \"player is ignoring you\";\n    default:\n      return `error ${result}`;\n  }\n}\n\nexport function formatGroupEvent(event: GroupEvent): string | undefined {\n  switch (event.type) {\n    case \"invite_received\":\n      return `[group] ${event.from} invites you to a group`;\n    case \"command_result\": {\n      const verb =\n        event.operation === PartyOperation.UNINVITE\n          ? \"kick\"\n          : event.operation === PartyOperation.LEAVE\n            ? \"leave\"\n            : \"invite\";\n      const label =\n        event.result === PartyResult.SUCCESS\n          ? verb === \"kick\"\n            ? `Removed ${event.target} from group`\n            : verb === \"leave\"\n              ? \"Left the group\"\n              : `Invited ${event.target}`\n          : `Cannot ${verb}${event.target ? ` ${event.target}` : \"\"}: ${partyResultLabel(event.result)}`;\n      return `[group] ${label}`;\n    }\n    case \"leader_changed\":\n      return `[group] ${event.name} is now the group leader`;\n    case \"group_destroyed\":\n      return \"[group] Group has been disbanded\";\n    case \"kicked\":\n      return \"[group] You have been removed from the group\";\n    case \"invite_declined\":\n      return `[group] ${event.name} has declined your invitation`;\n    case \"group_list\":\n    case \"member_stats\":\n      return undefined;\n  }\n}\n\nexport function formatEntityEvent(event: EntityEvent): string | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      if (!e.name) return undefined;\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        const kind = e.objectType === ObjectType.PLAYER ? \"Player\" : \"NPC\";\n        const levelStr = unit.level > 0 ? `, level ${unit.level}` : \"\";\n        return `[world] ${e.name} appeared (${kind}${levelStr})`;\n      }\n      if (e.objectType === ObjectType.GAMEOBJECT) {\n        return `[world] ${e.name} appeared (GameObject)`;\n      }\n      return undefined;\n    }\n    case \"disappear\": {\n      const name = event.name ?? \"Unknown entity\";\n      return `[world] ${name} left range`;\n    }\n    case \"update\": {\n      if (!event.changed.includes(\"name\") || !event.entity.name)\n        return undefined;\n      return formatEntityEvent({ type: \"appear\", entity: event.entity });\n    }\n  }\n}\n\nexport function formatEntityEventObj(\n  event: EntityEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"appear\": {\n      const e = event.entity;\n      const obj: Record<string, unknown> = {\n        type: \"ENTITY_APPEAR\",\n        guid: `0x${e.guid.toString(16)}`,\n        objectType: e.objectType,\n        name: e.name,\n      };\n      if (\n        e.objectType === ObjectType.UNIT ||\n        e.objectType === ObjectType.PLAYER\n      ) {\n        const unit = e as UnitEntity;\n        obj[\"level\"] = unit.level;\n        obj[\"health\"] = unit.health;\n        obj[\"maxHealth\"] = unit.maxHealth;\n      }\n      if (e.position) {\n        obj[\"x\"] = e.position.x;\n        obj[\"y\"] = e.position.y;\n        obj[\"z\"] = e.position.z;\n      }\n      return obj;\n    }\n    case \"disappear\":\n      return {\n        type: \"ENTITY_DISAPPEAR\",\n        guid: `0x${event.guid.toString(16)}`,\n        name: event.name,\n      };\n    case \"update\":\n      return undefined;\n  }\n}\n\nconst CLASS_NAMES: Record<number, string> = {\n  1: \"Warrior\",\n  2: \"Paladin\",\n  3: \"Hunter\",\n  4: \"Rogue\",\n  5: \"Priest\",\n  6: \"Death Knight\",\n  7: \"Shaman\",\n  8: \"Mage\",\n  9: \"Warlock\",\n  11: \"Druid\",\n};\n\nfunction friendStatusLabel(status: number): string {\n  if (status === FriendStatus.AFK) return \"AFK\";\n  if (status === FriendStatus.DND) return \"DND\";\n  if (status !== FriendStatus.OFFLINE) return \"Online\";\n  return \"Offline\";\n}\n\nexport function formatFriendList(friends: FriendEntry[]): string {\n  if (friends.length === 0) return \"[friends] No friends on your list\";\n  const lines = friends.map((f) => {\n    const name = f.name || `guid:${Number(f.guid & 0xffffffffn)}`;\n    if (f.status === FriendStatus.OFFLINE) return `  ${name} — Offline`;\n    const cls = CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`;\n    const statusLabel = friendStatusLabel(f.status);\n    return `  ${name} — ${statusLabel}, Level ${f.level} ${cls}`;\n  });\n  const online = friends.filter(\n    (f) => f.status !== FriendStatus.OFFLINE,\n  ).length;\n  return `[friends] ${online}/${friends.length} online\\n${lines.join(\"\\n\")}`;\n}\n\nexport function formatFriendListJson(friends: FriendEntry[]): string {\n  return JSON.stringify({\n    type: \"FRIENDS\",\n    count: friends.length,\n    online: friends.filter((f) => f.status !== FriendStatus.OFFLINE).length,\n    friends: friends.map((f) => ({\n      guid: `0x${f.guid.toString(16)}`,\n      name: f.name,\n      note: f.note,\n      status: friendStatusLabel(f.status).toUpperCase(),\n      level: f.level,\n      class: CLASS_NAMES[f.playerClass] ?? `class ${f.playerClass}`,\n      area: f.area,\n    })),\n  });\n}\n\nfunction friendResultLabel(result: number): string {\n  const labels: Record<number, string> = {\n    0x00: \"database error\",\n    0x01: \"friends list is full\",\n    0x04: \"player not found\",\n    0x08: \"already on friends list\",\n    0x09: \"cannot add yourself\",\n    0x0a: \"cannot add enemy faction\",\n  };\n  return labels[result] ?? `error ${result}`;\n}\n\nexport function formatFriendEvent(event: FriendEvent): string | undefined {\n  switch (event.type) {\n    case \"friend-online\": {\n      const f = event.friend;\n      const cls = CLASS_NAMES[f.playerClass] ?? \"\";\n      const lvl = f.level ? `Level ${f.level}` : \"\";\n      const detail = [lvl, cls].filter(Boolean).join(\" \");\n      return `[friends] ${f.name || \"Unknown\"} is now online${detail ? ` (${detail})` : \"\"}`;\n    }\n    case \"friend-offline\":\n      return `[friends] ${event.name || \"Unknown\"} went offline`;\n    case \"friend-added\": {\n      const f = event.friend;\n      return `[friends] ${f.name || \"Unknown\"} added to friends list`;\n    }\n    case \"friend-removed\":\n      return `[friends] ${event.name || \"Unknown\"} removed from friends list`;\n    case \"friend-error\":\n      return `[friends] Error: ${friendResultLabel(event.result)}`;\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport function formatFriendEventObj(\n  event: FriendEvent,\n): Record<string, unknown> | undefined {\n  switch (event.type) {\n    case \"friend-online\":\n      return {\n        type: \"FRIEND_ONLINE\",\n        name: event.friend.name,\n        level: event.friend.level,\n        class: CLASS_NAMES[event.friend.playerClass],\n        area: event.friend.area,\n      };\n    case \"friend-offline\":\n      return { type: \"FRIEND_OFFLINE\", name: event.name };\n    case \"friend-added\":\n      return { type: \"FRIEND_ADDED\", name: event.friend.name };\n    case \"friend-removed\":\n      return { type: \"FRIEND_REMOVED\", name: event.name };\n    case \"friend-error\":\n      return {\n        type: \"FRIEND_ERROR\",\n        result: event.result,\n        message: friendResultLabel(event.result),\n      };\n    case \"friend-list\":\n      return undefined;\n  }\n}\n\nexport type TuiState = {\n  handle: WorldHandle;\n  write: (s: string) => void;\n  lastWhisperFrom: string | undefined;\n  showEntityEvents: boolean;\n};\n\nexport async function executeCommand(\n  state: TuiState,\n  cmd: Command,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\":\n      state.handle.sendInCurrentMode(cmd.message);\n      break;\n    case \"say\":\n      state.handle.sendSay(cmd.message);\n      break;\n    case \"yell\":\n      state.handle.sendYell(cmd.message);\n      break;\n    case \"guild\":\n      state.handle.sendGuild(cmd.message);\n      break;\n    case \"party\":\n      state.handle.sendParty(cmd.message);\n      break;\n    case \"raid\":\n      state.handle.sendRaid(cmd.message);\n      break;\n    case \"whisper\":\n      state.handle.sendWhisper(cmd.target, cmd.message);\n      state.lastWhisperFrom = cmd.target;\n      break;\n    case \"reply\":\n      if (!state.lastWhisperFrom) {\n        state.write(formatError(\"No one has whispered you yet.\") + \"\\n\");\n      } else {\n        state.handle.sendWhisper(state.lastWhisperFrom, cmd.message);\n      }\n      break;\n    case \"channel\": {\n      const channel = /^\\d+$/.test(cmd.target)\n        ? state.handle.getChannel(parseInt(cmd.target, 10))\n        : cmd.target;\n      if (!channel) {\n        state.write(formatError(`Not in channel ${cmd.target}.`) + \"\\n\");\n      } else {\n        state.handle.sendChannel(channel, cmd.message);\n      }\n      break;\n    }\n    case \"who\": {\n      const results = await state.handle.who(\n        cmd.target ? { name: cmd.target } : {},\n      );\n      state.write(formatWhoResults(results) + \"\\n\");\n      break;\n    }\n    case \"invite\":\n      state.handle.invite(cmd.target);\n      break;\n    case \"kick\":\n      state.handle.uninvite(cmd.target);\n      break;\n    case \"leave\":\n      state.handle.leaveGroup();\n      break;\n    case \"leader\":\n      state.handle.setLeader(cmd.target);\n      break;\n    case \"accept\":\n      state.handle.acceptInvite();\n      break;\n    case \"decline\":\n      state.handle.declineInvite();\n      break;\n    case \"quit\":\n      return true;\n    case \"tuicraft\":\n      if (cmd.subcommand === \"entities\") {\n        if (cmd.value === \"on\") {\n          state.showEntityEvents = true;\n          state.write(\"[system] Entity events enabled\\n\");\n        } else if (cmd.value === \"off\") {\n          state.showEntityEvents = false;\n          state.write(\"[system] Entity events disabled\\n\");\n        } else {\n          state.write(\"[system] Usage: /tuicraft entities on|off\\n\");\n        }\n      } else {\n        state.write(`[system] Unknown tuicraft command: ${cmd.subcommand}\\n`);\n      }\n      break;\n    case \"friends\": {\n      const friends = state.handle.getFriends();\n      state.write(formatFriendList(friends) + \"\\n\");\n      break;\n    }\n    case \"add-friend\":\n      state.handle.addFriend(cmd.target);\n      break;\n    case \"remove-friend\":\n      state.handle.removeFriend(cmd.target);\n      break;\n    case \"unimplemented\":\n      state.write(formatError(`${cmd.feature} is not yet implemented`) + \"\\n\");\n      break;\n  }\n  return false;\n}\n\nexport type TuiOptions = {\n  input?: NodeJS.ReadableStream;\n  write?: (s: string) => void;\n};\n\nexport function startTui(\n  handle: WorldHandle,\n  interactive: boolean,\n  opts: TuiOptions = {},\n): Promise<void> {\n  const write = opts.write ?? ((s: string) => void process.stdout.write(s));\n  const state: TuiState = {\n    handle,\n    write,\n    lastWhisperFrom: undefined,\n    showEntityEvents: false,\n  };\n\n  return new Promise<void>((resolve) => {\n    handle.onMessage((msg) => {\n      if (msg.type === ChatType.WHISPER) state.lastWhisperFrom = msg.sender;\n      const line = formatMessage(msg);\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onGroupEvent((event) => {\n      const line = formatGroupEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    handle.onEntityEvent((event) => {\n      if (!state.showEntityEvents) return;\n      const line = formatEntityEvent(event);\n      if (!line) return;\n      write(interactive ? `\\r\\x1b[K${line}\\n` : line + \"\\n\");\n      if (interactive) rl.prompt(true);\n    });\n\n    const rl = createInterface({\n      input: opts.input ?? process.stdin,\n      output: interactive ? process.stdout : undefined,\n      prompt: interactive ? formatPrompt(handle.getLastChatMode()) : \"\",\n      terminal: interactive,\n    });\n\n    if (interactive) rl.prompt();\n\n    rl.on(\"line\", async (input) => {\n      try {\n        if (await executeCommand(state, parseCommand(input.trim()))) {\n          handle.close();\n          rl.close();\n          resolve();\n          return;\n        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        write(formatError(msg) + \"\\n\");\n      }\n      if (interactive) {\n        rl.setPrompt(formatPrompt(handle.getLastChatMode()));\n        rl.prompt();\n      }\n    });\n\n    rl.on(\"SIGINT\", () => {\n      handle.close();\n      rl.close();\n    });\n\n    rl.on(\"close\", () => {\n      handle.close();\n      resolve();\n    });\n\n    handle.closed.then(() => rl.close());\n  });\n}\n","structuredPatch":[{"oldStart":521,"oldLines":6,"newStart":521,"newLines":9,"lines":["     case \"raid\":","       state.handle.sendRaid(cmd.message);","       break;","+    case \"emote\":","+      state.handle.sendEmote(cmd.message);","+      break;","     case \"whisper\":","       state.handle.sendWhisper(cmd.target, cmd.message);","       state.lastWhisperFrom = cmd.target;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"6428ea08-9887-49af-9991-b88ec6e96ffb"}
{"parentUuid":"77f015f0-f11e-441b-bc3e-7af392317b10","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_015AMKKb59io7acw9LVukZxT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DzMB38ffwoBZTFrDBs2TqH","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"in_progress","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":987,"cache_read_input_tokens":72937,"output_tokens":311,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":987,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMRpibsph58JvuYxDpv","type":"assistant","uuid":"3fe99f53-8bdc-4152-b23f-d2590bfb9c22","timestamp":"2026-02-28T23:42:23.374Z"}
{"parentUuid":"3fe99f53-8bdc-4152-b23f-d2590bfb9c22","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DzMB38ffwoBZTFrDBs2TqH","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"2ffa8858-6998-4922-b670-5671d07736b3","timestamp":"2026-02-28T23:42:23.377Z","toolUseResult":{"oldTodos":[{"content":"Explore project context for emote support","status":"completed","activeForm":"Exploring project context for emote support"},{"content":"Ask clarifying questions","status":"completed","activeForm":"Asking clarifying questions"},{"content":"Propose approaches with trade-offs","status":"completed","activeForm":"Proposing approaches"},{"content":"Present design for approval","status":"completed","activeForm":"Presenting design"},{"content":"Update tui.ts parseCommand for /e and /emote","status":"in_progress","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"pending","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"in_progress","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"3fe99f53-8bdc-4152-b23f-d2590bfb9c22"}
{"parentUuid":"2ffa8858-6998-4922-b670-5671d07736b3","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UpEKp3bsr7SxppLgZoaNKu","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `client.ts` — add `emote` to `ChatMode`, `sendEmote` to `WorldHandle`, and the emote case to `sendInCurrentMode`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":73924,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMSJF4jhZe1nQFsY11M","type":"assistant","uuid":"88571201-3731-4314-9b7f-0bb12d49c311","timestamp":"2026-02-28T23:42:27.392Z"}
{"parentUuid":"88571201-3731-4314-9b7f-0bb12d49c311","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UpEKp3bsr7SxppLgZoaNKu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BPf8xsR84eFHs3MvXEG1MN","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.ts","old_string":"  | { type: \"raid\" }\n  | { type: \"whisper\"; target: string }","new_string":"  | { type: \"raid\" }\n  | { type: \"emote\" }\n  | { type: \"whisper\"; target: string }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":73924,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMSJF4jhZe1nQFsY11M","type":"assistant","uuid":"598498bf-fbb8-448e-8e99-b2f9defaceba","timestamp":"2026-02-28T23:42:28.351Z"}
{"parentUuid":"598498bf-fbb8-448e-8e99-b2f9defaceba","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BPf8xsR84eFHs3MvXEG1MN","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.ts has been updated successfully."}]},"uuid":"bcab0695-ebb5-4fd4-991d-411a77345831","timestamp":"2026-02-28T23:42:28.370Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.ts","oldString":"  | { type: \"raid\" }\n  | { type: \"whisper\"; target: string }","newString":"  | { type: \"raid\" }\n  | { type: \"emote\" }\n  | { type: \"whisper\"; target: string }","originalFile":"import type { Socket } from \"bun\";\nimport { inflateSync } from \"node:zlib\";\nimport { PacketReader, PacketWriter } from \"wow/protocol/packet\";\nimport { SRP, type SRPResult } from \"wow/crypto/srp\";\nimport { Arc4 } from \"wow/crypto/arc4\";\nimport {\n  GameOpcode,\n  ChatType,\n  Language,\n  AuthOpcode,\n} from \"wow/protocol/opcodes\";\nimport {\n  parseChatMessage,\n  buildChatMessage,\n  buildNameQuery,\n  parseNameQueryResponse,\n  parseChannelNotify,\n  buildWhoRequest,\n  parseWhoResponse,\n  type ChatMessage as RawChatMessage,\n  type WhoResult,\n} from \"wow/protocol/chat\";\nimport {\n  buildLogonChallenge,\n  parseLogonChallengeResponse,\n  buildLogonProof,\n  parseLogonProofResponse,\n  buildRealmListRequest,\n  parseRealmList,\n  parseReconnectChallengeResponse,\n  buildReconnectProof,\n} from \"wow/protocol/auth\";\nimport {\n  buildWorldAuthPacket,\n  parseCharacterList,\n  OpcodeDispatch,\n  AccumulatorBuffer,\n  INCOMING_HEADER_SIZE,\n  buildOutgoingPacket,\n  decryptIncomingHeader,\n} from \"wow/protocol/world\";\nimport {\n  buildGroupInvite,\n  buildGroupAccept,\n  buildGroupDecline,\n  buildGroupUninvite,\n  buildGroupDisband,\n  buildGroupSetLeader,\n  parsePartyCommandResult,\n  parseGroupInvite,\n  parseGroupSetLeader,\n  parseGroupDecline,\n  parseGroupList,\n  parsePartyMemberStats,\n} from \"wow/protocol/group\";\nimport { registerStubs } from \"wow/protocol/stubs\";\nimport { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\nimport {\n  FriendStore,\n  type FriendEntry,\n  type FriendEvent,\n} from \"wow/friend-store\";\nimport {\n  parseContactList,\n  parseFriendStatus,\n  buildAddFriend,\n  buildDelFriend,\n  SocialFlag,\n  FriendStatus,\n  FriendResult,\n} from \"wow/protocol/social\";\nimport { parseUpdateObject } from \"wow/protocol/update-object\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport {\n  extractObjectFields,\n  extractUnitFields,\n  extractGameObjectFields,\n} from \"wow/protocol/extract-fields\";\nimport {\n  buildCreatureQuery,\n  parseCreatureQueryResponse,\n  buildGameObjectQuery,\n  parseGameObjectQueryResponse,\n} from \"wow/protocol/entity-queries\";\n\nexport type ClientConfig = {\n  host: string;\n  port: number;\n  account: string;\n  password: string;\n  character: string;\n  srpPrivateKey?: bigint;\n  clientSeed?: Uint8Array;\n  pingIntervalMs?: number;\n  language?: number;\n  cachedSessionKey?: Uint8Array;\n};\n\nexport type AuthResult = {\n  sessionKey: Uint8Array;\n  realmHost: string;\n  realmPort: number;\n  realmId: number;\n};\n\nexport type ChatMessage = {\n  type: number;\n  sender: string;\n  message: string;\n  channel?: string;\n};\n\nexport type GroupEvent =\n  | { type: \"invite_received\"; from: string }\n  | {\n      type: \"command_result\";\n      operation: number;\n      target: string;\n      result: number;\n    }\n  | { type: \"leader_changed\"; name: string }\n  | {\n      type: \"group_list\";\n      members: Array<{\n        name: string;\n        guidLow: number;\n        guidHigh: number;\n        online: boolean;\n      }>;\n      leader: string;\n    }\n  | { type: \"group_destroyed\" }\n  | { type: \"kicked\" }\n  | { type: \"invite_declined\"; name: string }\n  | {\n      type: \"member_stats\";\n      guidLow: number;\n      online?: boolean;\n      hp?: number;\n      maxHp?: number;\n      level?: number;\n    };\n\nexport type { WhoResult };\nexport type { Entity, EntityEvent };\nexport type { FriendEntry, FriendEvent };\n\nexport type ChatMode =\n  | { type: \"say\" }\n  | { type: \"yell\" }\n  | { type: \"guild\" }\n  | { type: \"party\" }\n  | { type: \"raid\" }\n  | { type: \"whisper\"; target: string }\n  | { type: \"channel\"; channel: string };\n\nexport type WorldHandle = {\n  closed: Promise<void>;\n  close(): void;\n  onMessage(cb: (msg: ChatMessage) => void): void;\n  sendWhisper(target: string, message: string): void;\n  sendSay(message: string): void;\n  sendYell(message: string): void;\n  sendGuild(message: string): void;\n  sendParty(message: string): void;\n  sendRaid(message: string): void;\n  sendChannel(channel: string, message: string): void;\n  getChannel(index: number): string | undefined;\n  who(opts?: {\n    name?: string;\n    minLevel?: number;\n    maxLevel?: number;\n  }): Promise<WhoResult[]>;\n  getLastChatMode(): ChatMode;\n  setLastChatMode(mode: ChatMode): void;\n  sendInCurrentMode(message: string): void;\n  invite(name: string): void;\n  uninvite(name: string): void;\n  leaveGroup(): void;\n  setLeader(name: string): void;\n  acceptInvite(): void;\n  declineInvite(): void;\n  onGroupEvent(cb: (event: GroupEvent) => void): void;\n  onEntityEvent(cb: (event: EntityEvent) => void): void;\n  onPacketError(cb: (opcode: number, err: Error) => void): void;\n  getNearbyEntities(): Entity[];\n  getFriends(): FriendEntry[];\n  addFriend(name: string): void;\n  removeFriend(name: string): void;\n  onFriendEvent(cb: (event: FriendEvent) => void): void;\n};\n\ntype WorldConn = {\n  socket: Socket;\n  dispatch: OpcodeDispatch;\n  buf: AccumulatorBuffer;\n  arc4?: Arc4;\n  startTime: number;\n  pendingHeader?: { size: number; opcode: number };\n  nameCache: Map<number, string>;\n  pendingMessages: Map<number, RawChatMessage[]>;\n  channels: string[];\n  lastChatMode: ChatMode;\n  onMessage?: (msg: ChatMessage) => void;\n  selfName: string;\n  selfGuidLow: number;\n  selfGuidHigh: number;\n  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n  onGroupEvent?: (event: GroupEvent) => void;\n  entityStore: EntityStore;\n  creatureNameCache: Map<number, string>;\n  gameObjectNameCache: Map<number, string>;\n  onEntityEvent?: (event: EntityEvent) => void;\n  onPacketError?: (opcode: number, err: Error) => void;\n  pendingNameQueries: Set<string>;\n  friendStore: FriendStore;\n  onFriendEvent?: (event: FriendEvent) => void;\n};\n\nfunction handleChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n  srp: SRP,\n): SRPResult {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return srp.calculate(\n    result.g!,\n    result.N!,\n    result.salt!,\n    result.B!,\n    config.srpPrivateKey,\n  );\n}\n\nfunction handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonProofResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth proof failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n}\n\nfunction handleRealms(\n  raw: Uint8Array,\n): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n  const realms = parseRealmList(new PacketReader(raw, 1));\n  if (realms.length === 0) throw new Error(\"No realms available\");\n  const realm = realms[0]!;\n  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n}\n\nexport class ReconnectRequiredError extends Error {\n  constructor() {\n    super(\"Server requires reconnect but no cached session key is available\");\n    this.name = \"ReconnectRequiredError\";\n  }\n}\n\nfunction handleReconnectChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n): Uint8Array {\n  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n  const r = new PacketReader(raw);\n  const result = parseReconnectChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return buildReconnectProof(\n    config.account,\n    result.challengeData!,\n    config.cachedSessionKey,\n  );\n}\n\nfunction handleReconnectProof(raw: Uint8Array): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const status = r.uint8();\n  if (status !== 0x00) {\n    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n  }\n}\n\nexport async function authWithRetry(\n  config: ClientConfig,\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\n): Promise<AuthResult> {\n  const maxAttempts = opts?.maxAttempts ?? 5;\n  const baseDelay = opts?.baseDelayMs ?? 5000;\n  let lastError: unknown;\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await authHandshake(config);\n    } catch (err) {\n      if (!(err instanceof ReconnectRequiredError)) throw err;\n      lastError = err;\n      if (attempt + 1 < maxAttempts) {\n        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n        await Bun.sleep(delay);\n      }\n    }\n  }\n  throw lastError;\n}\n\ntype AuthContext = {\n  buf: AccumulatorBuffer;\n  srp: SRP;\n  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n  config: ClientConfig;\n  srpResult?: SRPResult;\n  sessionKey?: Uint8Array;\n};\n\nfunction advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n  const raw = ctx.buf.peek(ctx.buf.length);\n  let result: AuthResult | undefined;\n\n  if (ctx.phase === \"challenge\") {\n    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n      socket.write(handleReconnectChallenge(raw, ctx.config));\n      ctx.sessionKey = ctx.config.cachedSessionKey!;\n      ctx.phase = \"reconnect_proof\";\n    } else {\n      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n      ctx.sessionKey = ctx.srpResult.K;\n      socket.write(buildLogonProof(ctx.srpResult));\n      ctx.phase = \"proof\";\n    }\n  } else if (ctx.phase === \"proof\") {\n    handleProof(raw, ctx.srpResult!);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else if (ctx.phase === \"reconnect_proof\") {\n    handleReconnectProof(raw);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else {\n    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n  }\n\n  ctx.buf.drain(ctx.buf.length);\n  return result;\n}\n\nexport function authHandshake(config: ClientConfig): Promise<AuthResult> {\n  return new Promise((resolve, reject) => {\n    const ctx: AuthContext = {\n      buf: new AccumulatorBuffer(),\n      srp: new SRP(config.account, config.password),\n      phase: \"challenge\",\n      config,\n    };\n    let done = false;\n\n    Bun.connect({\n      hostname: config.host,\n      port: config.port,\n      socket: {\n        open(socket) {\n          socket.write(buildLogonChallenge(config.account));\n        },\n        data(socket, data) {\n          ctx.buf.append(new Uint8Array(data));\n          try {\n            const result = advanceAuth(ctx, socket);\n            if (result) {\n              done = true;\n              socket.end();\n              resolve(result);\n            }\n          } catch (err) {\n            if (err instanceof RangeError) return;\n            done = true;\n            reject(err);\n            socket.end();\n          }\n        },\n        close() {\n          if (!done) reject(new Error(\"Auth connection closed\"));\n        },\n      },\n    }).catch(reject);\n  });\n}\n\nfunction sendPacket(\n  conn: WorldConn,\n  opcode: number,\n  body: Uint8Array = new Uint8Array(0),\n): void {\n  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n}\n\nfunction drainWorldPackets(conn: WorldConn): void {\n  while (true) {\n    if (!conn.pendingHeader) {\n      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n      conn.pendingHeader = decryptIncomingHeader(\n        conn.buf.drain(INCOMING_HEADER_SIZE),\n        conn.arc4,\n      );\n    }\n    const bodySize = conn.pendingHeader.size - 2;\n    if (conn.buf.length < bodySize) break;\n\n    const { opcode } = conn.pendingHeader;\n    conn.pendingHeader = undefined;\n    try {\n      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n    } catch (err) {\n      if (err instanceof Error) {\n        conn.onPacketError?.(opcode, err);\n      }\n    }\n  }\n}\n\nfunction handleTimeSync(conn: WorldConn, r: PacketReader): void {\n  const counter = r.uint32LE();\n  const elapsed = Date.now() - conn.startTime;\n  const w = new PacketWriter();\n  w.uint32LE(counter);\n  w.uint32LE(elapsed);\n  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,\n    sender: name,\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n  if (pending) {\n    pending.push(raw);\n  } else {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  }\n}\n\nfunction handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r, true);\n  deliverMessage(conn, raw, raw.senderName ?? \"\");\n}\n\nfunction handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseNameQueryResponse(r);\n\n  const name = result.found && result.name ? result.name : \"\";\n  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n  if (result.found && result.name) {\n    conn.nameCache.set(result.guidLow, result.name);\n    for (const entity of conn.entityStore.all()) {\n      if (\n        entity.objectType === ObjectType.PLAYER &&\n        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n        !entity.name\n      ) {\n        conn.entityStore.setName(entity.guid, result.name);\n      }\n    }\n    for (const friend of conn.friendStore.all()) {\n      if (\n        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n        !friend.name\n      ) {\n        conn.friendStore.setName(friend.guid, result.name);\n      }\n    }\n  }\n\n  const pending = conn.pendingMessages.get(result.guidLow);\n  if (!pending) return;\n  for (const raw of pending) deliverMessage(conn, raw, name);\n  conn.pendingMessages.delete(result.guidLow);\n}\n\nfunction handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n  const event = parseChannelNotify(r);\n  if (event.type === \"joined\") {\n    conn.channels.push(event.channel);\n  } else if (event.type === \"left\") {\n    const idx = conn.channels.indexOf(event.channel);\n    if (idx !== -1) conn.channels.splice(idx, 1);\n  }\n}\n\nfunction handleMotd(conn: WorldConn, r: PacketReader): void {\n  const lineCount = r.uint32LE();\n  const lines: string[] = [];\n  for (let i = 0; i < lineCount; i++) {\n    lines.push(r.cString());\n  }\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: lines.join(\"\\n\"),\n  });\n}\n\nfunction handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n  const name = r.cString();\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: `No player named \"${name}\" is currently playing.`,\n  });\n}\n\nfunction handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n  const result = parsePartyCommandResult(r);\n  conn.onGroupEvent?.({\n    type: \"command_result\",\n    operation: result.operation,\n    target: result.member,\n    result: result.result,\n  });\n}\n\nfunction handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n  const invite = parseGroupInvite(r);\n  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n}\n\nfunction handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupSetLeader(r);\n  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n}\n\nfunction handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n  const list = parseGroupList(r);\n  conn.partyMembers.clear();\n  let leaderName = \"\";\n  if (\n    conn.selfGuidLow === list.leaderGuidLow &&\n    conn.selfGuidHigh === list.leaderGuidHigh\n  ) {\n    leaderName = conn.selfName;\n  }\n  for (const m of list.members) {\n    conn.partyMembers.set(m.name, {\n      guidLow: m.guidLow,\n      guidHigh: m.guidHigh,\n    });\n    if (\n      m.guidLow === list.leaderGuidLow &&\n      m.guidHigh === list.leaderGuidHigh\n    ) {\n      leaderName = m.name;\n    }\n  }\n  conn.onGroupEvent?.({\n    type: \"group_list\",\n    members: list.members,\n    leader: leaderName,\n  });\n}\n\nfunction handleGroupDestroyed(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n}\n\nfunction handleGroupUninvite(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"kicked\" });\n}\n\nfunction handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupDecline(r);\n  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n}\n\nfunction handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const entries = parseUpdateObject(r);\n  for (const entry of entries) {\n    switch (entry.type) {\n      case \"create\": {\n        const { _changed: _co, ...objFields } = extractObjectFields(\n          entry.fields,\n        );\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entry.objectType === ObjectType.UNIT ||\n          entry.objectType === ObjectType.PLAYER\n        ) {\n          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n          extraFields = rest;\n        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n          const { _changed: _cg, ...rest } = extractGameObjectFields(\n            entry.fields,\n          );\n          extraFields = rest;\n        }\n        const cachedName = lookupCachedName(\n          conn,\n          entry.guid,\n          entry.objectType,\n          objFields.entry,\n        );\n        conn.entityStore.create(entry.guid, entry.objectType, {\n          ...objFields,\n          ...extraFields,\n          ...(cachedName ? { name: cachedName } : {}),\n          ...(entry.position ? { position: entry.position } : {}),\n          rawFields: new Map(entry.fields),\n        } as any);\n        if (!cachedName) {\n          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n        }\n        break;\n      }\n      case \"values\": {\n        const entity = conn.entityStore.get(entry.guid);\n        if (!entity) break;\n        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entity.objectType === ObjectType.UNIT ||\n          entity.objectType === ObjectType.PLAYER\n        ) {\n          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n          extraFields = extractGameObjectFields(entry.fields);\n        }\n        const allChanged = [\n          ...(objFields._changed || []),\n          ...((extraFields as any)._changed || []),\n        ];\n        const merged: Record<string, unknown> = {};\n        for (const key of allChanged) {\n          if (key in extraFields) merged[key] = (extraFields as any)[key];\n          else if (key in objFields) merged[key] = (objFields as any)[key];\n        }\n        conn.entityStore.update(entry.guid, merged);\n        for (const [k, v] of entry.fields) {\n          const existing = conn.entityStore.get(entry.guid);\n          if (existing) existing.rawFields.set(k, v);\n        }\n        break;\n      }\n      case \"movement\": {\n        conn.entityStore.setPosition(entry.guid, entry.position);\n        break;\n      }\n      case \"outOfRange\": {\n        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n        break;\n      }\n      case \"nearObjects\": {\n        break;\n      }\n    }\n  }\n}\n\nfunction handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const uncompressedSize = r.uint32LE();\n  const compressed = r.bytes(r.remaining);\n  const decompressed = inflateSync(compressed);\n  if (decompressed.length !== uncompressedSize) {\n    throw new Error(\n      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n    );\n  }\n  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n}\n\nfunction handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n  const guid = r.uint64LE();\n  r.skip(1);\n  conn.entityStore.destroy(guid);\n}\n\nfunction lookupCachedName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): string | undefined {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    return conn.nameCache.get(guidLow);\n  }\n  if (entry === undefined) return undefined;\n  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n  if (objectType === ObjectType.GAMEOBJECT)\n    return conn.gameObjectNameCache.get(entry);\n  return undefined;\n}\n\nfunction queryEntityName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): void {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    const key = `player:${guidLow}`;\n    if (conn.pendingNameQueries.has(key)) return;\n    conn.pendingNameQueries.add(key);\n    const w = new PacketWriter();\n    w.uint64LE(guid);\n    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n    return;\n  }\n  if (entry === undefined) return;\n  const key = `${objectType}:${entry}`;\n  if (conn.pendingNameQueries.has(key)) return;\n  conn.pendingNameQueries.add(key);\n  if (objectType === ObjectType.UNIT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_CREATURE_QUERY,\n      buildCreatureQuery(entry, guid),\n    );\n    return;\n  }\n  if (objectType === ObjectType.GAMEOBJECT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n      buildGameObjectQuery(entry, guid),\n    );\n    return;\n  }\n}\n\nfunction handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseCreatureQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n  if (!result.name) return;\n  conn.creatureNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry && !entity.name) {\n      conn.entityStore.setName(entity.guid, result.name);\n    }\n  }\n}\n\nfunction handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseGameObjectQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n  if (!result.name) return;\n  conn.gameObjectNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry) {\n      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n      if (result.gameObjectType !== undefined) {\n        conn.entityStore.update(entity.guid, {\n          gameObjectType: result.gameObjectType,\n        });\n      }\n    }\n  }\n}\n\nfunction handlePartyMemberStatsMsg(\n  conn: WorldConn,\n  r: PacketReader,\n  isFull = false,\n): void {\n  const stats = parsePartyMemberStats(r, isFull);\n  conn.onGroupEvent?.({\n    type: \"member_stats\",\n    guidLow: stats.guidLow,\n    online: stats.online,\n    hp: stats.hp,\n    maxHp: stats.maxHp,\n    level: stats.level,\n  });\n}\n\nfunction handleContactList(conn: WorldConn, r: PacketReader): void {\n  const list = parseContactList(r);\n  const friends: FriendEntry[] = [];\n  for (const contact of list.contacts) {\n    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n    const guidLow = Number(contact.guid & 0xffffffffn);\n    const name = conn.nameCache.get(guidLow) ?? \"\";\n    friends.push({\n      guid: contact.guid,\n      name,\n      note: contact.note,\n      status: contact.status ?? 0,\n      area: contact.area ?? 0,\n      level: contact.level ?? 0,\n      playerClass: contact.playerClass ?? 0,\n    });\n    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n      conn.pendingNameQueries.add(`player:${guidLow}`);\n      sendPacket(\n        conn,\n        GameOpcode.CMSG_NAME_QUERY,\n        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n      );\n    }\n  }\n  conn.friendStore.set(friends);\n}\n\nfunction handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n  const packet = parseFriendStatus(r);\n  const guidLow = Number(packet.guid & 0xffffffffn);\n\n  switch (packet.result) {\n    case FriendResult.ADDED_ONLINE:\n    case FriendResult.ADDED_OFFLINE: {\n      const name = conn.nameCache.get(guidLow) ?? \"\";\n      conn.friendStore.add({\n        guid: packet.guid,\n        name,\n        note: packet.note ?? \"\",\n        status: packet.status ?? 0,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n        conn.pendingNameQueries.add(`player:${guidLow}`);\n        sendPacket(\n          conn,\n          GameOpcode.CMSG_NAME_QUERY,\n          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n        );\n      }\n      break;\n    }\n    case FriendResult.ONLINE:\n      conn.friendStore.update(packet.guid, {\n        status: packet.status ?? FriendStatus.ONLINE,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      break;\n    case FriendResult.OFFLINE:\n      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n      break;\n    case FriendResult.REMOVED:\n      conn.friendStore.remove(packet.guid);\n      break;\n    default: {\n      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n      conn.onFriendEvent?.({\n        type: \"friend-error\",\n        result: packet.result,\n        name,\n      });\n      break;\n    }\n  }\n}\n\nasync function authenticateWorld(\n  conn: WorldConn,\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<void> {\n  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n  challenge.uint32LE();\n  const serverSeed = challenge.bytes(4);\n\n  const body = await buildWorldAuthPacket(\n    config.account,\n    auth.sessionKey,\n    serverSeed,\n    auth.realmId,\n    config.clientSeed,\n  );\n  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n  conn.arc4 = new Arc4(auth.sessionKey);\n\n  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n  const status = resp.uint8();\n  if (status !== 0x0c) {\n    const names: Record<number, string> = {\n      0x0d: \"system error\",\n      0x15: \"account in use\",\n    };\n    const label = names[status] ?? `status 0x${status.toString(16)}`;\n    throw new Error(`World auth failed: ${label}`);\n  }\n}\n\nasync function selectCharacter(\n  conn: WorldConn,\n  config: ClientConfig,\n): Promise<void> {\n  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n\n  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n  const chars = parseCharacterList(enumReader);\n  const char = chars.find(\n    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n  );\n  if (!char) {\n    throw new Error(\n      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n    );\n  }\n\n  conn.selfName = char.name;\n  conn.selfGuidLow = char.guidLow;\n  conn.selfGuidHigh = char.guidHigh;\n\n  const w = new PacketWriter();\n  w.uint32LE(char.guidLow);\n  w.uint32LE(char.guidHigh);\n  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n\n  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n}\n\nfunction startPingLoop(\n  conn: WorldConn,\n  intervalMs: number,\n): ReturnType<typeof setInterval> {\n  return setInterval(() => {\n    const w = new PacketWriter();\n    w.uint32LE(0);\n    w.uint32LE(0);\n    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n  }, intervalMs);\n}\n\nexport function worldSession(\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<WorldHandle> {\n  return new Promise((resolve, reject) => {\n    const conn: WorldConn = {\n      socket: undefined!,\n      dispatch: new OpcodeDispatch(),\n      buf: new AccumulatorBuffer(),\n      startTime: Date.now(),\n      nameCache: new Map(),\n      pendingMessages: new Map(),\n      channels: [],\n      lastChatMode: { type: \"say\" },\n      selfName: \"\",\n      selfGuidLow: 0,\n      selfGuidHigh: 0,\n      partyMembers: new Map(),\n      entityStore: new EntityStore(),\n      creatureNameCache: new Map(),\n      gameObjectNameCache: new Map(),\n      pendingNameQueries: new Set(),\n      friendStore: new FriendStore(),\n    };\n    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n\n    let pingInterval: ReturnType<typeof setInterval>;\n    let done = false;\n    let closedResolve: () => void;\n    const closed = new Promise<void>((r) => {\n      closedResolve = r;\n    });\n\n    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n      handleTimeSync(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n      handleChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n      handleGmChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n      handleNameQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n      handlePlayerNotFound(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n      handleChannelNotify(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n      handlePartyCommandResult(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n      handleGroupInviteReceived(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n      handleGroupSetLeaderMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n      handleGroupListMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n      handleGroupDestroyed(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n      handleGroupUninvite(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n      handleGroupDeclineMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n      handlePartyMemberStatsMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n      handlePartyMemberStatsMsg(conn, r, true),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n      handleUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n      handleCompressedUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n      handleDestroyObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n      handleCreatureQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n      handleGameObjectQueryResponse(conn, r),\n    );\n\n    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n      handleContactList(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n      handleFriendStatus(conn, r),\n    );\n\n    registerStubs(conn.dispatch, (msg) => {\n      if (!conn.onMessage) return false;\n      conn.onMessage({\n        type: ChatType.SYSTEM,\n        sender: \"\",\n        message: msg,\n      });\n      return true;\n    });\n\n    async function login() {\n      await authenticateWorld(conn, config, auth);\n      await selectCharacter(conn, config);\n      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n      const lang = config.language ?? Language.COMMON;\n      done = true;\n      const handle: WorldHandle = {\n        closed,\n        close() {\n          clearInterval(pingInterval);\n          conn.onEntityEvent = undefined;\n          conn.onFriendEvent = undefined;\n          conn.socket.end();\n        },\n        onMessage(cb) {\n          conn.onMessage = cb;\n        },\n        sendWhisper(target, message) {\n          if (target) conn.lastChatMode = { type: \"whisper\", target };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.WHISPER, lang, message, target),\n          );\n        },\n        sendSay(message) {\n          conn.lastChatMode = { type: \"say\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.SAY, lang, message),\n          );\n        },\n        sendYell(message) {\n          conn.lastChatMode = { type: \"yell\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.YELL, lang, message),\n          );\n        },\n        sendGuild(message) {\n          conn.lastChatMode = { type: \"guild\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.GUILD, lang, message),\n          );\n        },\n        sendParty(message) {\n          conn.lastChatMode = { type: \"party\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.PARTY, lang, message),\n          );\n        },\n        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {\n          conn.lastChatMode = { type: \"channel\", channel };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n          );\n        },\n        getChannel(index) {\n          return conn.channels[index - 1];\n        },\n        async who(opts = {}) {\n          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n          return parseWhoResponse(r);\n        },\n        getLastChatMode() {\n          return conn.lastChatMode;\n        },\n        setLastChatMode(mode) {\n          conn.lastChatMode = mode;\n        },\n        sendInCurrentMode(message) {\n          const mode = conn.lastChatMode;\n          switch (mode.type) {\n            case \"say\":\n              handle.sendSay(message);\n              break;\n            case \"yell\":\n              handle.sendYell(message);\n              break;\n            case \"guild\":\n              handle.sendGuild(message);\n              break;\n            case \"party\":\n              handle.sendParty(message);\n              break;\n            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":\n              handle.sendWhisper(mode.target, message);\n              break;\n            case \"channel\":\n              handle.sendChannel(mode.channel, message);\n              break;\n          }\n        },\n        invite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_INVITE,\n            buildGroupInvite(name),\n          );\n        },\n        uninvite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_UNINVITE,\n            buildGroupUninvite(name),\n          );\n        },\n        leaveGroup() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n        },\n        setLeader(name) {\n          const member = conn.partyMembers.get(name);\n          if (!member) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not in your party.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_SET_LEADER,\n            buildGroupSetLeader(member.guidLow, member.guidHigh),\n          );\n        },\n        acceptInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n        },\n        declineInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n        },\n        onGroupEvent(cb) {\n          conn.onGroupEvent = cb;\n        },\n        onEntityEvent(cb) {\n          conn.onEntityEvent = cb;\n        },\n        onPacketError(cb) {\n          conn.onPacketError = cb;\n        },\n        getNearbyEntities() {\n          return conn.entityStore.all();\n        },\n        getFriends() {\n          return conn.friendStore.all();\n        },\n        addFriend(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_ADD_FRIEND,\n            buildAddFriend(name, \"\"),\n          );\n        },\n        removeFriend(name) {\n          const friend = conn.friendStore.findByName(name);\n          if (!friend) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not on your friends list.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_DEL_FRIEND,\n            buildDelFriend(friend.guid),\n          );\n        },\n        onFriendEvent(cb) {\n          conn.onFriendEvent = cb;\n        },\n      };\n      resolve(handle);\n    }\n\n    login().catch((err) => {\n      done = true;\n      clearInterval(pingInterval);\n      reject(err);\n      conn.socket?.end();\n    });\n\n    Bun.connect({\n      hostname: auth.realmHost,\n      port: auth.realmPort,\n      socket: {\n        open(s) {\n          conn.socket = s;\n        },\n        data(_s, data) {\n          conn.buf.append(new Uint8Array(data));\n          drainWorldPackets(conn);\n        },\n        close() {\n          clearInterval(pingInterval);\n          conn.entityStore.clear();\n          if (!done) reject(new Error(\"World connection closed\"));\n          closedResolve();\n        },\n      },\n    }).catch(reject);\n  });\n}\n","structuredPatch":[{"oldStart":151,"oldLines":6,"newStart":151,"newLines":7,"lines":["   | { type: \"guild\" }","   | { type: \"party\" }","   | { type: \"raid\" }","+  | { type: \"emote\" }","   | { type: \"whisper\"; target: string }","   | { type: \"channel\"; channel: string };"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"598498bf-fbb8-448e-8e99-b2f9defaceba"}
{"parentUuid":"bcab0695-ebb5-4fd4-991d-411a77345831","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UpEKp3bsr7SxppLgZoaNKu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018DCM5mtXykeXus3YikoBYH","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.ts","old_string":"  sendRaid(message: string): void;\n  sendChannel(channel: string, message: string): void;","new_string":"  sendRaid(message: string): void;\n  sendEmote(message: string): void;\n  sendChannel(channel: string, message: string): void;"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":73924,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMSJF4jhZe1nQFsY11M","type":"assistant","uuid":"69a0ea24-996d-4d04-8972-dca48ca8612d","timestamp":"2026-02-28T23:42:29.612Z"}
{"parentUuid":"69a0ea24-996d-4d04-8972-dca48ca8612d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018DCM5mtXykeXus3YikoBYH","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.ts has been updated successfully."}]},"uuid":"b5752f8b-b23d-4048-b373-8268bf290920","timestamp":"2026-02-28T23:42:29.630Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.ts","oldString":"  sendRaid(message: string): void;\n  sendChannel(channel: string, message: string): void;","newString":"  sendRaid(message: string): void;\n  sendEmote(message: string): void;\n  sendChannel(channel: string, message: string): void;","originalFile":"import type { Socket } from \"bun\";\nimport { inflateSync } from \"node:zlib\";\nimport { PacketReader, PacketWriter } from \"wow/protocol/packet\";\nimport { SRP, type SRPResult } from \"wow/crypto/srp\";\nimport { Arc4 } from \"wow/crypto/arc4\";\nimport {\n  GameOpcode,\n  ChatType,\n  Language,\n  AuthOpcode,\n} from \"wow/protocol/opcodes\";\nimport {\n  parseChatMessage,\n  buildChatMessage,\n  buildNameQuery,\n  parseNameQueryResponse,\n  parseChannelNotify,\n  buildWhoRequest,\n  parseWhoResponse,\n  type ChatMessage as RawChatMessage,\n  type WhoResult,\n} from \"wow/protocol/chat\";\nimport {\n  buildLogonChallenge,\n  parseLogonChallengeResponse,\n  buildLogonProof,\n  parseLogonProofResponse,\n  buildRealmListRequest,\n  parseRealmList,\n  parseReconnectChallengeResponse,\n  buildReconnectProof,\n} from \"wow/protocol/auth\";\nimport {\n  buildWorldAuthPacket,\n  parseCharacterList,\n  OpcodeDispatch,\n  AccumulatorBuffer,\n  INCOMING_HEADER_SIZE,\n  buildOutgoingPacket,\n  decryptIncomingHeader,\n} from \"wow/protocol/world\";\nimport {\n  buildGroupInvite,\n  buildGroupAccept,\n  buildGroupDecline,\n  buildGroupUninvite,\n  buildGroupDisband,\n  buildGroupSetLeader,\n  parsePartyCommandResult,\n  parseGroupInvite,\n  parseGroupSetLeader,\n  parseGroupDecline,\n  parseGroupList,\n  parsePartyMemberStats,\n} from \"wow/protocol/group\";\nimport { registerStubs } from \"wow/protocol/stubs\";\nimport { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\nimport {\n  FriendStore,\n  type FriendEntry,\n  type FriendEvent,\n} from \"wow/friend-store\";\nimport {\n  parseContactList,\n  parseFriendStatus,\n  buildAddFriend,\n  buildDelFriend,\n  SocialFlag,\n  FriendStatus,\n  FriendResult,\n} from \"wow/protocol/social\";\nimport { parseUpdateObject } from \"wow/protocol/update-object\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport {\n  extractObjectFields,\n  extractUnitFields,\n  extractGameObjectFields,\n} from \"wow/protocol/extract-fields\";\nimport {\n  buildCreatureQuery,\n  parseCreatureQueryResponse,\n  buildGameObjectQuery,\n  parseGameObjectQueryResponse,\n} from \"wow/protocol/entity-queries\";\n\nexport type ClientConfig = {\n  host: string;\n  port: number;\n  account: string;\n  password: string;\n  character: string;\n  srpPrivateKey?: bigint;\n  clientSeed?: Uint8Array;\n  pingIntervalMs?: number;\n  language?: number;\n  cachedSessionKey?: Uint8Array;\n};\n\nexport type AuthResult = {\n  sessionKey: Uint8Array;\n  realmHost: string;\n  realmPort: number;\n  realmId: number;\n};\n\nexport type ChatMessage = {\n  type: number;\n  sender: string;\n  message: string;\n  channel?: string;\n};\n\nexport type GroupEvent =\n  | { type: \"invite_received\"; from: string }\n  | {\n      type: \"command_result\";\n      operation: number;\n      target: string;\n      result: number;\n    }\n  | { type: \"leader_changed\"; name: string }\n  | {\n      type: \"group_list\";\n      members: Array<{\n        name: string;\n        guidLow: number;\n        guidHigh: number;\n        online: boolean;\n      }>;\n      leader: string;\n    }\n  | { type: \"group_destroyed\" }\n  | { type: \"kicked\" }\n  | { type: \"invite_declined\"; name: string }\n  | {\n      type: \"member_stats\";\n      guidLow: number;\n      online?: boolean;\n      hp?: number;\n      maxHp?: number;\n      level?: number;\n    };\n\nexport type { WhoResult };\nexport type { Entity, EntityEvent };\nexport type { FriendEntry, FriendEvent };\n\nexport type ChatMode =\n  | { type: \"say\" }\n  | { type: \"yell\" }\n  | { type: \"guild\" }\n  | { type: \"party\" }\n  | { type: \"raid\" }\n  | { type: \"emote\" }\n  | { type: \"whisper\"; target: string }\n  | { type: \"channel\"; channel: string };\n\nexport type WorldHandle = {\n  closed: Promise<void>;\n  close(): void;\n  onMessage(cb: (msg: ChatMessage) => void): void;\n  sendWhisper(target: string, message: string): void;\n  sendSay(message: string): void;\n  sendYell(message: string): void;\n  sendGuild(message: string): void;\n  sendParty(message: string): void;\n  sendRaid(message: string): void;\n  sendChannel(channel: string, message: string): void;\n  getChannel(index: number): string | undefined;\n  who(opts?: {\n    name?: string;\n    minLevel?: number;\n    maxLevel?: number;\n  }): Promise<WhoResult[]>;\n  getLastChatMode(): ChatMode;\n  setLastChatMode(mode: ChatMode): void;\n  sendInCurrentMode(message: string): void;\n  invite(name: string): void;\n  uninvite(name: string): void;\n  leaveGroup(): void;\n  setLeader(name: string): void;\n  acceptInvite(): void;\n  declineInvite(): void;\n  onGroupEvent(cb: (event: GroupEvent) => void): void;\n  onEntityEvent(cb: (event: EntityEvent) => void): void;\n  onPacketError(cb: (opcode: number, err: Error) => void): void;\n  getNearbyEntities(): Entity[];\n  getFriends(): FriendEntry[];\n  addFriend(name: string): void;\n  removeFriend(name: string): void;\n  onFriendEvent(cb: (event: FriendEvent) => void): void;\n};\n\ntype WorldConn = {\n  socket: Socket;\n  dispatch: OpcodeDispatch;\n  buf: AccumulatorBuffer;\n  arc4?: Arc4;\n  startTime: number;\n  pendingHeader?: { size: number; opcode: number };\n  nameCache: Map<number, string>;\n  pendingMessages: Map<number, RawChatMessage[]>;\n  channels: string[];\n  lastChatMode: ChatMode;\n  onMessage?: (msg: ChatMessage) => void;\n  selfName: string;\n  selfGuidLow: number;\n  selfGuidHigh: number;\n  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n  onGroupEvent?: (event: GroupEvent) => void;\n  entityStore: EntityStore;\n  creatureNameCache: Map<number, string>;\n  gameObjectNameCache: Map<number, string>;\n  onEntityEvent?: (event: EntityEvent) => void;\n  onPacketError?: (opcode: number, err: Error) => void;\n  pendingNameQueries: Set<string>;\n  friendStore: FriendStore;\n  onFriendEvent?: (event: FriendEvent) => void;\n};\n\nfunction handleChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n  srp: SRP,\n): SRPResult {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return srp.calculate(\n    result.g!,\n    result.N!,\n    result.salt!,\n    result.B!,\n    config.srpPrivateKey,\n  );\n}\n\nfunction handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonProofResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth proof failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n}\n\nfunction handleRealms(\n  raw: Uint8Array,\n): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n  const realms = parseRealmList(new PacketReader(raw, 1));\n  if (realms.length === 0) throw new Error(\"No realms available\");\n  const realm = realms[0]!;\n  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n}\n\nexport class ReconnectRequiredError extends Error {\n  constructor() {\n    super(\"Server requires reconnect but no cached session key is available\");\n    this.name = \"ReconnectRequiredError\";\n  }\n}\n\nfunction handleReconnectChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n): Uint8Array {\n  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n  const r = new PacketReader(raw);\n  const result = parseReconnectChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return buildReconnectProof(\n    config.account,\n    result.challengeData!,\n    config.cachedSessionKey,\n  );\n}\n\nfunction handleReconnectProof(raw: Uint8Array): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const status = r.uint8();\n  if (status !== 0x00) {\n    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n  }\n}\n\nexport async function authWithRetry(\n  config: ClientConfig,\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\n): Promise<AuthResult> {\n  const maxAttempts = opts?.maxAttempts ?? 5;\n  const baseDelay = opts?.baseDelayMs ?? 5000;\n  let lastError: unknown;\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await authHandshake(config);\n    } catch (err) {\n      if (!(err instanceof ReconnectRequiredError)) throw err;\n      lastError = err;\n      if (attempt + 1 < maxAttempts) {\n        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n        await Bun.sleep(delay);\n      }\n    }\n  }\n  throw lastError;\n}\n\ntype AuthContext = {\n  buf: AccumulatorBuffer;\n  srp: SRP;\n  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n  config: ClientConfig;\n  srpResult?: SRPResult;\n  sessionKey?: Uint8Array;\n};\n\nfunction advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n  const raw = ctx.buf.peek(ctx.buf.length);\n  let result: AuthResult | undefined;\n\n  if (ctx.phase === \"challenge\") {\n    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n      socket.write(handleReconnectChallenge(raw, ctx.config));\n      ctx.sessionKey = ctx.config.cachedSessionKey!;\n      ctx.phase = \"reconnect_proof\";\n    } else {\n      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n      ctx.sessionKey = ctx.srpResult.K;\n      socket.write(buildLogonProof(ctx.srpResult));\n      ctx.phase = \"proof\";\n    }\n  } else if (ctx.phase === \"proof\") {\n    handleProof(raw, ctx.srpResult!);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else if (ctx.phase === \"reconnect_proof\") {\n    handleReconnectProof(raw);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else {\n    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n  }\n\n  ctx.buf.drain(ctx.buf.length);\n  return result;\n}\n\nexport function authHandshake(config: ClientConfig): Promise<AuthResult> {\n  return new Promise((resolve, reject) => {\n    const ctx: AuthContext = {\n      buf: new AccumulatorBuffer(),\n      srp: new SRP(config.account, config.password),\n      phase: \"challenge\",\n      config,\n    };\n    let done = false;\n\n    Bun.connect({\n      hostname: config.host,\n      port: config.port,\n      socket: {\n        open(socket) {\n          socket.write(buildLogonChallenge(config.account));\n        },\n        data(socket, data) {\n          ctx.buf.append(new Uint8Array(data));\n          try {\n            const result = advanceAuth(ctx, socket);\n            if (result) {\n              done = true;\n              socket.end();\n              resolve(result);\n            }\n          } catch (err) {\n            if (err instanceof RangeError) return;\n            done = true;\n            reject(err);\n            socket.end();\n          }\n        },\n        close() {\n          if (!done) reject(new Error(\"Auth connection closed\"));\n        },\n      },\n    }).catch(reject);\n  });\n}\n\nfunction sendPacket(\n  conn: WorldConn,\n  opcode: number,\n  body: Uint8Array = new Uint8Array(0),\n): void {\n  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n}\n\nfunction drainWorldPackets(conn: WorldConn): void {\n  while (true) {\n    if (!conn.pendingHeader) {\n      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n      conn.pendingHeader = decryptIncomingHeader(\n        conn.buf.drain(INCOMING_HEADER_SIZE),\n        conn.arc4,\n      );\n    }\n    const bodySize = conn.pendingHeader.size - 2;\n    if (conn.buf.length < bodySize) break;\n\n    const { opcode } = conn.pendingHeader;\n    conn.pendingHeader = undefined;\n    try {\n      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n    } catch (err) {\n      if (err instanceof Error) {\n        conn.onPacketError?.(opcode, err);\n      }\n    }\n  }\n}\n\nfunction handleTimeSync(conn: WorldConn, r: PacketReader): void {\n  const counter = r.uint32LE();\n  const elapsed = Date.now() - conn.startTime;\n  const w = new PacketWriter();\n  w.uint32LE(counter);\n  w.uint32LE(elapsed);\n  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,\n    sender: name,\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n  if (pending) {\n    pending.push(raw);\n  } else {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  }\n}\n\nfunction handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r, true);\n  deliverMessage(conn, raw, raw.senderName ?? \"\");\n}\n\nfunction handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseNameQueryResponse(r);\n\n  const name = result.found && result.name ? result.name : \"\";\n  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n  if (result.found && result.name) {\n    conn.nameCache.set(result.guidLow, result.name);\n    for (const entity of conn.entityStore.all()) {\n      if (\n        entity.objectType === ObjectType.PLAYER &&\n        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n        !entity.name\n      ) {\n        conn.entityStore.setName(entity.guid, result.name);\n      }\n    }\n    for (const friend of conn.friendStore.all()) {\n      if (\n        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n        !friend.name\n      ) {\n        conn.friendStore.setName(friend.guid, result.name);\n      }\n    }\n  }\n\n  const pending = conn.pendingMessages.get(result.guidLow);\n  if (!pending) return;\n  for (const raw of pending) deliverMessage(conn, raw, name);\n  conn.pendingMessages.delete(result.guidLow);\n}\n\nfunction handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n  const event = parseChannelNotify(r);\n  if (event.type === \"joined\") {\n    conn.channels.push(event.channel);\n  } else if (event.type === \"left\") {\n    const idx = conn.channels.indexOf(event.channel);\n    if (idx !== -1) conn.channels.splice(idx, 1);\n  }\n}\n\nfunction handleMotd(conn: WorldConn, r: PacketReader): void {\n  const lineCount = r.uint32LE();\n  const lines: string[] = [];\n  for (let i = 0; i < lineCount; i++) {\n    lines.push(r.cString());\n  }\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: lines.join(\"\\n\"),\n  });\n}\n\nfunction handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n  const name = r.cString();\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: `No player named \"${name}\" is currently playing.`,\n  });\n}\n\nfunction handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n  const result = parsePartyCommandResult(r);\n  conn.onGroupEvent?.({\n    type: \"command_result\",\n    operation: result.operation,\n    target: result.member,\n    result: result.result,\n  });\n}\n\nfunction handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n  const invite = parseGroupInvite(r);\n  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n}\n\nfunction handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupSetLeader(r);\n  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n}\n\nfunction handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n  const list = parseGroupList(r);\n  conn.partyMembers.clear();\n  let leaderName = \"\";\n  if (\n    conn.selfGuidLow === list.leaderGuidLow &&\n    conn.selfGuidHigh === list.leaderGuidHigh\n  ) {\n    leaderName = conn.selfName;\n  }\n  for (const m of list.members) {\n    conn.partyMembers.set(m.name, {\n      guidLow: m.guidLow,\n      guidHigh: m.guidHigh,\n    });\n    if (\n      m.guidLow === list.leaderGuidLow &&\n      m.guidHigh === list.leaderGuidHigh\n    ) {\n      leaderName = m.name;\n    }\n  }\n  conn.onGroupEvent?.({\n    type: \"group_list\",\n    members: list.members,\n    leader: leaderName,\n  });\n}\n\nfunction handleGroupDestroyed(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n}\n\nfunction handleGroupUninvite(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"kicked\" });\n}\n\nfunction handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupDecline(r);\n  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n}\n\nfunction handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const entries = parseUpdateObject(r);\n  for (const entry of entries) {\n    switch (entry.type) {\n      case \"create\": {\n        const { _changed: _co, ...objFields } = extractObjectFields(\n          entry.fields,\n        );\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entry.objectType === ObjectType.UNIT ||\n          entry.objectType === ObjectType.PLAYER\n        ) {\n          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n          extraFields = rest;\n        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n          const { _changed: _cg, ...rest } = extractGameObjectFields(\n            entry.fields,\n          );\n          extraFields = rest;\n        }\n        const cachedName = lookupCachedName(\n          conn,\n          entry.guid,\n          entry.objectType,\n          objFields.entry,\n        );\n        conn.entityStore.create(entry.guid, entry.objectType, {\n          ...objFields,\n          ...extraFields,\n          ...(cachedName ? { name: cachedName } : {}),\n          ...(entry.position ? { position: entry.position } : {}),\n          rawFields: new Map(entry.fields),\n        } as any);\n        if (!cachedName) {\n          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n        }\n        break;\n      }\n      case \"values\": {\n        const entity = conn.entityStore.get(entry.guid);\n        if (!entity) break;\n        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entity.objectType === ObjectType.UNIT ||\n          entity.objectType === ObjectType.PLAYER\n        ) {\n          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n          extraFields = extractGameObjectFields(entry.fields);\n        }\n        const allChanged = [\n          ...(objFields._changed || []),\n          ...((extraFields as any)._changed || []),\n        ];\n        const merged: Record<string, unknown> = {};\n        for (const key of allChanged) {\n          if (key in extraFields) merged[key] = (extraFields as any)[key];\n          else if (key in objFields) merged[key] = (objFields as any)[key];\n        }\n        conn.entityStore.update(entry.guid, merged);\n        for (const [k, v] of entry.fields) {\n          const existing = conn.entityStore.get(entry.guid);\n          if (existing) existing.rawFields.set(k, v);\n        }\n        break;\n      }\n      case \"movement\": {\n        conn.entityStore.setPosition(entry.guid, entry.position);\n        break;\n      }\n      case \"outOfRange\": {\n        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n        break;\n      }\n      case \"nearObjects\": {\n        break;\n      }\n    }\n  }\n}\n\nfunction handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const uncompressedSize = r.uint32LE();\n  const compressed = r.bytes(r.remaining);\n  const decompressed = inflateSync(compressed);\n  if (decompressed.length !== uncompressedSize) {\n    throw new Error(\n      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n    );\n  }\n  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n}\n\nfunction handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n  const guid = r.uint64LE();\n  r.skip(1);\n  conn.entityStore.destroy(guid);\n}\n\nfunction lookupCachedName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): string | undefined {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    return conn.nameCache.get(guidLow);\n  }\n  if (entry === undefined) return undefined;\n  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n  if (objectType === ObjectType.GAMEOBJECT)\n    return conn.gameObjectNameCache.get(entry);\n  return undefined;\n}\n\nfunction queryEntityName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): void {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    const key = `player:${guidLow}`;\n    if (conn.pendingNameQueries.has(key)) return;\n    conn.pendingNameQueries.add(key);\n    const w = new PacketWriter();\n    w.uint64LE(guid);\n    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n    return;\n  }\n  if (entry === undefined) return;\n  const key = `${objectType}:${entry}`;\n  if (conn.pendingNameQueries.has(key)) return;\n  conn.pendingNameQueries.add(key);\n  if (objectType === ObjectType.UNIT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_CREATURE_QUERY,\n      buildCreatureQuery(entry, guid),\n    );\n    return;\n  }\n  if (objectType === ObjectType.GAMEOBJECT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n      buildGameObjectQuery(entry, guid),\n    );\n    return;\n  }\n}\n\nfunction handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseCreatureQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n  if (!result.name) return;\n  conn.creatureNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry && !entity.name) {\n      conn.entityStore.setName(entity.guid, result.name);\n    }\n  }\n}\n\nfunction handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseGameObjectQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n  if (!result.name) return;\n  conn.gameObjectNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry) {\n      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n      if (result.gameObjectType !== undefined) {\n        conn.entityStore.update(entity.guid, {\n          gameObjectType: result.gameObjectType,\n        });\n      }\n    }\n  }\n}\n\nfunction handlePartyMemberStatsMsg(\n  conn: WorldConn,\n  r: PacketReader,\n  isFull = false,\n): void {\n  const stats = parsePartyMemberStats(r, isFull);\n  conn.onGroupEvent?.({\n    type: \"member_stats\",\n    guidLow: stats.guidLow,\n    online: stats.online,\n    hp: stats.hp,\n    maxHp: stats.maxHp,\n    level: stats.level,\n  });\n}\n\nfunction handleContactList(conn: WorldConn, r: PacketReader): void {\n  const list = parseContactList(r);\n  const friends: FriendEntry[] = [];\n  for (const contact of list.contacts) {\n    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n    const guidLow = Number(contact.guid & 0xffffffffn);\n    const name = conn.nameCache.get(guidLow) ?? \"\";\n    friends.push({\n      guid: contact.guid,\n      name,\n      note: contact.note,\n      status: contact.status ?? 0,\n      area: contact.area ?? 0,\n      level: contact.level ?? 0,\n      playerClass: contact.playerClass ?? 0,\n    });\n    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n      conn.pendingNameQueries.add(`player:${guidLow}`);\n      sendPacket(\n        conn,\n        GameOpcode.CMSG_NAME_QUERY,\n        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n      );\n    }\n  }\n  conn.friendStore.set(friends);\n}\n\nfunction handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n  const packet = parseFriendStatus(r);\n  const guidLow = Number(packet.guid & 0xffffffffn);\n\n  switch (packet.result) {\n    case FriendResult.ADDED_ONLINE:\n    case FriendResult.ADDED_OFFLINE: {\n      const name = conn.nameCache.get(guidLow) ?? \"\";\n      conn.friendStore.add({\n        guid: packet.guid,\n        name,\n        note: packet.note ?? \"\",\n        status: packet.status ?? 0,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n        conn.pendingNameQueries.add(`player:${guidLow}`);\n        sendPacket(\n          conn,\n          GameOpcode.CMSG_NAME_QUERY,\n          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n        );\n      }\n      break;\n    }\n    case FriendResult.ONLINE:\n      conn.friendStore.update(packet.guid, {\n        status: packet.status ?? FriendStatus.ONLINE,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      break;\n    case FriendResult.OFFLINE:\n      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n      break;\n    case FriendResult.REMOVED:\n      conn.friendStore.remove(packet.guid);\n      break;\n    default: {\n      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n      conn.onFriendEvent?.({\n        type: \"friend-error\",\n        result: packet.result,\n        name,\n      });\n      break;\n    }\n  }\n}\n\nasync function authenticateWorld(\n  conn: WorldConn,\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<void> {\n  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n  challenge.uint32LE();\n  const serverSeed = challenge.bytes(4);\n\n  const body = await buildWorldAuthPacket(\n    config.account,\n    auth.sessionKey,\n    serverSeed,\n    auth.realmId,\n    config.clientSeed,\n  );\n  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n  conn.arc4 = new Arc4(auth.sessionKey);\n\n  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n  const status = resp.uint8();\n  if (status !== 0x0c) {\n    const names: Record<number, string> = {\n      0x0d: \"system error\",\n      0x15: \"account in use\",\n    };\n    const label = names[status] ?? `status 0x${status.toString(16)}`;\n    throw new Error(`World auth failed: ${label}`);\n  }\n}\n\nasync function selectCharacter(\n  conn: WorldConn,\n  config: ClientConfig,\n): Promise<void> {\n  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n\n  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n  const chars = parseCharacterList(enumReader);\n  const char = chars.find(\n    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n  );\n  if (!char) {\n    throw new Error(\n      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n    );\n  }\n\n  conn.selfName = char.name;\n  conn.selfGuidLow = char.guidLow;\n  conn.selfGuidHigh = char.guidHigh;\n\n  const w = new PacketWriter();\n  w.uint32LE(char.guidLow);\n  w.uint32LE(char.guidHigh);\n  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n\n  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n}\n\nfunction startPingLoop(\n  conn: WorldConn,\n  intervalMs: number,\n): ReturnType<typeof setInterval> {\n  return setInterval(() => {\n    const w = new PacketWriter();\n    w.uint32LE(0);\n    w.uint32LE(0);\n    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n  }, intervalMs);\n}\n\nexport function worldSession(\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<WorldHandle> {\n  return new Promise((resolve, reject) => {\n    const conn: WorldConn = {\n      socket: undefined!,\n      dispatch: new OpcodeDispatch(),\n      buf: new AccumulatorBuffer(),\n      startTime: Date.now(),\n      nameCache: new Map(),\n      pendingMessages: new Map(),\n      channels: [],\n      lastChatMode: { type: \"say\" },\n      selfName: \"\",\n      selfGuidLow: 0,\n      selfGuidHigh: 0,\n      partyMembers: new Map(),\n      entityStore: new EntityStore(),\n      creatureNameCache: new Map(),\n      gameObjectNameCache: new Map(),\n      pendingNameQueries: new Set(),\n      friendStore: new FriendStore(),\n    };\n    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n\n    let pingInterval: ReturnType<typeof setInterval>;\n    let done = false;\n    let closedResolve: () => void;\n    const closed = new Promise<void>((r) => {\n      closedResolve = r;\n    });\n\n    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n      handleTimeSync(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n      handleChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n      handleGmChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n      handleNameQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n      handlePlayerNotFound(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n      handleChannelNotify(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n      handlePartyCommandResult(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n      handleGroupInviteReceived(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n      handleGroupSetLeaderMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n      handleGroupListMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n      handleGroupDestroyed(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n      handleGroupUninvite(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n      handleGroupDeclineMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n      handlePartyMemberStatsMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n      handlePartyMemberStatsMsg(conn, r, true),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n      handleUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n      handleCompressedUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n      handleDestroyObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n      handleCreatureQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n      handleGameObjectQueryResponse(conn, r),\n    );\n\n    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n      handleContactList(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n      handleFriendStatus(conn, r),\n    );\n\n    registerStubs(conn.dispatch, (msg) => {\n      if (!conn.onMessage) return false;\n      conn.onMessage({\n        type: ChatType.SYSTEM,\n        sender: \"\",\n        message: msg,\n      });\n      return true;\n    });\n\n    async function login() {\n      await authenticateWorld(conn, config, auth);\n      await selectCharacter(conn, config);\n      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n      const lang = config.language ?? Language.COMMON;\n      done = true;\n      const handle: WorldHandle = {\n        closed,\n        close() {\n          clearInterval(pingInterval);\n          conn.onEntityEvent = undefined;\n          conn.onFriendEvent = undefined;\n          conn.socket.end();\n        },\n        onMessage(cb) {\n          conn.onMessage = cb;\n        },\n        sendWhisper(target, message) {\n          if (target) conn.lastChatMode = { type: \"whisper\", target };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.WHISPER, lang, message, target),\n          );\n        },\n        sendSay(message) {\n          conn.lastChatMode = { type: \"say\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.SAY, lang, message),\n          );\n        },\n        sendYell(message) {\n          conn.lastChatMode = { type: \"yell\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.YELL, lang, message),\n          );\n        },\n        sendGuild(message) {\n          conn.lastChatMode = { type: \"guild\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.GUILD, lang, message),\n          );\n        },\n        sendParty(message) {\n          conn.lastChatMode = { type: \"party\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.PARTY, lang, message),\n          );\n        },\n        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {\n          conn.lastChatMode = { type: \"channel\", channel };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n          );\n        },\n        getChannel(index) {\n          return conn.channels[index - 1];\n        },\n        async who(opts = {}) {\n          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n          return parseWhoResponse(r);\n        },\n        getLastChatMode() {\n          return conn.lastChatMode;\n        },\n        setLastChatMode(mode) {\n          conn.lastChatMode = mode;\n        },\n        sendInCurrentMode(message) {\n          const mode = conn.lastChatMode;\n          switch (mode.type) {\n            case \"say\":\n              handle.sendSay(message);\n              break;\n            case \"yell\":\n              handle.sendYell(message);\n              break;\n            case \"guild\":\n              handle.sendGuild(message);\n              break;\n            case \"party\":\n              handle.sendParty(message);\n              break;\n            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":\n              handle.sendWhisper(mode.target, message);\n              break;\n            case \"channel\":\n              handle.sendChannel(mode.channel, message);\n              break;\n          }\n        },\n        invite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_INVITE,\n            buildGroupInvite(name),\n          );\n        },\n        uninvite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_UNINVITE,\n            buildGroupUninvite(name),\n          );\n        },\n        leaveGroup() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n        },\n        setLeader(name) {\n          const member = conn.partyMembers.get(name);\n          if (!member) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not in your party.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_SET_LEADER,\n            buildGroupSetLeader(member.guidLow, member.guidHigh),\n          );\n        },\n        acceptInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n        },\n        declineInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n        },\n        onGroupEvent(cb) {\n          conn.onGroupEvent = cb;\n        },\n        onEntityEvent(cb) {\n          conn.onEntityEvent = cb;\n        },\n        onPacketError(cb) {\n          conn.onPacketError = cb;\n        },\n        getNearbyEntities() {\n          return conn.entityStore.all();\n        },\n        getFriends() {\n          return conn.friendStore.all();\n        },\n        addFriend(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_ADD_FRIEND,\n            buildAddFriend(name, \"\"),\n          );\n        },\n        removeFriend(name) {\n          const friend = conn.friendStore.findByName(name);\n          if (!friend) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not on your friends list.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_DEL_FRIEND,\n            buildDelFriend(friend.guid),\n          );\n        },\n        onFriendEvent(cb) {\n          conn.onFriendEvent = cb;\n        },\n      };\n      resolve(handle);\n    }\n\n    login().catch((err) => {\n      done = true;\n      clearInterval(pingInterval);\n      reject(err);\n      conn.socket?.end();\n    });\n\n    Bun.connect({\n      hostname: auth.realmHost,\n      port: auth.realmPort,\n      socket: {\n        open(s) {\n          conn.socket = s;\n        },\n        data(_s, data) {\n          conn.buf.append(new Uint8Array(data));\n          drainWorldPackets(conn);\n        },\n        close() {\n          clearInterval(pingInterval);\n          conn.entityStore.clear();\n          if (!done) reject(new Error(\"World connection closed\"));\n          closedResolve();\n        },\n      },\n    }).catch(reject);\n  });\n}\n","structuredPatch":[{"oldStart":165,"oldLines":6,"newStart":165,"newLines":7,"lines":["   sendGuild(message: string): void;","   sendParty(message: string): void;","   sendRaid(message: string): void;","+  sendEmote(message: string): void;","   sendChannel(channel: string, message: string): void;","   getChannel(index: number): string | undefined;","   who(opts?: {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"69a0ea24-996d-4d04-8972-dca48ca8612d"}
{"parentUuid":"b5752f8b-b23d-4048-b373-8268bf290920","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UpEKp3bsr7SxppLgZoaNKu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0155rZt8JstqMDSLy1FxDAax","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.ts","old_string":"        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {","new_string":"        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendEmote(message) {\n          conn.lastChatMode = { type: \"emote\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.EMOTE, lang, message),\n          );\n        },\n        sendChannel(channel, message) {"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":73924,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMSJF4jhZe1nQFsY11M","type":"assistant","uuid":"5843857d-c83f-4cfe-9f8b-63887ed27dc4","timestamp":"2026-02-28T23:42:32.953Z"}
{"parentUuid":"5843857d-c83f-4cfe-9f8b-63887ed27dc4","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0155rZt8JstqMDSLy1FxDAax","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.ts has been updated successfully."}]},"uuid":"4b4c5937-587a-4828-b338-55da4a9924db","timestamp":"2026-02-28T23:42:32.971Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.ts","oldString":"        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {","newString":"        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendEmote(message) {\n          conn.lastChatMode = { type: \"emote\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.EMOTE, lang, message),\n          );\n        },\n        sendChannel(channel, message) {","originalFile":"import type { Socket } from \"bun\";\nimport { inflateSync } from \"node:zlib\";\nimport { PacketReader, PacketWriter } from \"wow/protocol/packet\";\nimport { SRP, type SRPResult } from \"wow/crypto/srp\";\nimport { Arc4 } from \"wow/crypto/arc4\";\nimport {\n  GameOpcode,\n  ChatType,\n  Language,\n  AuthOpcode,\n} from \"wow/protocol/opcodes\";\nimport {\n  parseChatMessage,\n  buildChatMessage,\n  buildNameQuery,\n  parseNameQueryResponse,\n  parseChannelNotify,\n  buildWhoRequest,\n  parseWhoResponse,\n  type ChatMessage as RawChatMessage,\n  type WhoResult,\n} from \"wow/protocol/chat\";\nimport {\n  buildLogonChallenge,\n  parseLogonChallengeResponse,\n  buildLogonProof,\n  parseLogonProofResponse,\n  buildRealmListRequest,\n  parseRealmList,\n  parseReconnectChallengeResponse,\n  buildReconnectProof,\n} from \"wow/protocol/auth\";\nimport {\n  buildWorldAuthPacket,\n  parseCharacterList,\n  OpcodeDispatch,\n  AccumulatorBuffer,\n  INCOMING_HEADER_SIZE,\n  buildOutgoingPacket,\n  decryptIncomingHeader,\n} from \"wow/protocol/world\";\nimport {\n  buildGroupInvite,\n  buildGroupAccept,\n  buildGroupDecline,\n  buildGroupUninvite,\n  buildGroupDisband,\n  buildGroupSetLeader,\n  parsePartyCommandResult,\n  parseGroupInvite,\n  parseGroupSetLeader,\n  parseGroupDecline,\n  parseGroupList,\n  parsePartyMemberStats,\n} from \"wow/protocol/group\";\nimport { registerStubs } from \"wow/protocol/stubs\";\nimport { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\nimport {\n  FriendStore,\n  type FriendEntry,\n  type FriendEvent,\n} from \"wow/friend-store\";\nimport {\n  parseContactList,\n  parseFriendStatus,\n  buildAddFriend,\n  buildDelFriend,\n  SocialFlag,\n  FriendStatus,\n  FriendResult,\n} from \"wow/protocol/social\";\nimport { parseUpdateObject } from \"wow/protocol/update-object\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport {\n  extractObjectFields,\n  extractUnitFields,\n  extractGameObjectFields,\n} from \"wow/protocol/extract-fields\";\nimport {\n  buildCreatureQuery,\n  parseCreatureQueryResponse,\n  buildGameObjectQuery,\n  parseGameObjectQueryResponse,\n} from \"wow/protocol/entity-queries\";\n\nexport type ClientConfig = {\n  host: string;\n  port: number;\n  account: string;\n  password: string;\n  character: string;\n  srpPrivateKey?: bigint;\n  clientSeed?: Uint8Array;\n  pingIntervalMs?: number;\n  language?: number;\n  cachedSessionKey?: Uint8Array;\n};\n\nexport type AuthResult = {\n  sessionKey: Uint8Array;\n  realmHost: string;\n  realmPort: number;\n  realmId: number;\n};\n\nexport type ChatMessage = {\n  type: number;\n  sender: string;\n  message: string;\n  channel?: string;\n};\n\nexport type GroupEvent =\n  | { type: \"invite_received\"; from: string }\n  | {\n      type: \"command_result\";\n      operation: number;\n      target: string;\n      result: number;\n    }\n  | { type: \"leader_changed\"; name: string }\n  | {\n      type: \"group_list\";\n      members: Array<{\n        name: string;\n        guidLow: number;\n        guidHigh: number;\n        online: boolean;\n      }>;\n      leader: string;\n    }\n  | { type: \"group_destroyed\" }\n  | { type: \"kicked\" }\n  | { type: \"invite_declined\"; name: string }\n  | {\n      type: \"member_stats\";\n      guidLow: number;\n      online?: boolean;\n      hp?: number;\n      maxHp?: number;\n      level?: number;\n    };\n\nexport type { WhoResult };\nexport type { Entity, EntityEvent };\nexport type { FriendEntry, FriendEvent };\n\nexport type ChatMode =\n  | { type: \"say\" }\n  | { type: \"yell\" }\n  | { type: \"guild\" }\n  | { type: \"party\" }\n  | { type: \"raid\" }\n  | { type: \"emote\" }\n  | { type: \"whisper\"; target: string }\n  | { type: \"channel\"; channel: string };\n\nexport type WorldHandle = {\n  closed: Promise<void>;\n  close(): void;\n  onMessage(cb: (msg: ChatMessage) => void): void;\n  sendWhisper(target: string, message: string): void;\n  sendSay(message: string): void;\n  sendYell(message: string): void;\n  sendGuild(message: string): void;\n  sendParty(message: string): void;\n  sendRaid(message: string): void;\n  sendEmote(message: string): void;\n  sendChannel(channel: string, message: string): void;\n  getChannel(index: number): string | undefined;\n  who(opts?: {\n    name?: string;\n    minLevel?: number;\n    maxLevel?: number;\n  }): Promise<WhoResult[]>;\n  getLastChatMode(): ChatMode;\n  setLastChatMode(mode: ChatMode): void;\n  sendInCurrentMode(message: string): void;\n  invite(name: string): void;\n  uninvite(name: string): void;\n  leaveGroup(): void;\n  setLeader(name: string): void;\n  acceptInvite(): void;\n  declineInvite(): void;\n  onGroupEvent(cb: (event: GroupEvent) => void): void;\n  onEntityEvent(cb: (event: EntityEvent) => void): void;\n  onPacketError(cb: (opcode: number, err: Error) => void): void;\n  getNearbyEntities(): Entity[];\n  getFriends(): FriendEntry[];\n  addFriend(name: string): void;\n  removeFriend(name: string): void;\n  onFriendEvent(cb: (event: FriendEvent) => void): void;\n};\n\ntype WorldConn = {\n  socket: Socket;\n  dispatch: OpcodeDispatch;\n  buf: AccumulatorBuffer;\n  arc4?: Arc4;\n  startTime: number;\n  pendingHeader?: { size: number; opcode: number };\n  nameCache: Map<number, string>;\n  pendingMessages: Map<number, RawChatMessage[]>;\n  channels: string[];\n  lastChatMode: ChatMode;\n  onMessage?: (msg: ChatMessage) => void;\n  selfName: string;\n  selfGuidLow: number;\n  selfGuidHigh: number;\n  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n  onGroupEvent?: (event: GroupEvent) => void;\n  entityStore: EntityStore;\n  creatureNameCache: Map<number, string>;\n  gameObjectNameCache: Map<number, string>;\n  onEntityEvent?: (event: EntityEvent) => void;\n  onPacketError?: (opcode: number, err: Error) => void;\n  pendingNameQueries: Set<string>;\n  friendStore: FriendStore;\n  onFriendEvent?: (event: FriendEvent) => void;\n};\n\nfunction handleChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n  srp: SRP,\n): SRPResult {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return srp.calculate(\n    result.g!,\n    result.N!,\n    result.salt!,\n    result.B!,\n    config.srpPrivateKey,\n  );\n}\n\nfunction handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonProofResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth proof failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n}\n\nfunction handleRealms(\n  raw: Uint8Array,\n): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n  const realms = parseRealmList(new PacketReader(raw, 1));\n  if (realms.length === 0) throw new Error(\"No realms available\");\n  const realm = realms[0]!;\n  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n}\n\nexport class ReconnectRequiredError extends Error {\n  constructor() {\n    super(\"Server requires reconnect but no cached session key is available\");\n    this.name = \"ReconnectRequiredError\";\n  }\n}\n\nfunction handleReconnectChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n): Uint8Array {\n  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n  const r = new PacketReader(raw);\n  const result = parseReconnectChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return buildReconnectProof(\n    config.account,\n    result.challengeData!,\n    config.cachedSessionKey,\n  );\n}\n\nfunction handleReconnectProof(raw: Uint8Array): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const status = r.uint8();\n  if (status !== 0x00) {\n    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n  }\n}\n\nexport async function authWithRetry(\n  config: ClientConfig,\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\n): Promise<AuthResult> {\n  const maxAttempts = opts?.maxAttempts ?? 5;\n  const baseDelay = opts?.baseDelayMs ?? 5000;\n  let lastError: unknown;\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await authHandshake(config);\n    } catch (err) {\n      if (!(err instanceof ReconnectRequiredError)) throw err;\n      lastError = err;\n      if (attempt + 1 < maxAttempts) {\n        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n        await Bun.sleep(delay);\n      }\n    }\n  }\n  throw lastError;\n}\n\ntype AuthContext = {\n  buf: AccumulatorBuffer;\n  srp: SRP;\n  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n  config: ClientConfig;\n  srpResult?: SRPResult;\n  sessionKey?: Uint8Array;\n};\n\nfunction advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n  const raw = ctx.buf.peek(ctx.buf.length);\n  let result: AuthResult | undefined;\n\n  if (ctx.phase === \"challenge\") {\n    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n      socket.write(handleReconnectChallenge(raw, ctx.config));\n      ctx.sessionKey = ctx.config.cachedSessionKey!;\n      ctx.phase = \"reconnect_proof\";\n    } else {\n      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n      ctx.sessionKey = ctx.srpResult.K;\n      socket.write(buildLogonProof(ctx.srpResult));\n      ctx.phase = \"proof\";\n    }\n  } else if (ctx.phase === \"proof\") {\n    handleProof(raw, ctx.srpResult!);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else if (ctx.phase === \"reconnect_proof\") {\n    handleReconnectProof(raw);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else {\n    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n  }\n\n  ctx.buf.drain(ctx.buf.length);\n  return result;\n}\n\nexport function authHandshake(config: ClientConfig): Promise<AuthResult> {\n  return new Promise((resolve, reject) => {\n    const ctx: AuthContext = {\n      buf: new AccumulatorBuffer(),\n      srp: new SRP(config.account, config.password),\n      phase: \"challenge\",\n      config,\n    };\n    let done = false;\n\n    Bun.connect({\n      hostname: config.host,\n      port: config.port,\n      socket: {\n        open(socket) {\n          socket.write(buildLogonChallenge(config.account));\n        },\n        data(socket, data) {\n          ctx.buf.append(new Uint8Array(data));\n          try {\n            const result = advanceAuth(ctx, socket);\n            if (result) {\n              done = true;\n              socket.end();\n              resolve(result);\n            }\n          } catch (err) {\n            if (err instanceof RangeError) return;\n            done = true;\n            reject(err);\n            socket.end();\n          }\n        },\n        close() {\n          if (!done) reject(new Error(\"Auth connection closed\"));\n        },\n      },\n    }).catch(reject);\n  });\n}\n\nfunction sendPacket(\n  conn: WorldConn,\n  opcode: number,\n  body: Uint8Array = new Uint8Array(0),\n): void {\n  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n}\n\nfunction drainWorldPackets(conn: WorldConn): void {\n  while (true) {\n    if (!conn.pendingHeader) {\n      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n      conn.pendingHeader = decryptIncomingHeader(\n        conn.buf.drain(INCOMING_HEADER_SIZE),\n        conn.arc4,\n      );\n    }\n    const bodySize = conn.pendingHeader.size - 2;\n    if (conn.buf.length < bodySize) break;\n\n    const { opcode } = conn.pendingHeader;\n    conn.pendingHeader = undefined;\n    try {\n      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n    } catch (err) {\n      if (err instanceof Error) {\n        conn.onPacketError?.(opcode, err);\n      }\n    }\n  }\n}\n\nfunction handleTimeSync(conn: WorldConn, r: PacketReader): void {\n  const counter = r.uint32LE();\n  const elapsed = Date.now() - conn.startTime;\n  const w = new PacketWriter();\n  w.uint32LE(counter);\n  w.uint32LE(elapsed);\n  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,\n    sender: name,\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n  if (pending) {\n    pending.push(raw);\n  } else {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  }\n}\n\nfunction handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r, true);\n  deliverMessage(conn, raw, raw.senderName ?? \"\");\n}\n\nfunction handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseNameQueryResponse(r);\n\n  const name = result.found && result.name ? result.name : \"\";\n  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n  if (result.found && result.name) {\n    conn.nameCache.set(result.guidLow, result.name);\n    for (const entity of conn.entityStore.all()) {\n      if (\n        entity.objectType === ObjectType.PLAYER &&\n        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n        !entity.name\n      ) {\n        conn.entityStore.setName(entity.guid, result.name);\n      }\n    }\n    for (const friend of conn.friendStore.all()) {\n      if (\n        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n        !friend.name\n      ) {\n        conn.friendStore.setName(friend.guid, result.name);\n      }\n    }\n  }\n\n  const pending = conn.pendingMessages.get(result.guidLow);\n  if (!pending) return;\n  for (const raw of pending) deliverMessage(conn, raw, name);\n  conn.pendingMessages.delete(result.guidLow);\n}\n\nfunction handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n  const event = parseChannelNotify(r);\n  if (event.type === \"joined\") {\n    conn.channels.push(event.channel);\n  } else if (event.type === \"left\") {\n    const idx = conn.channels.indexOf(event.channel);\n    if (idx !== -1) conn.channels.splice(idx, 1);\n  }\n}\n\nfunction handleMotd(conn: WorldConn, r: PacketReader): void {\n  const lineCount = r.uint32LE();\n  const lines: string[] = [];\n  for (let i = 0; i < lineCount; i++) {\n    lines.push(r.cString());\n  }\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: lines.join(\"\\n\"),\n  });\n}\n\nfunction handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n  const name = r.cString();\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: `No player named \"${name}\" is currently playing.`,\n  });\n}\n\nfunction handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n  const result = parsePartyCommandResult(r);\n  conn.onGroupEvent?.({\n    type: \"command_result\",\n    operation: result.operation,\n    target: result.member,\n    result: result.result,\n  });\n}\n\nfunction handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n  const invite = parseGroupInvite(r);\n  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n}\n\nfunction handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupSetLeader(r);\n  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n}\n\nfunction handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n  const list = parseGroupList(r);\n  conn.partyMembers.clear();\n  let leaderName = \"\";\n  if (\n    conn.selfGuidLow === list.leaderGuidLow &&\n    conn.selfGuidHigh === list.leaderGuidHigh\n  ) {\n    leaderName = conn.selfName;\n  }\n  for (const m of list.members) {\n    conn.partyMembers.set(m.name, {\n      guidLow: m.guidLow,\n      guidHigh: m.guidHigh,\n    });\n    if (\n      m.guidLow === list.leaderGuidLow &&\n      m.guidHigh === list.leaderGuidHigh\n    ) {\n      leaderName = m.name;\n    }\n  }\n  conn.onGroupEvent?.({\n    type: \"group_list\",\n    members: list.members,\n    leader: leaderName,\n  });\n}\n\nfunction handleGroupDestroyed(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n}\n\nfunction handleGroupUninvite(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"kicked\" });\n}\n\nfunction handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupDecline(r);\n  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n}\n\nfunction handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const entries = parseUpdateObject(r);\n  for (const entry of entries) {\n    switch (entry.type) {\n      case \"create\": {\n        const { _changed: _co, ...objFields } = extractObjectFields(\n          entry.fields,\n        );\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entry.objectType === ObjectType.UNIT ||\n          entry.objectType === ObjectType.PLAYER\n        ) {\n          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n          extraFields = rest;\n        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n          const { _changed: _cg, ...rest } = extractGameObjectFields(\n            entry.fields,\n          );\n          extraFields = rest;\n        }\n        const cachedName = lookupCachedName(\n          conn,\n          entry.guid,\n          entry.objectType,\n          objFields.entry,\n        );\n        conn.entityStore.create(entry.guid, entry.objectType, {\n          ...objFields,\n          ...extraFields,\n          ...(cachedName ? { name: cachedName } : {}),\n          ...(entry.position ? { position: entry.position } : {}),\n          rawFields: new Map(entry.fields),\n        } as any);\n        if (!cachedName) {\n          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n        }\n        break;\n      }\n      case \"values\": {\n        const entity = conn.entityStore.get(entry.guid);\n        if (!entity) break;\n        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entity.objectType === ObjectType.UNIT ||\n          entity.objectType === ObjectType.PLAYER\n        ) {\n          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n          extraFields = extractGameObjectFields(entry.fields);\n        }\n        const allChanged = [\n          ...(objFields._changed || []),\n          ...((extraFields as any)._changed || []),\n        ];\n        const merged: Record<string, unknown> = {};\n        for (const key of allChanged) {\n          if (key in extraFields) merged[key] = (extraFields as any)[key];\n          else if (key in objFields) merged[key] = (objFields as any)[key];\n        }\n        conn.entityStore.update(entry.guid, merged);\n        for (const [k, v] of entry.fields) {\n          const existing = conn.entityStore.get(entry.guid);\n          if (existing) existing.rawFields.set(k, v);\n        }\n        break;\n      }\n      case \"movement\": {\n        conn.entityStore.setPosition(entry.guid, entry.position);\n        break;\n      }\n      case \"outOfRange\": {\n        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n        break;\n      }\n      case \"nearObjects\": {\n        break;\n      }\n    }\n  }\n}\n\nfunction handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const uncompressedSize = r.uint32LE();\n  const compressed = r.bytes(r.remaining);\n  const decompressed = inflateSync(compressed);\n  if (decompressed.length !== uncompressedSize) {\n    throw new Error(\n      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n    );\n  }\n  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n}\n\nfunction handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n  const guid = r.uint64LE();\n  r.skip(1);\n  conn.entityStore.destroy(guid);\n}\n\nfunction lookupCachedName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): string | undefined {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    return conn.nameCache.get(guidLow);\n  }\n  if (entry === undefined) return undefined;\n  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n  if (objectType === ObjectType.GAMEOBJECT)\n    return conn.gameObjectNameCache.get(entry);\n  return undefined;\n}\n\nfunction queryEntityName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): void {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    const key = `player:${guidLow}`;\n    if (conn.pendingNameQueries.has(key)) return;\n    conn.pendingNameQueries.add(key);\n    const w = new PacketWriter();\n    w.uint64LE(guid);\n    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n    return;\n  }\n  if (entry === undefined) return;\n  const key = `${objectType}:${entry}`;\n  if (conn.pendingNameQueries.has(key)) return;\n  conn.pendingNameQueries.add(key);\n  if (objectType === ObjectType.UNIT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_CREATURE_QUERY,\n      buildCreatureQuery(entry, guid),\n    );\n    return;\n  }\n  if (objectType === ObjectType.GAMEOBJECT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n      buildGameObjectQuery(entry, guid),\n    );\n    return;\n  }\n}\n\nfunction handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseCreatureQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n  if (!result.name) return;\n  conn.creatureNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry && !entity.name) {\n      conn.entityStore.setName(entity.guid, result.name);\n    }\n  }\n}\n\nfunction handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseGameObjectQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n  if (!result.name) return;\n  conn.gameObjectNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry) {\n      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n      if (result.gameObjectType !== undefined) {\n        conn.entityStore.update(entity.guid, {\n          gameObjectType: result.gameObjectType,\n        });\n      }\n    }\n  }\n}\n\nfunction handlePartyMemberStatsMsg(\n  conn: WorldConn,\n  r: PacketReader,\n  isFull = false,\n): void {\n  const stats = parsePartyMemberStats(r, isFull);\n  conn.onGroupEvent?.({\n    type: \"member_stats\",\n    guidLow: stats.guidLow,\n    online: stats.online,\n    hp: stats.hp,\n    maxHp: stats.maxHp,\n    level: stats.level,\n  });\n}\n\nfunction handleContactList(conn: WorldConn, r: PacketReader): void {\n  const list = parseContactList(r);\n  const friends: FriendEntry[] = [];\n  for (const contact of list.contacts) {\n    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n    const guidLow = Number(contact.guid & 0xffffffffn);\n    const name = conn.nameCache.get(guidLow) ?? \"\";\n    friends.push({\n      guid: contact.guid,\n      name,\n      note: contact.note,\n      status: contact.status ?? 0,\n      area: contact.area ?? 0,\n      level: contact.level ?? 0,\n      playerClass: contact.playerClass ?? 0,\n    });\n    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n      conn.pendingNameQueries.add(`player:${guidLow}`);\n      sendPacket(\n        conn,\n        GameOpcode.CMSG_NAME_QUERY,\n        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n      );\n    }\n  }\n  conn.friendStore.set(friends);\n}\n\nfunction handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n  const packet = parseFriendStatus(r);\n  const guidLow = Number(packet.guid & 0xffffffffn);\n\n  switch (packet.result) {\n    case FriendResult.ADDED_ONLINE:\n    case FriendResult.ADDED_OFFLINE: {\n      const name = conn.nameCache.get(guidLow) ?? \"\";\n      conn.friendStore.add({\n        guid: packet.guid,\n        name,\n        note: packet.note ?? \"\",\n        status: packet.status ?? 0,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n        conn.pendingNameQueries.add(`player:${guidLow}`);\n        sendPacket(\n          conn,\n          GameOpcode.CMSG_NAME_QUERY,\n          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n        );\n      }\n      break;\n    }\n    case FriendResult.ONLINE:\n      conn.friendStore.update(packet.guid, {\n        status: packet.status ?? FriendStatus.ONLINE,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      break;\n    case FriendResult.OFFLINE:\n      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n      break;\n    case FriendResult.REMOVED:\n      conn.friendStore.remove(packet.guid);\n      break;\n    default: {\n      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n      conn.onFriendEvent?.({\n        type: \"friend-error\",\n        result: packet.result,\n        name,\n      });\n      break;\n    }\n  }\n}\n\nasync function authenticateWorld(\n  conn: WorldConn,\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<void> {\n  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n  challenge.uint32LE();\n  const serverSeed = challenge.bytes(4);\n\n  const body = await buildWorldAuthPacket(\n    config.account,\n    auth.sessionKey,\n    serverSeed,\n    auth.realmId,\n    config.clientSeed,\n  );\n  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n  conn.arc4 = new Arc4(auth.sessionKey);\n\n  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n  const status = resp.uint8();\n  if (status !== 0x0c) {\n    const names: Record<number, string> = {\n      0x0d: \"system error\",\n      0x15: \"account in use\",\n    };\n    const label = names[status] ?? `status 0x${status.toString(16)}`;\n    throw new Error(`World auth failed: ${label}`);\n  }\n}\n\nasync function selectCharacter(\n  conn: WorldConn,\n  config: ClientConfig,\n): Promise<void> {\n  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n\n  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n  const chars = parseCharacterList(enumReader);\n  const char = chars.find(\n    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n  );\n  if (!char) {\n    throw new Error(\n      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n    );\n  }\n\n  conn.selfName = char.name;\n  conn.selfGuidLow = char.guidLow;\n  conn.selfGuidHigh = char.guidHigh;\n\n  const w = new PacketWriter();\n  w.uint32LE(char.guidLow);\n  w.uint32LE(char.guidHigh);\n  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n\n  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n}\n\nfunction startPingLoop(\n  conn: WorldConn,\n  intervalMs: number,\n): ReturnType<typeof setInterval> {\n  return setInterval(() => {\n    const w = new PacketWriter();\n    w.uint32LE(0);\n    w.uint32LE(0);\n    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n  }, intervalMs);\n}\n\nexport function worldSession(\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<WorldHandle> {\n  return new Promise((resolve, reject) => {\n    const conn: WorldConn = {\n      socket: undefined!,\n      dispatch: new OpcodeDispatch(),\n      buf: new AccumulatorBuffer(),\n      startTime: Date.now(),\n      nameCache: new Map(),\n      pendingMessages: new Map(),\n      channels: [],\n      lastChatMode: { type: \"say\" },\n      selfName: \"\",\n      selfGuidLow: 0,\n      selfGuidHigh: 0,\n      partyMembers: new Map(),\n      entityStore: new EntityStore(),\n      creatureNameCache: new Map(),\n      gameObjectNameCache: new Map(),\n      pendingNameQueries: new Set(),\n      friendStore: new FriendStore(),\n    };\n    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n\n    let pingInterval: ReturnType<typeof setInterval>;\n    let done = false;\n    let closedResolve: () => void;\n    const closed = new Promise<void>((r) => {\n      closedResolve = r;\n    });\n\n    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n      handleTimeSync(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n      handleChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n      handleGmChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n      handleNameQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n      handlePlayerNotFound(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n      handleChannelNotify(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n      handlePartyCommandResult(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n      handleGroupInviteReceived(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n      handleGroupSetLeaderMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n      handleGroupListMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n      handleGroupDestroyed(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n      handleGroupUninvite(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n      handleGroupDeclineMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n      handlePartyMemberStatsMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n      handlePartyMemberStatsMsg(conn, r, true),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n      handleUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n      handleCompressedUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n      handleDestroyObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n      handleCreatureQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n      handleGameObjectQueryResponse(conn, r),\n    );\n\n    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n      handleContactList(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n      handleFriendStatus(conn, r),\n    );\n\n    registerStubs(conn.dispatch, (msg) => {\n      if (!conn.onMessage) return false;\n      conn.onMessage({\n        type: ChatType.SYSTEM,\n        sender: \"\",\n        message: msg,\n      });\n      return true;\n    });\n\n    async function login() {\n      await authenticateWorld(conn, config, auth);\n      await selectCharacter(conn, config);\n      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n      const lang = config.language ?? Language.COMMON;\n      done = true;\n      const handle: WorldHandle = {\n        closed,\n        close() {\n          clearInterval(pingInterval);\n          conn.onEntityEvent = undefined;\n          conn.onFriendEvent = undefined;\n          conn.socket.end();\n        },\n        onMessage(cb) {\n          conn.onMessage = cb;\n        },\n        sendWhisper(target, message) {\n          if (target) conn.lastChatMode = { type: \"whisper\", target };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.WHISPER, lang, message, target),\n          );\n        },\n        sendSay(message) {\n          conn.lastChatMode = { type: \"say\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.SAY, lang, message),\n          );\n        },\n        sendYell(message) {\n          conn.lastChatMode = { type: \"yell\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.YELL, lang, message),\n          );\n        },\n        sendGuild(message) {\n          conn.lastChatMode = { type: \"guild\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.GUILD, lang, message),\n          );\n        },\n        sendParty(message) {\n          conn.lastChatMode = { type: \"party\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.PARTY, lang, message),\n          );\n        },\n        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendChannel(channel, message) {\n          conn.lastChatMode = { type: \"channel\", channel };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n          );\n        },\n        getChannel(index) {\n          return conn.channels[index - 1];\n        },\n        async who(opts = {}) {\n          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n          return parseWhoResponse(r);\n        },\n        getLastChatMode() {\n          return conn.lastChatMode;\n        },\n        setLastChatMode(mode) {\n          conn.lastChatMode = mode;\n        },\n        sendInCurrentMode(message) {\n          const mode = conn.lastChatMode;\n          switch (mode.type) {\n            case \"say\":\n              handle.sendSay(message);\n              break;\n            case \"yell\":\n              handle.sendYell(message);\n              break;\n            case \"guild\":\n              handle.sendGuild(message);\n              break;\n            case \"party\":\n              handle.sendParty(message);\n              break;\n            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":\n              handle.sendWhisper(mode.target, message);\n              break;\n            case \"channel\":\n              handle.sendChannel(mode.channel, message);\n              break;\n          }\n        },\n        invite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_INVITE,\n            buildGroupInvite(name),\n          );\n        },\n        uninvite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_UNINVITE,\n            buildGroupUninvite(name),\n          );\n        },\n        leaveGroup() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n        },\n        setLeader(name) {\n          const member = conn.partyMembers.get(name);\n          if (!member) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not in your party.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_SET_LEADER,\n            buildGroupSetLeader(member.guidLow, member.guidHigh),\n          );\n        },\n        acceptInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n        },\n        declineInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n        },\n        onGroupEvent(cb) {\n          conn.onGroupEvent = cb;\n        },\n        onEntityEvent(cb) {\n          conn.onEntityEvent = cb;\n        },\n        onPacketError(cb) {\n          conn.onPacketError = cb;\n        },\n        getNearbyEntities() {\n          return conn.entityStore.all();\n        },\n        getFriends() {\n          return conn.friendStore.all();\n        },\n        addFriend(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_ADD_FRIEND,\n            buildAddFriend(name, \"\"),\n          );\n        },\n        removeFriend(name) {\n          const friend = conn.friendStore.findByName(name);\n          if (!friend) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not on your friends list.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_DEL_FRIEND,\n            buildDelFriend(friend.guid),\n          );\n        },\n        onFriendEvent(cb) {\n          conn.onFriendEvent = cb;\n        },\n      };\n      resolve(handle);\n    }\n\n    login().catch((err) => {\n      done = true;\n      clearInterval(pingInterval);\n      reject(err);\n      conn.socket?.end();\n    });\n\n    Bun.connect({\n      hostname: auth.realmHost,\n      port: auth.realmPort,\n      socket: {\n        open(s) {\n          conn.socket = s;\n        },\n        data(_s, data) {\n          conn.buf.append(new Uint8Array(data));\n          drainWorldPackets(conn);\n        },\n        close() {\n          clearInterval(pingInterval);\n          conn.entityStore.clear();\n          if (!done) reject(new Error(\"World connection closed\"));\n          closedResolve();\n        },\n      },\n    }).catch(reject);\n  });\n}\n","structuredPatch":[{"oldStart":1146,"oldLines":6,"newStart":1146,"newLines":14,"lines":["             buildChatMessage(ChatType.RAID, lang, message),","           );","         },","+        sendEmote(message) {","+          conn.lastChatMode = { type: \"emote\" };","+          sendPacket(","+            conn,","+            GameOpcode.CMSG_MESSAGE_CHAT,","+            buildChatMessage(ChatType.EMOTE, lang, message),","+          );","+        },","         sendChannel(channel, message) {","           conn.lastChatMode = { type: \"channel\", channel };","           sendPacket("]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5843857d-c83f-4cfe-9f8b-63887ed27dc4"}
{"parentUuid":"4b4c5937-587a-4828-b338-55da4a9924db","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UpEKp3bsr7SxppLgZoaNKu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FVVW18z4DK2vRcF9xjnzrG","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.ts","old_string":"            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":","new_string":"            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"emote\":\n              handle.sendEmote(message);\n              break;\n            case \"whisper\":"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":73924,"output_tokens":849,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":353,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMSJF4jhZe1nQFsY11M","type":"assistant","uuid":"d6b8c7e3-0513-4648-bd77-d79c0cab7bad","timestamp":"2026-02-28T23:42:34.229Z"}
{"parentUuid":"d6b8c7e3-0513-4648-bd77-d79c0cab7bad","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FVVW18z4DK2vRcF9xjnzrG","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.ts has been updated successfully."}]},"uuid":"09bda1b0-afb8-45df-874a-104794fd8ec0","timestamp":"2026-02-28T23:42:34.246Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.ts","oldString":"            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":","newString":"            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"emote\":\n              handle.sendEmote(message);\n              break;\n            case \"whisper\":","originalFile":"import type { Socket } from \"bun\";\nimport { inflateSync } from \"node:zlib\";\nimport { PacketReader, PacketWriter } from \"wow/protocol/packet\";\nimport { SRP, type SRPResult } from \"wow/crypto/srp\";\nimport { Arc4 } from \"wow/crypto/arc4\";\nimport {\n  GameOpcode,\n  ChatType,\n  Language,\n  AuthOpcode,\n} from \"wow/protocol/opcodes\";\nimport {\n  parseChatMessage,\n  buildChatMessage,\n  buildNameQuery,\n  parseNameQueryResponse,\n  parseChannelNotify,\n  buildWhoRequest,\n  parseWhoResponse,\n  type ChatMessage as RawChatMessage,\n  type WhoResult,\n} from \"wow/protocol/chat\";\nimport {\n  buildLogonChallenge,\n  parseLogonChallengeResponse,\n  buildLogonProof,\n  parseLogonProofResponse,\n  buildRealmListRequest,\n  parseRealmList,\n  parseReconnectChallengeResponse,\n  buildReconnectProof,\n} from \"wow/protocol/auth\";\nimport {\n  buildWorldAuthPacket,\n  parseCharacterList,\n  OpcodeDispatch,\n  AccumulatorBuffer,\n  INCOMING_HEADER_SIZE,\n  buildOutgoingPacket,\n  decryptIncomingHeader,\n} from \"wow/protocol/world\";\nimport {\n  buildGroupInvite,\n  buildGroupAccept,\n  buildGroupDecline,\n  buildGroupUninvite,\n  buildGroupDisband,\n  buildGroupSetLeader,\n  parsePartyCommandResult,\n  parseGroupInvite,\n  parseGroupSetLeader,\n  parseGroupDecline,\n  parseGroupList,\n  parsePartyMemberStats,\n} from \"wow/protocol/group\";\nimport { registerStubs } from \"wow/protocol/stubs\";\nimport { EntityStore, type Entity, type EntityEvent } from \"wow/entity-store\";\nimport {\n  FriendStore,\n  type FriendEntry,\n  type FriendEvent,\n} from \"wow/friend-store\";\nimport {\n  parseContactList,\n  parseFriendStatus,\n  buildAddFriend,\n  buildDelFriend,\n  SocialFlag,\n  FriendStatus,\n  FriendResult,\n} from \"wow/protocol/social\";\nimport { parseUpdateObject } from \"wow/protocol/update-object\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport {\n  extractObjectFields,\n  extractUnitFields,\n  extractGameObjectFields,\n} from \"wow/protocol/extract-fields\";\nimport {\n  buildCreatureQuery,\n  parseCreatureQueryResponse,\n  buildGameObjectQuery,\n  parseGameObjectQueryResponse,\n} from \"wow/protocol/entity-queries\";\n\nexport type ClientConfig = {\n  host: string;\n  port: number;\n  account: string;\n  password: string;\n  character: string;\n  srpPrivateKey?: bigint;\n  clientSeed?: Uint8Array;\n  pingIntervalMs?: number;\n  language?: number;\n  cachedSessionKey?: Uint8Array;\n};\n\nexport type AuthResult = {\n  sessionKey: Uint8Array;\n  realmHost: string;\n  realmPort: number;\n  realmId: number;\n};\n\nexport type ChatMessage = {\n  type: number;\n  sender: string;\n  message: string;\n  channel?: string;\n};\n\nexport type GroupEvent =\n  | { type: \"invite_received\"; from: string }\n  | {\n      type: \"command_result\";\n      operation: number;\n      target: string;\n      result: number;\n    }\n  | { type: \"leader_changed\"; name: string }\n  | {\n      type: \"group_list\";\n      members: Array<{\n        name: string;\n        guidLow: number;\n        guidHigh: number;\n        online: boolean;\n      }>;\n      leader: string;\n    }\n  | { type: \"group_destroyed\" }\n  | { type: \"kicked\" }\n  | { type: \"invite_declined\"; name: string }\n  | {\n      type: \"member_stats\";\n      guidLow: number;\n      online?: boolean;\n      hp?: number;\n      maxHp?: number;\n      level?: number;\n    };\n\nexport type { WhoResult };\nexport type { Entity, EntityEvent };\nexport type { FriendEntry, FriendEvent };\n\nexport type ChatMode =\n  | { type: \"say\" }\n  | { type: \"yell\" }\n  | { type: \"guild\" }\n  | { type: \"party\" }\n  | { type: \"raid\" }\n  | { type: \"emote\" }\n  | { type: \"whisper\"; target: string }\n  | { type: \"channel\"; channel: string };\n\nexport type WorldHandle = {\n  closed: Promise<void>;\n  close(): void;\n  onMessage(cb: (msg: ChatMessage) => void): void;\n  sendWhisper(target: string, message: string): void;\n  sendSay(message: string): void;\n  sendYell(message: string): void;\n  sendGuild(message: string): void;\n  sendParty(message: string): void;\n  sendRaid(message: string): void;\n  sendEmote(message: string): void;\n  sendChannel(channel: string, message: string): void;\n  getChannel(index: number): string | undefined;\n  who(opts?: {\n    name?: string;\n    minLevel?: number;\n    maxLevel?: number;\n  }): Promise<WhoResult[]>;\n  getLastChatMode(): ChatMode;\n  setLastChatMode(mode: ChatMode): void;\n  sendInCurrentMode(message: string): void;\n  invite(name: string): void;\n  uninvite(name: string): void;\n  leaveGroup(): void;\n  setLeader(name: string): void;\n  acceptInvite(): void;\n  declineInvite(): void;\n  onGroupEvent(cb: (event: GroupEvent) => void): void;\n  onEntityEvent(cb: (event: EntityEvent) => void): void;\n  onPacketError(cb: (opcode: number, err: Error) => void): void;\n  getNearbyEntities(): Entity[];\n  getFriends(): FriendEntry[];\n  addFriend(name: string): void;\n  removeFriend(name: string): void;\n  onFriendEvent(cb: (event: FriendEvent) => void): void;\n};\n\ntype WorldConn = {\n  socket: Socket;\n  dispatch: OpcodeDispatch;\n  buf: AccumulatorBuffer;\n  arc4?: Arc4;\n  startTime: number;\n  pendingHeader?: { size: number; opcode: number };\n  nameCache: Map<number, string>;\n  pendingMessages: Map<number, RawChatMessage[]>;\n  channels: string[];\n  lastChatMode: ChatMode;\n  onMessage?: (msg: ChatMessage) => void;\n  selfName: string;\n  selfGuidLow: number;\n  selfGuidHigh: number;\n  partyMembers: Map<string, { guidLow: number; guidHigh: number }>;\n  onGroupEvent?: (event: GroupEvent) => void;\n  entityStore: EntityStore;\n  creatureNameCache: Map<number, string>;\n  gameObjectNameCache: Map<number, string>;\n  onEntityEvent?: (event: EntityEvent) => void;\n  onPacketError?: (opcode: number, err: Error) => void;\n  pendingNameQueries: Set<string>;\n  friendStore: FriendStore;\n  onFriendEvent?: (event: FriendEvent) => void;\n};\n\nfunction handleChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n  srp: SRP,\n): SRPResult {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return srp.calculate(\n    result.g!,\n    result.N!,\n    result.salt!,\n    result.B!,\n    config.srpPrivateKey,\n  );\n}\n\nfunction handleProof(raw: Uint8Array, srpResult: SRPResult): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const result = parseLogonProofResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Auth proof failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  if (result.M2 !== srpResult.M2) throw new Error(\"Server M2 mismatch\");\n}\n\nfunction handleRealms(\n  raw: Uint8Array,\n): Pick<AuthResult, \"realmHost\" | \"realmPort\" | \"realmId\"> {\n  const realms = parseRealmList(new PacketReader(raw, 1));\n  if (realms.length === 0) throw new Error(\"No realms available\");\n  const realm = realms[0]!;\n  return { realmHost: realm.host, realmPort: realm.port, realmId: realm.id };\n}\n\nexport class ReconnectRequiredError extends Error {\n  constructor() {\n    super(\"Server requires reconnect but no cached session key is available\");\n    this.name = \"ReconnectRequiredError\";\n  }\n}\n\nfunction handleReconnectChallenge(\n  raw: Uint8Array,\n  config: ClientConfig,\n): Uint8Array {\n  if (!config.cachedSessionKey) throw new ReconnectRequiredError();\n  const r = new PacketReader(raw);\n  const result = parseReconnectChallengeResponse(r);\n  if (result.status !== 0x00) {\n    throw new Error(\n      `Reconnect challenge failed: status 0x${result.status.toString(16)}`,\n    );\n  }\n  return buildReconnectProof(\n    config.account,\n    result.challengeData!,\n    config.cachedSessionKey,\n  );\n}\n\nfunction handleReconnectProof(raw: Uint8Array): void {\n  const r = new PacketReader(raw);\n  r.skip(1);\n  const status = r.uint8();\n  if (status !== 0x00) {\n    throw new Error(`Reconnect proof failed: status 0x${status.toString(16)}`);\n  }\n}\n\nexport async function authWithRetry(\n  config: ClientConfig,\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\n): Promise<AuthResult> {\n  const maxAttempts = opts?.maxAttempts ?? 5;\n  const baseDelay = opts?.baseDelayMs ?? 5000;\n  let lastError: unknown;\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await authHandshake(config);\n    } catch (err) {\n      if (!(err instanceof ReconnectRequiredError)) throw err;\n      lastError = err;\n      if (attempt + 1 < maxAttempts) {\n        const delay = Math.min(baseDelay * 2 ** attempt, 60000);\n        await Bun.sleep(delay);\n      }\n    }\n  }\n  throw lastError;\n}\n\ntype AuthContext = {\n  buf: AccumulatorBuffer;\n  srp: SRP;\n  phase: \"challenge\" | \"proof\" | \"reconnect_proof\" | \"realms\";\n  config: ClientConfig;\n  srpResult?: SRPResult;\n  sessionKey?: Uint8Array;\n};\n\nfunction advanceAuth(ctx: AuthContext, socket: Socket): AuthResult | undefined {\n  const raw = ctx.buf.peek(ctx.buf.length);\n  let result: AuthResult | undefined;\n\n  if (ctx.phase === \"challenge\") {\n    if (raw[0] === AuthOpcode.RECONNECT_CHALLENGE) {\n      socket.write(handleReconnectChallenge(raw, ctx.config));\n      ctx.sessionKey = ctx.config.cachedSessionKey!;\n      ctx.phase = \"reconnect_proof\";\n    } else {\n      ctx.srpResult = handleChallenge(raw, ctx.config, ctx.srp);\n      ctx.sessionKey = ctx.srpResult.K;\n      socket.write(buildLogonProof(ctx.srpResult));\n      ctx.phase = \"proof\";\n    }\n  } else if (ctx.phase === \"proof\") {\n    handleProof(raw, ctx.srpResult!);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else if (ctx.phase === \"reconnect_proof\") {\n    handleReconnectProof(raw);\n    socket.write(buildRealmListRequest());\n    ctx.phase = \"realms\";\n  } else {\n    result = { sessionKey: ctx.sessionKey!, ...handleRealms(raw) };\n  }\n\n  ctx.buf.drain(ctx.buf.length);\n  return result;\n}\n\nexport function authHandshake(config: ClientConfig): Promise<AuthResult> {\n  return new Promise((resolve, reject) => {\n    const ctx: AuthContext = {\n      buf: new AccumulatorBuffer(),\n      srp: new SRP(config.account, config.password),\n      phase: \"challenge\",\n      config,\n    };\n    let done = false;\n\n    Bun.connect({\n      hostname: config.host,\n      port: config.port,\n      socket: {\n        open(socket) {\n          socket.write(buildLogonChallenge(config.account));\n        },\n        data(socket, data) {\n          ctx.buf.append(new Uint8Array(data));\n          try {\n            const result = advanceAuth(ctx, socket);\n            if (result) {\n              done = true;\n              socket.end();\n              resolve(result);\n            }\n          } catch (err) {\n            if (err instanceof RangeError) return;\n            done = true;\n            reject(err);\n            socket.end();\n          }\n        },\n        close() {\n          if (!done) reject(new Error(\"Auth connection closed\"));\n        },\n      },\n    }).catch(reject);\n  });\n}\n\nfunction sendPacket(\n  conn: WorldConn,\n  opcode: number,\n  body: Uint8Array = new Uint8Array(0),\n): void {\n  conn.socket.write(buildOutgoingPacket(opcode, body, conn.arc4));\n}\n\nfunction drainWorldPackets(conn: WorldConn): void {\n  while (true) {\n    if (!conn.pendingHeader) {\n      if (conn.buf.length < INCOMING_HEADER_SIZE) break;\n      conn.pendingHeader = decryptIncomingHeader(\n        conn.buf.drain(INCOMING_HEADER_SIZE),\n        conn.arc4,\n      );\n    }\n    const bodySize = conn.pendingHeader.size - 2;\n    if (conn.buf.length < bodySize) break;\n\n    const { opcode } = conn.pendingHeader;\n    conn.pendingHeader = undefined;\n    try {\n      conn.dispatch.handle(opcode, new PacketReader(conn.buf.drain(bodySize)));\n    } catch (err) {\n      if (err instanceof Error) {\n        conn.onPacketError?.(opcode, err);\n      }\n    }\n  }\n}\n\nfunction handleTimeSync(conn: WorldConn, r: PacketReader): void {\n  const counter = r.uint32LE();\n  const elapsed = Date.now() - conn.startTime;\n  const w = new PacketWriter();\n  w.uint32LE(counter);\n  w.uint32LE(elapsed);\n  sendPacket(conn, GameOpcode.CMSG_TIME_SYNC_RESP, w.finish());\n}\n\nfunction deliverMessage(\n  conn: WorldConn,\n  raw: RawChatMessage,\n  name: string,\n): void {\n  conn.onMessage?.({\n    type: raw.type,\n    sender: name,\n    message: raw.message,\n    channel: raw.channel,\n  });\n}\n\nfunction handleChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r);\n\n  if (raw.senderGuidLow === 0) {\n    deliverMessage(conn, raw, \"\");\n    return;\n  }\n\n  const cached = conn.nameCache.get(raw.senderGuidLow);\n  if (cached !== undefined) {\n    deliverMessage(conn, raw, cached);\n    return;\n  }\n\n  const pending = conn.pendingMessages.get(raw.senderGuidLow);\n  if (pending) {\n    pending.push(raw);\n  } else {\n    conn.pendingMessages.set(raw.senderGuidLow, [raw]);\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_NAME_QUERY,\n      buildNameQuery(raw.senderGuidLow, raw.senderGuidHigh),\n    );\n  }\n}\n\nfunction handleGmChatMessage(conn: WorldConn, r: PacketReader): void {\n  const raw = parseChatMessage(r, true);\n  deliverMessage(conn, raw, raw.senderName ?? \"\");\n}\n\nfunction handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseNameQueryResponse(r);\n\n  const name = result.found && result.name ? result.name : \"\";\n  conn.pendingNameQueries.delete(`player:${result.guidLow}`);\n  if (result.found && result.name) {\n    conn.nameCache.set(result.guidLow, result.name);\n    for (const entity of conn.entityStore.all()) {\n      if (\n        entity.objectType === ObjectType.PLAYER &&\n        Number(entity.guid & 0xffffffffn) === result.guidLow &&\n        !entity.name\n      ) {\n        conn.entityStore.setName(entity.guid, result.name);\n      }\n    }\n    for (const friend of conn.friendStore.all()) {\n      if (\n        Number(friend.guid & 0xffffffffn) === result.guidLow &&\n        !friend.name\n      ) {\n        conn.friendStore.setName(friend.guid, result.name);\n      }\n    }\n  }\n\n  const pending = conn.pendingMessages.get(result.guidLow);\n  if (!pending) return;\n  for (const raw of pending) deliverMessage(conn, raw, name);\n  conn.pendingMessages.delete(result.guidLow);\n}\n\nfunction handleChannelNotify(conn: WorldConn, r: PacketReader): void {\n  const event = parseChannelNotify(r);\n  if (event.type === \"joined\") {\n    conn.channels.push(event.channel);\n  } else if (event.type === \"left\") {\n    const idx = conn.channels.indexOf(event.channel);\n    if (idx !== -1) conn.channels.splice(idx, 1);\n  }\n}\n\nfunction handleMotd(conn: WorldConn, r: PacketReader): void {\n  const lineCount = r.uint32LE();\n  const lines: string[] = [];\n  for (let i = 0; i < lineCount; i++) {\n    lines.push(r.cString());\n  }\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: lines.join(\"\\n\"),\n  });\n}\n\nfunction handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {\n  const name = r.cString();\n  conn.onMessage?.({\n    type: ChatType.SYSTEM,\n    sender: \"\",\n    message: `No player named \"${name}\" is currently playing.`,\n  });\n}\n\nfunction handlePartyCommandResult(conn: WorldConn, r: PacketReader): void {\n  const result = parsePartyCommandResult(r);\n  conn.onGroupEvent?.({\n    type: \"command_result\",\n    operation: result.operation,\n    target: result.member,\n    result: result.result,\n  });\n}\n\nfunction handleGroupInviteReceived(conn: WorldConn, r: PacketReader): void {\n  const invite = parseGroupInvite(r);\n  conn.onGroupEvent?.({ type: \"invite_received\", from: invite.name });\n}\n\nfunction handleGroupSetLeaderMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupSetLeader(r);\n  conn.onGroupEvent?.({ type: \"leader_changed\", name });\n}\n\nfunction handleGroupListMsg(conn: WorldConn, r: PacketReader): void {\n  const list = parseGroupList(r);\n  conn.partyMembers.clear();\n  let leaderName = \"\";\n  if (\n    conn.selfGuidLow === list.leaderGuidLow &&\n    conn.selfGuidHigh === list.leaderGuidHigh\n  ) {\n    leaderName = conn.selfName;\n  }\n  for (const m of list.members) {\n    conn.partyMembers.set(m.name, {\n      guidLow: m.guidLow,\n      guidHigh: m.guidHigh,\n    });\n    if (\n      m.guidLow === list.leaderGuidLow &&\n      m.guidHigh === list.leaderGuidHigh\n    ) {\n      leaderName = m.name;\n    }\n  }\n  conn.onGroupEvent?.({\n    type: \"group_list\",\n    members: list.members,\n    leader: leaderName,\n  });\n}\n\nfunction handleGroupDestroyed(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"group_destroyed\" });\n}\n\nfunction handleGroupUninvite(conn: WorldConn): void {\n  conn.partyMembers.clear();\n  conn.onGroupEvent?.({ type: \"kicked\" });\n}\n\nfunction handleGroupDeclineMsg(conn: WorldConn, r: PacketReader): void {\n  const { name } = parseGroupDecline(r);\n  conn.onGroupEvent?.({ type: \"invite_declined\", name });\n}\n\nfunction handleUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const entries = parseUpdateObject(r);\n  for (const entry of entries) {\n    switch (entry.type) {\n      case \"create\": {\n        const { _changed: _co, ...objFields } = extractObjectFields(\n          entry.fields,\n        );\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entry.objectType === ObjectType.UNIT ||\n          entry.objectType === ObjectType.PLAYER\n        ) {\n          const { _changed: _cu, ...rest } = extractUnitFields(entry.fields);\n          extraFields = rest;\n        } else if (entry.objectType === ObjectType.GAMEOBJECT) {\n          const { _changed: _cg, ...rest } = extractGameObjectFields(\n            entry.fields,\n          );\n          extraFields = rest;\n        }\n        const cachedName = lookupCachedName(\n          conn,\n          entry.guid,\n          entry.objectType,\n          objFields.entry,\n        );\n        conn.entityStore.create(entry.guid, entry.objectType, {\n          ...objFields,\n          ...extraFields,\n          ...(cachedName ? { name: cachedName } : {}),\n          ...(entry.position ? { position: entry.position } : {}),\n          rawFields: new Map(entry.fields),\n        } as any);\n        if (!cachedName) {\n          queryEntityName(conn, entry.guid, entry.objectType, objFields.entry);\n        }\n        break;\n      }\n      case \"values\": {\n        const entity = conn.entityStore.get(entry.guid);\n        if (!entity) break;\n        const objFields = extractObjectFields(entry.fields, entity.rawFields);\n        let extraFields: Record<string, unknown> = {};\n        if (\n          entity.objectType === ObjectType.UNIT ||\n          entity.objectType === ObjectType.PLAYER\n        ) {\n          extraFields = extractUnitFields(entry.fields, entity.rawFields);\n        } else if (entity.objectType === ObjectType.GAMEOBJECT) {\n          extraFields = extractGameObjectFields(entry.fields);\n        }\n        const allChanged = [\n          ...(objFields._changed || []),\n          ...((extraFields as any)._changed || []),\n        ];\n        const merged: Record<string, unknown> = {};\n        for (const key of allChanged) {\n          if (key in extraFields) merged[key] = (extraFields as any)[key];\n          else if (key in objFields) merged[key] = (objFields as any)[key];\n        }\n        conn.entityStore.update(entry.guid, merged);\n        for (const [k, v] of entry.fields) {\n          const existing = conn.entityStore.get(entry.guid);\n          if (existing) existing.rawFields.set(k, v);\n        }\n        break;\n      }\n      case \"movement\": {\n        conn.entityStore.setPosition(entry.guid, entry.position);\n        break;\n      }\n      case \"outOfRange\": {\n        for (const guid of entry.guids) conn.entityStore.destroy(guid);\n        break;\n      }\n      case \"nearObjects\": {\n        break;\n      }\n    }\n  }\n}\n\nfunction handleCompressedUpdateObject(conn: WorldConn, r: PacketReader): void {\n  const uncompressedSize = r.uint32LE();\n  const compressed = r.bytes(r.remaining);\n  const decompressed = inflateSync(compressed);\n  if (decompressed.length !== uncompressedSize) {\n    throw new Error(\n      `Compressed update size mismatch: expected ${uncompressedSize}, got ${decompressed.length}`,\n    );\n  }\n  handleUpdateObject(conn, new PacketReader(new Uint8Array(decompressed)));\n}\n\nfunction handleDestroyObject(conn: WorldConn, r: PacketReader): void {\n  const guid = r.uint64LE();\n  r.skip(1);\n  conn.entityStore.destroy(guid);\n}\n\nfunction lookupCachedName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): string | undefined {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    return conn.nameCache.get(guidLow);\n  }\n  if (entry === undefined) return undefined;\n  if (objectType === ObjectType.UNIT) return conn.creatureNameCache.get(entry);\n  if (objectType === ObjectType.GAMEOBJECT)\n    return conn.gameObjectNameCache.get(entry);\n  return undefined;\n}\n\nfunction queryEntityName(\n  conn: WorldConn,\n  guid: bigint,\n  objectType: number,\n  entry: number | undefined,\n): void {\n  if (objectType === ObjectType.PLAYER) {\n    const guidLow = Number(guid & 0xffffffffn);\n    const key = `player:${guidLow}`;\n    if (conn.pendingNameQueries.has(key)) return;\n    conn.pendingNameQueries.add(key);\n    const w = new PacketWriter();\n    w.uint64LE(guid);\n    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());\n    return;\n  }\n  if (entry === undefined) return;\n  const key = `${objectType}:${entry}`;\n  if (conn.pendingNameQueries.has(key)) return;\n  conn.pendingNameQueries.add(key);\n  if (objectType === ObjectType.UNIT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_CREATURE_QUERY,\n      buildCreatureQuery(entry, guid),\n    );\n    return;\n  }\n  if (objectType === ObjectType.GAMEOBJECT) {\n    sendPacket(\n      conn,\n      GameOpcode.CMSG_GAMEOBJECT_QUERY,\n      buildGameObjectQuery(entry, guid),\n    );\n    return;\n  }\n}\n\nfunction handleCreatureQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseCreatureQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.UNIT}:${result.entry}`);\n  if (!result.name) return;\n  conn.creatureNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry && !entity.name) {\n      conn.entityStore.setName(entity.guid, result.name);\n    }\n  }\n}\n\nfunction handleGameObjectQueryResponse(conn: WorldConn, r: PacketReader): void {\n  const result = parseGameObjectQueryResponse(r);\n  conn.pendingNameQueries.delete(`${ObjectType.GAMEOBJECT}:${result.entry}`);\n  if (!result.name) return;\n  conn.gameObjectNameCache.set(result.entry, result.name);\n  for (const entity of conn.entityStore.all()) {\n    if (entity.entry === result.entry) {\n      if (!entity.name) conn.entityStore.setName(entity.guid, result.name);\n      if (result.gameObjectType !== undefined) {\n        conn.entityStore.update(entity.guid, {\n          gameObjectType: result.gameObjectType,\n        });\n      }\n    }\n  }\n}\n\nfunction handlePartyMemberStatsMsg(\n  conn: WorldConn,\n  r: PacketReader,\n  isFull = false,\n): void {\n  const stats = parsePartyMemberStats(r, isFull);\n  conn.onGroupEvent?.({\n    type: \"member_stats\",\n    guidLow: stats.guidLow,\n    online: stats.online,\n    hp: stats.hp,\n    maxHp: stats.maxHp,\n    level: stats.level,\n  });\n}\n\nfunction handleContactList(conn: WorldConn, r: PacketReader): void {\n  const list = parseContactList(r);\n  const friends: FriendEntry[] = [];\n  for (const contact of list.contacts) {\n    if (!(contact.flags & SocialFlag.FRIEND)) continue;\n    const guidLow = Number(contact.guid & 0xffffffffn);\n    const name = conn.nameCache.get(guidLow) ?? \"\";\n    friends.push({\n      guid: contact.guid,\n      name,\n      note: contact.note,\n      status: contact.status ?? 0,\n      area: contact.area ?? 0,\n      level: contact.level ?? 0,\n      playerClass: contact.playerClass ?? 0,\n    });\n    if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n      conn.pendingNameQueries.add(`player:${guidLow}`);\n      sendPacket(\n        conn,\n        GameOpcode.CMSG_NAME_QUERY,\n        buildNameQuery(guidLow, Number((contact.guid >> 32n) & 0xffffffffn)),\n      );\n    }\n  }\n  conn.friendStore.set(friends);\n}\n\nfunction handleFriendStatus(conn: WorldConn, r: PacketReader): void {\n  const packet = parseFriendStatus(r);\n  const guidLow = Number(packet.guid & 0xffffffffn);\n\n  switch (packet.result) {\n    case FriendResult.ADDED_ONLINE:\n    case FriendResult.ADDED_OFFLINE: {\n      const name = conn.nameCache.get(guidLow) ?? \"\";\n      conn.friendStore.add({\n        guid: packet.guid,\n        name,\n        note: packet.note ?? \"\",\n        status: packet.status ?? 0,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      if (!name && !conn.pendingNameQueries.has(`player:${guidLow}`)) {\n        conn.pendingNameQueries.add(`player:${guidLow}`);\n        sendPacket(\n          conn,\n          GameOpcode.CMSG_NAME_QUERY,\n          buildNameQuery(guidLow, Number((packet.guid >> 32n) & 0xffffffffn)),\n        );\n      }\n      break;\n    }\n    case FriendResult.ONLINE:\n      conn.friendStore.update(packet.guid, {\n        status: packet.status ?? FriendStatus.ONLINE,\n        area: packet.area ?? 0,\n        level: packet.level ?? 0,\n        playerClass: packet.playerClass ?? 0,\n      });\n      break;\n    case FriendResult.OFFLINE:\n      conn.friendStore.update(packet.guid, { status: FriendStatus.OFFLINE });\n      break;\n    case FriendResult.REMOVED:\n      conn.friendStore.remove(packet.guid);\n      break;\n    default: {\n      const name = conn.nameCache.get(guidLow) ?? `guid:${guidLow}`;\n      conn.onFriendEvent?.({\n        type: \"friend-error\",\n        result: packet.result,\n        name,\n      });\n      break;\n    }\n  }\n}\n\nasync function authenticateWorld(\n  conn: WorldConn,\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<void> {\n  const challenge = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_CHALLENGE);\n  challenge.uint32LE();\n  const serverSeed = challenge.bytes(4);\n\n  const body = await buildWorldAuthPacket(\n    config.account,\n    auth.sessionKey,\n    serverSeed,\n    auth.realmId,\n    config.clientSeed,\n  );\n  conn.socket.write(buildOutgoingPacket(GameOpcode.CMSG_AUTH_SESSION, body));\n  conn.arc4 = new Arc4(auth.sessionKey);\n\n  const resp = await conn.dispatch.expect(GameOpcode.SMSG_AUTH_RESPONSE);\n  const status = resp.uint8();\n  if (status !== 0x0c) {\n    const names: Record<number, string> = {\n      0x0d: \"system error\",\n      0x15: \"account in use\",\n    };\n    const label = names[status] ?? `status 0x${status.toString(16)}`;\n    throw new Error(`World auth failed: ${label}`);\n  }\n}\n\nasync function selectCharacter(\n  conn: WorldConn,\n  config: ClientConfig,\n): Promise<void> {\n  sendPacket(conn, GameOpcode.CMSG_CHAR_ENUM);\n\n  const enumReader = await conn.dispatch.expect(GameOpcode.SMSG_CHAR_ENUM);\n  const chars = parseCharacterList(enumReader);\n  const char = chars.find(\n    (c) => c.name.toLowerCase() === config.character.toLowerCase(),\n  );\n  if (!char) {\n    throw new Error(\n      `Character \"${config.character}\" not found. Available: ${chars.map((c) => c.name).join(\", \")}`,\n    );\n  }\n\n  conn.selfName = char.name;\n  conn.selfGuidLow = char.guidLow;\n  conn.selfGuidHigh = char.guidHigh;\n\n  const w = new PacketWriter();\n  w.uint32LE(char.guidLow);\n  w.uint32LE(char.guidHigh);\n  sendPacket(conn, GameOpcode.CMSG_PLAYER_LOGIN, w.finish());\n\n  await conn.dispatch.expect(GameOpcode.SMSG_LOGIN_VERIFY_WORLD);\n}\n\nfunction startPingLoop(\n  conn: WorldConn,\n  intervalMs: number,\n): ReturnType<typeof setInterval> {\n  return setInterval(() => {\n    const w = new PacketWriter();\n    w.uint32LE(0);\n    w.uint32LE(0);\n    sendPacket(conn, GameOpcode.CMSG_PING, w.finish());\n  }, intervalMs);\n}\n\nexport function worldSession(\n  config: ClientConfig,\n  auth: AuthResult,\n): Promise<WorldHandle> {\n  return new Promise((resolve, reject) => {\n    const conn: WorldConn = {\n      socket: undefined!,\n      dispatch: new OpcodeDispatch(),\n      buf: new AccumulatorBuffer(),\n      startTime: Date.now(),\n      nameCache: new Map(),\n      pendingMessages: new Map(),\n      channels: [],\n      lastChatMode: { type: \"say\" },\n      selfName: \"\",\n      selfGuidLow: 0,\n      selfGuidHigh: 0,\n      partyMembers: new Map(),\n      entityStore: new EntityStore(),\n      creatureNameCache: new Map(),\n      gameObjectNameCache: new Map(),\n      pendingNameQueries: new Set(),\n      friendStore: new FriendStore(),\n    };\n    conn.entityStore.onEvent((event) => conn.onEntityEvent?.(event));\n    conn.friendStore.onEvent((event) => conn.onFriendEvent?.(event));\n\n    let pingInterval: ReturnType<typeof setInterval>;\n    let done = false;\n    let closedResolve: () => void;\n    const closed = new Promise<void>((r) => {\n      closedResolve = r;\n    });\n\n    conn.dispatch.on(GameOpcode.SMSG_TIME_SYNC_REQ, (r) =>\n      handleTimeSync(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>\n      handleChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>\n      handleGmChatMessage(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>\n      handleNameQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_MOTD, (r) => handleMotd(conn, r));\n    conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>\n      handlePlayerNotFound(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CHANNEL_NOTIFY, (r) =>\n      handleChannelNotify(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_COMMAND_RESULT, (r) =>\n      handlePartyCommandResult(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_INVITE, (r) =>\n      handleGroupInviteReceived(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_SET_LEADER, (r) =>\n      handleGroupSetLeaderMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_LIST, (r) =>\n      handleGroupListMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DESTROYED, () =>\n      handleGroupDestroyed(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_UNINVITE, () =>\n      handleGroupUninvite(conn),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GROUP_DECLINE, (r) =>\n      handleGroupDeclineMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS, (r) =>\n      handlePartyMemberStatsMsg(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, (r) =>\n      handlePartyMemberStatsMsg(conn, r, true),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_UPDATE_OBJECT, (r) =>\n      handleUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, (r) =>\n      handleCompressedUpdateObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_DESTROY_OBJECT, (r) =>\n      handleDestroyObject(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_CREATURE_QUERY_RESPONSE, (r) =>\n      handleCreatureQueryResponse(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, (r) =>\n      handleGameObjectQueryResponse(conn, r),\n    );\n\n    conn.dispatch.on(GameOpcode.SMSG_CONTACT_LIST, (r) =>\n      handleContactList(conn, r),\n    );\n    conn.dispatch.on(GameOpcode.SMSG_FRIEND_STATUS, (r) =>\n      handleFriendStatus(conn, r),\n    );\n\n    registerStubs(conn.dispatch, (msg) => {\n      if (!conn.onMessage) return false;\n      conn.onMessage({\n        type: ChatType.SYSTEM,\n        sender: \"\",\n        message: msg,\n      });\n      return true;\n    });\n\n    async function login() {\n      await authenticateWorld(conn, config, auth);\n      await selectCharacter(conn, config);\n      pingInterval = startPingLoop(conn, config.pingIntervalMs ?? 30_000);\n      const lang = config.language ?? Language.COMMON;\n      done = true;\n      const handle: WorldHandle = {\n        closed,\n        close() {\n          clearInterval(pingInterval);\n          conn.onEntityEvent = undefined;\n          conn.onFriendEvent = undefined;\n          conn.socket.end();\n        },\n        onMessage(cb) {\n          conn.onMessage = cb;\n        },\n        sendWhisper(target, message) {\n          if (target) conn.lastChatMode = { type: \"whisper\", target };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.WHISPER, lang, message, target),\n          );\n        },\n        sendSay(message) {\n          conn.lastChatMode = { type: \"say\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.SAY, lang, message),\n          );\n        },\n        sendYell(message) {\n          conn.lastChatMode = { type: \"yell\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.YELL, lang, message),\n          );\n        },\n        sendGuild(message) {\n          conn.lastChatMode = { type: \"guild\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.GUILD, lang, message),\n          );\n        },\n        sendParty(message) {\n          conn.lastChatMode = { type: \"party\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.PARTY, lang, message),\n          );\n        },\n        sendRaid(message) {\n          conn.lastChatMode = { type: \"raid\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.RAID, lang, message),\n          );\n        },\n        sendEmote(message) {\n          conn.lastChatMode = { type: \"emote\" };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.EMOTE, lang, message),\n          );\n        },\n        sendChannel(channel, message) {\n          conn.lastChatMode = { type: \"channel\", channel };\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_MESSAGE_CHAT,\n            buildChatMessage(ChatType.CHANNEL, lang, message, channel),\n          );\n        },\n        getChannel(index) {\n          return conn.channels[index - 1];\n        },\n        async who(opts = {}) {\n          sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));\n          const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);\n          return parseWhoResponse(r);\n        },\n        getLastChatMode() {\n          return conn.lastChatMode;\n        },\n        setLastChatMode(mode) {\n          conn.lastChatMode = mode;\n        },\n        sendInCurrentMode(message) {\n          const mode = conn.lastChatMode;\n          switch (mode.type) {\n            case \"say\":\n              handle.sendSay(message);\n              break;\n            case \"yell\":\n              handle.sendYell(message);\n              break;\n            case \"guild\":\n              handle.sendGuild(message);\n              break;\n            case \"party\":\n              handle.sendParty(message);\n              break;\n            case \"raid\":\n              handle.sendRaid(message);\n              break;\n            case \"whisper\":\n              handle.sendWhisper(mode.target, message);\n              break;\n            case \"channel\":\n              handle.sendChannel(mode.channel, message);\n              break;\n          }\n        },\n        invite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_INVITE,\n            buildGroupInvite(name),\n          );\n        },\n        uninvite(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_UNINVITE,\n            buildGroupUninvite(name),\n          );\n        },\n        leaveGroup() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DISBAND, buildGroupDisband());\n        },\n        setLeader(name) {\n          const member = conn.partyMembers.get(name);\n          if (!member) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not in your party.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_GROUP_SET_LEADER,\n            buildGroupSetLeader(member.guidLow, member.guidHigh),\n          );\n        },\n        acceptInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_ACCEPT, buildGroupAccept());\n        },\n        declineInvite() {\n          sendPacket(conn, GameOpcode.CMSG_GROUP_DECLINE, buildGroupDecline());\n        },\n        onGroupEvent(cb) {\n          conn.onGroupEvent = cb;\n        },\n        onEntityEvent(cb) {\n          conn.onEntityEvent = cb;\n        },\n        onPacketError(cb) {\n          conn.onPacketError = cb;\n        },\n        getNearbyEntities() {\n          return conn.entityStore.all();\n        },\n        getFriends() {\n          return conn.friendStore.all();\n        },\n        addFriend(name) {\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_ADD_FRIEND,\n            buildAddFriend(name, \"\"),\n          );\n        },\n        removeFriend(name) {\n          const friend = conn.friendStore.findByName(name);\n          if (!friend) {\n            conn.onMessage?.({\n              type: ChatType.SYSTEM,\n              sender: \"\",\n              message: `\"${name}\" is not on your friends list.`,\n            });\n            return;\n          }\n          sendPacket(\n            conn,\n            GameOpcode.CMSG_DEL_FRIEND,\n            buildDelFriend(friend.guid),\n          );\n        },\n        onFriendEvent(cb) {\n          conn.onFriendEvent = cb;\n        },\n      };\n      resolve(handle);\n    }\n\n    login().catch((err) => {\n      done = true;\n      clearInterval(pingInterval);\n      reject(err);\n      conn.socket?.end();\n    });\n\n    Bun.connect({\n      hostname: auth.realmHost,\n      port: auth.realmPort,\n      socket: {\n        open(s) {\n          conn.socket = s;\n        },\n        data(_s, data) {\n          conn.buf.append(new Uint8Array(data));\n          drainWorldPackets(conn);\n        },\n        close() {\n          clearInterval(pingInterval);\n          conn.entityStore.clear();\n          if (!done) reject(new Error(\"World connection closed\"));\n          closedResolve();\n        },\n      },\n    }).catch(reject);\n  });\n}\n","structuredPatch":[{"oldStart":1194,"oldLines":6,"newStart":1194,"newLines":9,"lines":["             case \"raid\":","               handle.sendRaid(message);","               break;","+            case \"emote\":","+              handle.sendEmote(message);","+              break;","             case \"whisper\":","               handle.sendWhisper(mode.target, message);","               break;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d6b8c7e3-0513-4648-bd77-d79c0cab7bad"}
{"parentUuid":"09bda1b0-afb8-45df-874a-104794fd8ec0","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01QzEnesWtBBL7R1QdpR1zNy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GMie8B5fhen5rXircvoLi8","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"in_progress","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1130,"cache_read_input_tokens":74277,"output_tokens":311,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1130,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMT7xU8QrDM6hsb3d6t","type":"assistant","uuid":"f5c97943-5f58-4397-b9ac-33c487c12c9b","timestamp":"2026-02-28T23:42:41.880Z"}
{"parentUuid":"f5c97943-5f58-4397-b9ac-33c487c12c9b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GMie8B5fhen5rXircvoLi8","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"54e0e336-f248-42da-b6b0-1bd770c351e1","timestamp":"2026-02-28T23:42:41.881Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"in_progress","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"pending","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"in_progress","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"f5c97943-5f58-4397-b9ac-33c487c12c9b"}
{"parentUuid":"54e0e336-f248-42da-b6b0-1bd770c351e1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"text","text":"Now wire emote through `commands.ts` — add to `IpcCommand` union, `parseIpcCommand`, and `dispatchCommand`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"f661d1e7-ba0d-49b4-8d17-118ce7b4a43b","timestamp":"2026-02-28T23:42:45.023Z"}
{"parentUuid":"f661d1e7-ba0d-49b4-8d17-118ce7b4a43b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PifHVhHt28H2g5wXVqrdVA","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }","new_string":"  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"dfb8bd22-e1ec-407d-9100-a03dfeb83350","timestamp":"2026-02-28T23:42:46.750Z"}
{"parentUuid":"dfb8bd22-e1ec-407d-9100-a03dfeb83350","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PifHVhHt28H2g5wXVqrdVA","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.ts has been updated successfully."}]},"uuid":"e49b74b4-61f6-4d0d-850e-b689b93dfa16","timestamp":"2026-02-28T23:42:46.769Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","oldString":"  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }","newString":"  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }","originalFile":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","structuredPatch":[{"oldStart":37,"oldLines":6,"newStart":37,"newLines":7,"lines":["   | { type: \"yell\"; message: string }","   | { type: \"guild\"; message: string }","   | { type: \"party\"; message: string }","+  | { type: \"emote\"; message: string }","   | { type: \"whisper\"; target: string; message: string }","   | { type: \"read\" }","   | { type: \"read_json\" }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"dfb8bd22-e1ec-407d-9100-a03dfeb83350"}
{"parentUuid":"e49b74b4-61f6-4d0d-850e-b689b93dfa16","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TzuHJp7ZhRS59wAxuDpY3S","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n        return parsed;\n      case \"whisper\":","new_string":"      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n      case \"emote\":\n        return parsed;\n      case \"whisper\":"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"3bcc6995-3b51-42b3-ba58-0a35542bb0a5","timestamp":"2026-02-28T23:42:48.509Z"}
{"parentUuid":"3bcc6995-3b51-42b3-ba58-0a35542bb0a5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TzuHJp7ZhRS59wAxuDpY3S","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.ts has been updated successfully."}]},"uuid":"9f346265-98b4-4a9e-8d25-868886aee1dc","timestamp":"2026-02-28T23:42:48.517Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","oldString":"      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n        return parsed;\n      case \"whisper\":","newString":"      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n      case \"emote\":\n        return parsed;\n      case \"whisper\":","originalFile":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","structuredPatch":[{"oldStart":69,"oldLines":6,"newStart":69,"newLines":7,"lines":["       case \"yell\":","       case \"guild\":","       case \"party\":","+      case \"emote\":","         return parsed;","       case \"whisper\":","         return parsed;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3bcc6995-3b51-42b3-ba58-0a35542bb0a5"}
{"parentUuid":"9f346265-98b4-4a9e-8d25-868886aee1dc","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013pzrZtdhkQBdZsZ537nzBp","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };","new_string":"    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n    case \"EMOTE\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\" | \"emote\",\n        message: rest,\n      };"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"a9aa1e9b-4af4-462a-9e05-3b874ba087d8","timestamp":"2026-02-28T23:42:50.669Z"}
{"parentUuid":"a9aa1e9b-4af4-462a-9e05-3b874ba087d8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013pzrZtdhkQBdZsZ537nzBp","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.ts has been updated successfully."}]},"uuid":"f22edeb6-53cf-47cc-bf74-c433bfd9bd24","timestamp":"2026-02-28T23:42:50.686Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","oldString":"    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };","newString":"    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n    case \"EMOTE\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\" | \"emote\",\n        message: rest,\n      };","originalFile":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n      case \"emote\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n      return {\n        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","structuredPatch":[{"oldStart":106,"oldLines":8,"newStart":106,"newLines":9,"lines":["     case \"YELL\":","     case \"GUILD\":","     case \"PARTY\":","+    case \"EMOTE\":","       return {","-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",","+        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\" | \"emote\",","         message: rest,","       };","     case \"WHISPER\": {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a9aa1e9b-4af4-462a-9e05-3b874ba087d8"}
{"parentUuid":"f22edeb6-53cf-47cc-bf74-c433bfd9bd24","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CmNpUcc3Cyn8U4BWqDrnGt","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };","new_string":"    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"c6700575-be82-4eac-925d-a1ca8998fc33","timestamp":"2026-02-28T23:42:53.671Z"}
{"parentUuid":"c6700575-be82-4eac-925d-a1ca8998fc33","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01CmNpUcc3Cyn8U4BWqDrnGt"}]},"uuid":"ec012351-9f35-4381-a5d5-acb01e072a76","timestamp":"2026-02-28T23:42:53.671Z","toolUseResult":"Error: File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.","sourceToolAssistantUUID":"c6700575-be82-4eac-925d-a1ca8998fc33"}
{"parentUuid":"ec012351-9f35-4381-a5d5-acb01e072a76","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DbCAqKYYEhozAHnBGjNZrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012n64tcqH8bEoaztNTDECzR","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":","new_string":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"emote\":\n      handle.sendEmote(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":75407,"output_tokens":1196,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":353,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMTfNLZKZ8agzBiSBVs","type":"assistant","uuid":"14f61f3a-fbfb-4d79-a70b-d0a71d1d06a5","timestamp":"2026-02-28T23:42:55.630Z"}
{"parentUuid":"14f61f3a-fbfb-4d79-a70b-d0a71d1d06a5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_012n64tcqH8bEoaztNTDECzR"}]},"uuid":"6f552469-663a-44f8-8969-d4777c37842f","timestamp":"2026-02-28T23:42:55.631Z","toolUseResult":"Error: File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.","sourceToolAssistantUUID":"14f61f3a-fbfb-4d79-a70b-d0a71d1d06a5"}
{"parentUuid":"6f552469-663a-44f8-8969-d4777c37842f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FSbHqv7cCTVm6Unrp4CcyE","type":"message","role":"assistant","content":[{"type":"text","text":"Formatter reformatted the file. Let me re-read and apply the remaining edits."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1801,"cache_read_input_tokens":75760,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1801},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMUg3oJY58dNjQ8gHnT","type":"assistant","uuid":"df73f092-4fa4-4dbb-b0fe-1fb5d9061cd8","timestamp":"2026-02-28T23:42:59.160Z"}
{"parentUuid":"df73f092-4fa4-4dbb-b0fe-1fb5d9061cd8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FSbHqv7cCTVm6Unrp4CcyE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F9VLtmdgCQALXNHzNde7Qi","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","offset":170,"limit":30},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1801,"cache_read_input_tokens":75760,"output_tokens":126,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1801,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMUg3oJY58dNjQ8gHnT","type":"assistant","uuid":"47705082-1ffd-44ab-a09c-e2b799e9fe2a","timestamp":"2026-02-28T23:42:59.848Z"}
{"parentUuid":"47705082-1ffd-44ab-a09c-e2b799e9fe2a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F9VLtmdgCQALXNHzNde7Qi","type":"tool_result","content":"   170→      return { type: \"friends_json\" };\n   171→    case \"ADD_FRIEND\":\n   172→      return rest ? { type: \"add_friend\", target: rest } : undefined;\n   173→    case \"DEL_FRIEND\":\n   174→      return rest ? { type: \"del_friend\", target: rest } : undefined;\n   175→    case \"IGNORE\":\n   176→      return { type: \"unimplemented\", feature: \"Ignore list\" };\n   177→    case \"JOIN\":\n   178→      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n   179→    case \"GINVITE\":\n   180→    case \"GKICK\":\n   181→    case \"GLEAVE\":\n   182→    case \"GPROMOTE\":\n   183→      return { type: \"unimplemented\", feature: \"Guild management\" };\n   184→    case \"MAIL\":\n   185→      return { type: \"unimplemented\", feature: \"Mail\" };\n   186→    case \"ROLL\":\n   187→      return { type: \"unimplemented\", feature: \"Random roll\" };\n   188→    case \"DND\":\n   189→    case \"AFK\":\n   190→      return { type: \"unimplemented\", feature: \"Player status\" };\n   191→    case \"EMOTE\":\n   192→      return { type: \"unimplemented\", feature: \"Text emotes\" };\n   193→    default:\n   194→      return line ? { type: \"chat\", message: line } : undefined;\n   195→  }\n   196→}\n   197→\n   198→export function writeLines(socket: IpcSocket, lines: string[]): void {\n   199→  for (const line of lines) socket.write(line + \"\\n\");"}]},"uuid":"48895c97-caca-44ba-90d2-6a54024d2128","timestamp":"2026-02-28T23:42:59.850Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","content":"      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");","numLines":30,"startLine":170,"totalLines":526}},"sourceToolAssistantUUID":"47705082-1ffd-44ab-a09c-e2b799e9fe2a"}
{"parentUuid":"48895c97-caca-44ba-90d2-6a54024d2128","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01M4kiQYg6jDNCB12W2yt18K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q8awAV91TPGBSk1iXrDCFx","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:","new_string":"    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    default:"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":583,"cache_read_input_tokens":77561,"output_tokens":224,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":583,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMUz9DxeyfjENJ6XHnR","type":"assistant","uuid":"d34bbfc3-715b-4d08-b091-a66d6c1a6b25","timestamp":"2026-02-28T23:43:04.007Z"}
{"parentUuid":"d34bbfc3-715b-4d08-b091-a66d6c1a6b25","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q8awAV91TPGBSk1iXrDCFx","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.ts has been updated successfully."}]},"uuid":"5ee2543c-5b87-40b2-8fd3-5ab86f0d309a","timestamp":"2026-02-28T23:43:04.031Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","oldString":"    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:","newString":"    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    default:","originalFile":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n      case \"emote\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n    case \"EMOTE\":\n      return {\n        type: verb.toLowerCase() as\n          | \"say\"\n          | \"yell\"\n          | \"guild\"\n          | \"party\"\n          | \"emote\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    case \"EMOTE\":\n      return { type: \"unimplemented\", feature: \"Text emotes\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","structuredPatch":[{"oldStart":188,"oldLines":8,"newStart":188,"newLines":6,"lines":["     case \"DND\":","     case \"AFK\":","       return { type: \"unimplemented\", feature: \"Player status\" };","-    case \"EMOTE\":","-      return { type: \"unimplemented\", feature: \"Text emotes\" };","     default:","       return line ? { type: \"chat\", message: line } : undefined;","   }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d34bbfc3-715b-4d08-b091-a66d6c1a6b25"}
{"parentUuid":"5ee2543c-5b87-40b2-8fd3-5ab86f0d309a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_014zYavKmMYiybFTTGVaz5fm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JC6qUJrT9MSZvcq9subHTg","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","offset":245,"limit":20},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":261,"cache_read_input_tokens":78144,"output_tokens":105,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":261,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMVJZVt1AUSiRFrahgR","type":"assistant","uuid":"14ba3bfd-713f-46be-910e-8b0f1e98839b","timestamp":"2026-02-28T23:43:07.262Z"}
{"parentUuid":"14ba3bfd-713f-46be-910e-8b0f1e98839b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JC6qUJrT9MSZvcq9subHTg","type":"tool_result","content":"   245→      writeLines(socket, [\"OK\"]);\n   246→      return false;\n   247→    case \"guild\":\n   248→      handle.sendGuild(cmd.message);\n   249→      writeLines(socket, [\"OK\"]);\n   250→      return false;\n   251→    case \"party\":\n   252→      handle.sendParty(cmd.message);\n   253→      writeLines(socket, [\"OK\"]);\n   254→      return false;\n   255→    case \"whisper\":\n   256→      handle.sendWhisper(cmd.target, cmd.message);\n   257→      writeLines(socket, [\"OK\"]);\n   258→      return false;\n   259→    case \"read\":\n   260→      writeLines(socket, drainText(events));\n   261→      return false;\n   262→    case \"read_json\":\n   263→      writeLines(socket, drainJson(events));\n   264→      return false;"}]},"uuid":"db364899-4d4e-422a-922f-44bee6284d59","timestamp":"2026-02-28T23:43:07.264Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","content":"      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;","numLines":20,"startLine":245,"totalLines":524}},"sourceToolAssistantUUID":"14ba3bfd-713f-46be-910e-8b0f1e98839b"}
{"parentUuid":"db364899-4d4e-422a-922f-44bee6284d59","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_012FtvN5bAsh2hs3665vMXsv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016pnzWwkY5VTV9nhtYe1iZf","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","old_string":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":","new_string":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"emote\":\n      handle.sendEmote(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":574,"cache_read_input_tokens":78405,"output_tokens":241,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":574,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMVXmzF1s2DB3uXduQ6","type":"assistant","uuid":"85c178c8-2bc4-45d5-906b-961288fbe587","timestamp":"2026-02-28T23:43:11.207Z"}
{"parentUuid":"85c178c8-2bc4-45d5-906b-961288fbe587","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016pnzWwkY5VTV9nhtYe1iZf","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.ts has been updated successfully."}]},"uuid":"967b98d2-07d1-4290-8fe0-a3f3f6731606","timestamp":"2026-02-28T23:43:11.216Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.ts","oldString":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":","newString":"    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"emote\":\n      handle.sendEmote(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":","originalFile":"import { RingBuffer } from \"lib/ring-buffer\";\nimport {\n  formatMessage,\n  formatMessageObj,\n  formatWhoResults,\n  formatWhoResultsJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  parseCommand,\n} from \"ui/tui\";\nimport type { FriendEvent } from \"wow/friend-store\";\nimport { SessionLog, type LogEntry } from \"lib/session-log\";\nimport type { WorldHandle, ChatMessage, GroupEvent } from \"wow/client\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  Entity,\n  UnitEntity,\n  GameObjectEntity,\n  EntityEvent,\n} from \"wow/entity-store\";\n\nexport type EventEntry = { text: string | undefined; json: string };\n\nexport type IpcSocket = {\n  write(data: string | Uint8Array): number;\n  end(): void;\n};\n\nexport type IpcCommand =\n  | { type: \"chat\"; message: string }\n  | { type: \"say\"; message: string }\n  | { type: \"yell\"; message: string }\n  | { type: \"guild\"; message: string }\n  | { type: \"party\"; message: string }\n  | { type: \"emote\"; message: string }\n  | { type: \"whisper\"; target: string; message: string }\n  | { type: \"read\" }\n  | { type: \"read_json\" }\n  | { type: \"read_wait\"; ms: number }\n  | { type: \"read_wait_json\"; ms: number }\n  | { type: \"stop\" }\n  | { type: \"status\" }\n  | { type: \"who\"; filter?: string }\n  | { type: \"who_json\"; filter?: string }\n  | { type: \"invite\"; target: string }\n  | { type: \"kick\"; target: string }\n  | { type: \"leave\" }\n  | { type: \"leader\"; target: string }\n  | { type: \"accept\" }\n  | { type: \"decline\" }\n  | { type: \"nearby\" }\n  | { type: \"nearby_json\" }\n  | { type: \"friends\" }\n  | { type: \"friends_json\" }\n  | { type: \"add_friend\"; target: string }\n  | { type: \"del_friend\"; target: string }\n  | { type: \"unimplemented\"; feature: string };\n\nexport function parseIpcCommand(line: string): IpcCommand | undefined {\n  if (line.startsWith(\"/\")) {\n    const parsed = parseCommand(line);\n    switch (parsed.type) {\n      case \"say\":\n      case \"yell\":\n      case \"guild\":\n      case \"party\":\n      case \"emote\":\n        return parsed;\n      case \"whisper\":\n        return parsed;\n      case \"who\":\n        return parsed.target\n          ? { type: \"who\", filter: parsed.target }\n          : { type: \"who\" };\n      case \"invite\":\n      case \"kick\":\n      case \"leave\":\n      case \"leader\":\n      case \"accept\":\n      case \"decline\":\n        return parsed;\n      case \"friends\":\n        return { type: \"friends\" };\n      case \"add-friend\":\n        return { type: \"add_friend\", target: parsed.target };\n      case \"remove-friend\":\n        return { type: \"del_friend\", target: parsed.target };\n      case \"unimplemented\":\n        return parsed;\n      default:\n        return { type: \"say\", message: line };\n    }\n  }\n\n  const spaceIdx = line.indexOf(\" \");\n  const verb = spaceIdx === -1 ? line : line.slice(0, spaceIdx);\n  const rest = spaceIdx === -1 ? \"\" : line.slice(spaceIdx + 1);\n\n  switch (verb) {\n    case \"SAY\":\n    case \"YELL\":\n    case \"GUILD\":\n    case \"PARTY\":\n    case \"EMOTE\":\n      return {\n        type: verb.toLowerCase() as\n          | \"say\"\n          | \"yell\"\n          | \"guild\"\n          | \"party\"\n          | \"emote\",\n        message: rest,\n      };\n    case \"WHISPER\": {\n      const targetEnd = rest.indexOf(\" \");\n      if (targetEnd === -1)\n        return { type: \"whisper\", target: rest, message: \"\" };\n      return {\n        type: \"whisper\",\n        target: rest.slice(0, targetEnd),\n        message: rest.slice(targetEnd + 1),\n      };\n    }\n    case \"READ\":\n      return { type: \"read\" };\n    case \"READ_JSON\":\n      return { type: \"read_json\" };\n    case \"READ_WAIT\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait\", ms: Math.min(ms, 60_000) };\n    }\n    case \"READ_WAIT_JSON\": {\n      const ms = parseInt(rest, 10);\n      if (!Number.isFinite(ms) || ms < 0) return undefined;\n      return { type: \"read_wait_json\", ms: Math.min(ms, 60_000) };\n    }\n    case \"STOP\":\n      return { type: \"stop\" };\n    case \"STATUS\":\n      return { type: \"status\" };\n    case \"WHO\":\n      return rest ? { type: \"who\", filter: rest } : { type: \"who\" };\n    case \"WHO_JSON\":\n      return rest ? { type: \"who_json\", filter: rest } : { type: \"who_json\" };\n    case \"INVITE\":\n      return rest ? { type: \"invite\", target: rest } : undefined;\n    case \"KICK\":\n      return rest ? { type: \"kick\", target: rest } : undefined;\n    case \"LEAVE\":\n      return { type: \"leave\" };\n    case \"LEADER\":\n      return rest ? { type: \"leader\", target: rest } : undefined;\n    case \"ACCEPT\":\n      return { type: \"accept\" };\n    case \"DECLINE\":\n      return { type: \"decline\" };\n    case \"NEARBY\":\n      return { type: \"nearby\" };\n    case \"NEARBY_JSON\":\n      return { type: \"nearby_json\" };\n    case \"FRIENDS\":\n      return { type: \"friends\" };\n    case \"FRIENDS_JSON\":\n      return { type: \"friends_json\" };\n    case \"ADD_FRIEND\":\n      return rest ? { type: \"add_friend\", target: rest } : undefined;\n    case \"DEL_FRIEND\":\n      return rest ? { type: \"del_friend\", target: rest } : undefined;\n    case \"IGNORE\":\n      return { type: \"unimplemented\", feature: \"Ignore list\" };\n    case \"JOIN\":\n      return { type: \"unimplemented\", feature: \"Channel join/leave\" };\n    case \"GINVITE\":\n    case \"GKICK\":\n    case \"GLEAVE\":\n    case \"GPROMOTE\":\n      return { type: \"unimplemented\", feature: \"Guild management\" };\n    case \"MAIL\":\n      return { type: \"unimplemented\", feature: \"Mail\" };\n    case \"ROLL\":\n      return { type: \"unimplemented\", feature: \"Random roll\" };\n    case \"DND\":\n    case \"AFK\":\n      return { type: \"unimplemented\", feature: \"Player status\" };\n    default:\n      return line ? { type: \"chat\", message: line } : undefined;\n  }\n}\n\nexport function writeLines(socket: IpcSocket, lines: string[]): void {\n  for (const line of lines) socket.write(line + \"\\n\");\n  socket.write(\"\\n\");\n}\n\nfunction drainText(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction drainJson(events: RingBuffer<EventEntry>): string[] {\n  return events.drain().map((e) => e.json);\n}\n\nfunction sliceText(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events\n    .slice(from)\n    .flatMap((e) => (e.text !== undefined ? [e.text] : []));\n}\n\nfunction sliceJson(events: RingBuffer<EventEntry>, from: number): string[] {\n  return events.slice(from).map((e) => e.json);\n}\n\nexport async function dispatchCommand(\n  cmd: IpcCommand,\n  handle: WorldHandle,\n  events: RingBuffer<EventEntry>,\n  socket: IpcSocket,\n  cleanup: () => void,\n): Promise<boolean> {\n  switch (cmd.type) {\n    case \"chat\": {\n      handle.sendInCurrentMode(cmd.message);\n      const mode = handle.getLastChatMode();\n      const label =\n        mode.type === \"whisper\"\n          ? `WHISPER ${mode.target}`\n          : mode.type === \"channel\"\n            ? `CHANNEL ${mode.channel}`\n            : mode.type.toUpperCase();\n      writeLines(socket, [`OK ${label}`]);\n      return false;\n    }\n    case \"say\":\n      handle.sendSay(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"yell\":\n      handle.sendYell(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"guild\":\n      handle.sendGuild(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"party\":\n      handle.sendParty(cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"whisper\":\n      handle.sendWhisper(cmd.target, cmd.message);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"read\":\n      writeLines(socket, drainText(events));\n      return false;\n    case \"read_json\":\n      writeLines(socket, drainJson(events));\n      return false;\n    case \"read_wait\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceText(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"read_wait_json\": {\n      const start = events.writePos;\n      await new Promise<void>((resolve) => {\n        setTimeout(() => {\n          writeLines(socket, sliceJson(events, start));\n          resolve();\n        }, cmd.ms);\n      });\n      return false;\n    }\n    case \"stop\":\n      writeLines(socket, [\"OK\"]);\n      cleanup();\n      return true;\n    case \"status\":\n      writeLines(socket, [\"CONNECTED\"]);\n      return false;\n    case \"who\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, formatWhoResults(results).split(\"\\n\"));\n      return false;\n    }\n    case \"who_json\": {\n      const results = await handle.who(cmd.filter ? { name: cmd.filter } : {});\n      writeLines(socket, [formatWhoResultsJson(results)]);\n      return false;\n    }\n    case \"invite\":\n      handle.invite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"kick\":\n      handle.uninvite(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leave\":\n      handle.leaveGroup();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"leader\":\n      handle.setLeader(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"accept\":\n      handle.acceptInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"decline\":\n      handle.declineInvite();\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"nearby\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(socket, entities.map(formatNearbyLine));\n      return false;\n    }\n    case \"nearby_json\": {\n      const entities = handle.getNearbyEntities();\n      writeLines(\n        socket,\n        entities.map((e) => JSON.stringify(formatNearbyObj(e))),\n      );\n      return false;\n    }\n    case \"friends\": {\n      const friends = handle.getFriends();\n      writeLines(socket, formatFriendList(friends).split(\"\\n\"));\n      return false;\n    }\n    case \"friends_json\": {\n      const friends = handle.getFriends();\n      writeLines(socket, [formatFriendListJson(friends)]);\n      return false;\n    }\n    case \"add_friend\":\n      handle.addFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"del_friend\":\n      handle.removeFriend(cmd.target);\n      writeLines(socket, [\"OK\"]);\n      return false;\n    case \"unimplemented\":\n      writeLines(socket, [`UNIMPLEMENTED ${cmd.feature}`]);\n      return false;\n  }\n}\n\nfunction objectTypeName(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"NPC\";\n    case ObjectType.PLAYER:\n      return \"Player\";\n    default:\n      return `type ${type}`;\n  }\n}\n\nfunction formatNearbyLine(entity: Entity): string {\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    const name = entity.name ?? \"Unknown\";\n    const kind = objectTypeName(entity.objectType);\n    const level = unit.level > 0 ? `, level ${unit.level}` : \"\";\n    const hp = `HP ${unit.health}/${unit.maxHealth}`;\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (${kind}${level}) ${hp}${pos}`;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    const name = entity.name ?? \"Unknown\";\n    const pos = entity.position\n      ? ` at ${entity.position.x.toFixed(2)}, ${entity.position.y.toFixed(2)}, ${entity.position.z.toFixed(2)}`\n      : \"\";\n    return `${name} (GameObject)${pos}`;\n  }\n  return `Entity 0x${entity.guid.toString(16)} (${objectTypeName(entity.objectType)})`;\n}\n\nfunction objectTypeString(type: ObjectType): string {\n  switch (type) {\n    case ObjectType.UNIT:\n      return \"unit\";\n    case ObjectType.PLAYER:\n      return \"player\";\n    case ObjectType.GAMEOBJECT:\n      return \"gameobject\";\n    default:\n      return \"object\";\n  }\n}\n\nfunction formatNearbyObj(entity: Entity): Record<string, unknown> {\n  const obj: Record<string, unknown> = {\n    guid: `0x${entity.guid.toString(16)}`,\n    type: objectTypeString(entity.objectType),\n    name: entity.name,\n  };\n  if (\n    entity.objectType === ObjectType.UNIT ||\n    entity.objectType === ObjectType.PLAYER\n  ) {\n    const unit = entity as UnitEntity;\n    obj[\"level\"] = unit.level;\n    obj[\"health\"] = unit.health;\n    obj[\"maxHealth\"] = unit.maxHealth;\n  }\n  if (entity.objectType === ObjectType.GAMEOBJECT) {\n    obj[\"gameObjectType\"] = (entity as GameObjectEntity).gameObjectType;\n  }\n  if (entity.position) {\n    obj[\"x\"] = entity.position.x;\n    obj[\"y\"] = entity.position.y;\n    obj[\"z\"] = entity.position.z;\n  }\n  return obj;\n}\n\nfunction formatGroupEventObj(event: GroupEvent): Record<string, unknown> {\n  switch (event.type) {\n    case \"invite_received\":\n      return { type: \"GROUP_INVITE\", from: event.from };\n    case \"command_result\":\n      return {\n        type: \"GROUP_COMMAND_RESULT\",\n        operation: event.operation,\n        target: event.target,\n        result: event.result,\n      };\n    case \"leader_changed\":\n      return { type: \"GROUP_LEADER_CHANGED\", name: event.name };\n    case \"group_destroyed\":\n      return { type: \"GROUP_DESTROYED\" };\n    case \"kicked\":\n      return { type: \"GROUP_KICKED\" };\n    case \"invite_declined\":\n      return { type: \"GROUP_INVITE_DECLINED\", name: event.name };\n    case \"group_list\":\n      return {\n        type: \"GROUP_LIST\",\n        members: event.members.map((m) => ({\n          name: m.name,\n          online: m.online,\n        })),\n        leader: event.leader,\n      };\n    case \"member_stats\":\n      return {\n        type: \"PARTY_MEMBER_STATS\",\n        guidLow: event.guidLow,\n        online: event.online,\n        hp: event.hp,\n        maxHp: event.maxHp,\n        level: event.level,\n      };\n  }\n}\n\nexport function onGroupEvent(\n  event: GroupEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatGroupEvent(event);\n  const obj = formatGroupEventObj(event);\n  events.push({ text, json: JSON.stringify(obj) });\n  log.append(obj as LogEntry).catch(() => {});\n}\n\nexport function onChatMessage(\n  msg: ChatMessage,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const obj = formatMessageObj(msg);\n  events.push({ text: formatMessage(msg), json: JSON.stringify(obj) });\n  log.append(obj).catch(() => {});\n}\n\nexport function onEntityEvent(\n  event: EntityEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatEntityEvent(event);\n  const obj = formatEntityEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n\nexport function onFriendEvent(\n  event: FriendEvent,\n  events: RingBuffer<EventEntry>,\n  log: SessionLog,\n): void {\n  const text = formatFriendEvent(event);\n  const obj = formatFriendEventObj(event);\n  if (obj) {\n    events.push({ text, json: JSON.stringify(obj) });\n    log.append(obj as LogEntry).catch(() => {});\n  }\n}\n","structuredPatch":[{"oldStart":252,"oldLines":6,"newStart":252,"newLines":10,"lines":["       handle.sendParty(cmd.message);","       writeLines(socket, [\"OK\"]);","       return false;","+    case \"emote\":","+      handle.sendEmote(cmd.message);","+      writeLines(socket, [\"OK\"]);","+      return false;","     case \"whisper\":","       handle.sendWhisper(cmd.target, cmd.message);","       writeLines(socket, [\"OK\"]);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"85c178c8-2bc4-45d5-906b-961288fbe587"}
{"parentUuid":"967b98d2-07d1-4290-8fe0-a3f3f6731606","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01MztixGSbRvBYUsAis8zVXX","type":"message","role":"assistant","content":[{"type":"text","text":"Now update both mock handles."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":278,"cache_read_input_tokens":78979,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":278},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMVqHhQtmCueYC4kBrJ","type":"assistant","uuid":"f16834db-7caa-4c88-a944-10f7b15dfef6","timestamp":"2026-02-28T23:43:14.013Z"}
{"parentUuid":"f16834db-7caa-4c88-a944-10f7b15dfef6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01MztixGSbRvBYUsAis8zVXX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NnYxzgZMaTxcfnQef4x62W","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/test/mock-handle.ts","old_string":"    sendRaid: jest.fn(),\n    sendChannel: jest.fn(),","new_string":"    sendRaid: jest.fn(),\n    sendEmote: jest.fn(),\n    sendChannel: jest.fn(),"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":278,"cache_read_input_tokens":78979,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":278},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMVqHhQtmCueYC4kBrJ","type":"assistant","uuid":"237c85b2-727d-4b38-8c1e-4055f8f45f8a","timestamp":"2026-02-28T23:43:15.430Z"}
{"parentUuid":"237c85b2-727d-4b38-8c1e-4055f8f45f8a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NnYxzgZMaTxcfnQef4x62W","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/test/mock-handle.ts has been updated successfully."}]},"uuid":"e7c6c2a7-568d-4eb8-a894-bd6e0c77741d","timestamp":"2026-02-28T23:43:15.449Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/test/mock-handle.ts","oldString":"    sendRaid: jest.fn(),\n    sendChannel: jest.fn(),","newString":"    sendRaid: jest.fn(),\n    sendEmote: jest.fn(),\n    sendChannel: jest.fn(),","originalFile":"import { jest } from \"bun:test\";\nimport type {\n  WorldHandle,\n  ChatMessage,\n  ChatMode,\n  GroupEvent,\n} from \"wow/client\";\nimport type { Entity, EntityEvent } from \"wow/entity-store\";\nimport type { FriendEntry, FriendEvent } from \"wow/friend-store\";\n\nexport function createMockHandle(): WorldHandle & {\n  triggerMessage(msg: ChatMessage): void;\n  triggerGroupEvent(event: GroupEvent): void;\n  triggerEntityEvent(event: EntityEvent): void;\n  triggerFriendEvent(event: FriendEvent): void;\n  resolveClosed(): void;\n} {\n  let messageCb: ((msg: ChatMessage) => void) | undefined;\n  let groupEventCb: ((event: GroupEvent) => void) | undefined;\n  let entityEventCb: ((event: EntityEvent) => void) | undefined;\n  let friendEventCb: ((event: FriendEvent) => void) | undefined;\n  let closeResolve: () => void;\n  const closed = new Promise<void>((r) => {\n    closeResolve = r;\n  });\n  let lastChatMode: ChatMode = { type: \"say\" };\n\n  return {\n    closed,\n    close: jest.fn(() => closeResolve()),\n    onMessage(cb) {\n      messageCb = cb;\n    },\n    sendWhisper: jest.fn(),\n    sendSay: jest.fn(),\n    sendYell: jest.fn(),\n    sendGuild: jest.fn(),\n    sendParty: jest.fn(),\n    sendRaid: jest.fn(),\n    sendChannel: jest.fn(),\n    getChannel: jest.fn(),\n    who: jest.fn(async () => []),\n    getLastChatMode: jest.fn(() => lastChatMode),\n    setLastChatMode: jest.fn((mode: ChatMode) => {\n      lastChatMode = mode;\n    }),\n    sendInCurrentMode: jest.fn(),\n    invite: jest.fn(),\n    uninvite: jest.fn(),\n    leaveGroup: jest.fn(),\n    setLeader: jest.fn(),\n    acceptInvite: jest.fn(),\n    declineInvite: jest.fn(),\n    onGroupEvent(cb) {\n      groupEventCb = cb;\n    },\n    onEntityEvent(cb) {\n      entityEventCb = cb;\n    },\n    onPacketError: jest.fn(),\n    getNearbyEntities: jest.fn((): Entity[] => []),\n    getFriends: jest.fn((): FriendEntry[] => []),\n    addFriend: jest.fn(),\n    removeFriend: jest.fn(),\n    onFriendEvent(cb) {\n      friendEventCb = cb;\n    },\n    triggerMessage(msg) {\n      messageCb?.(msg);\n    },\n    triggerGroupEvent(event) {\n      groupEventCb?.(event);\n    },\n    triggerEntityEvent(event) {\n      entityEventCb?.(event);\n    },\n    triggerFriendEvent(event) {\n      friendEventCb?.(event);\n    },\n    resolveClosed() {\n      closeResolve();\n    },\n  };\n}\n","structuredPatch":[{"oldStart":37,"oldLines":6,"newStart":37,"newLines":7,"lines":["     sendGuild: jest.fn(),","     sendParty: jest.fn(),","     sendRaid: jest.fn(),","+    sendEmote: jest.fn(),","     sendChannel: jest.fn(),","     getChannel: jest.fn(),","     who: jest.fn(async () => []),"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"237c85b2-727d-4b38-8c1e-4055f8f45f8a"}
{"parentUuid":"e7c6c2a7-568d-4eb8-a894-bd6e0c77741d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01MztixGSbRvBYUsAis8zVXX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NjcTLCNRMA7rBeCvptq5nh","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/start.test.ts","old_string":"        sendRaid: jest.fn(),\n        sendWhisper: jest.fn(),","new_string":"        sendRaid: jest.fn(),\n        sendEmote: jest.fn(),\n        sendWhisper: jest.fn(),"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":278,"cache_read_input_tokens":78979,"output_tokens":342,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":278,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMVqHhQtmCueYC4kBrJ","type":"assistant","uuid":"de01de73-9deb-444c-9f84-ae771eb8c707","timestamp":"2026-02-28T23:43:16.731Z"}
{"parentUuid":"de01de73-9deb-444c-9f84-ae771eb8c707","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NjcTLCNRMA7rBeCvptq5nh","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/start.test.ts has been updated successfully."}]},"uuid":"85411f60-caf2-4bc3-98a9-9823fb07a95d","timestamp":"2026-02-28T23:43:16.752Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/start.test.ts","oldString":"        sendRaid: jest.fn(),\n        sendWhisper: jest.fn(),","newString":"        sendRaid: jest.fn(),\n        sendEmote: jest.fn(),\n        sendWhisper: jest.fn(),","originalFile":"import { mock, jest, test, expect, describe, afterEach } from \"bun:test\";\nimport { access, rm, mkdir, unlink } from \"node:fs/promises\";\nimport { serializeConfig } from \"lib/config\";\nimport type { AuthResult, WorldHandle } from \"wow/client\";\nimport { sendToSocket } from \"cli/ipc\";\n\nconst tmpDir = `./tmp/daemon-start-${Date.now()}`;\nconst cfgDir = `${tmpDir}/config/tuicraft`;\nconst uid = process.getuid?.() ?? 0;\nconst rtDir = `${tmpDir}/tuicraft-${uid}`;\nconst stDir = `${tmpDir}/state/tuicraft`;\n\nmock.module(\"lib/paths\", () => ({\n  configDir: () => cfgDir,\n  runtimeDir: () => rtDir,\n  stateDir: () => stDir,\n  socketPath: () => `${rtDir}/sock`,\n  pidPath: () => `${rtDir}/pid`,\n  configPath: () => `${cfgDir}/config.toml`,\n  logPath: () => `${stDir}/session.log`,\n}));\n\nlet closedResolve: () => void;\n\nfunction makeMockClient(): {\n  authHandshake: ReturnType<typeof jest.fn>;\n  worldSession: ReturnType<typeof jest.fn>;\n  mockHandleClose: ReturnType<typeof jest.fn>;\n} {\n  const mockHandleClose = jest.fn();\n  const closed = new Promise<void>((r) => {\n    closedResolve = r;\n  });\n  return {\n    authHandshake: jest.fn(\n      async (): Promise<AuthResult> => ({\n        sessionKey: new Uint8Array(40),\n        realmHost: \"localhost\",\n        realmPort: 8085,\n        realmId: 1,\n      }),\n    ),\n    worldSession: jest.fn(\n      async (): Promise<WorldHandle> => ({\n        closed,\n        close: mockHandleClose,\n        onMessage: jest.fn(),\n        sendSay: jest.fn(),\n        sendYell: jest.fn(),\n        sendGuild: jest.fn(),\n        sendParty: jest.fn(),\n        sendRaid: jest.fn(),\n        sendWhisper: jest.fn(),\n        sendChannel: jest.fn(),\n        getChannel: jest.fn(),\n        who: jest.fn(async () => []),\n        getLastChatMode: jest.fn(() => ({ type: \"say\" as const })),\n        setLastChatMode: jest.fn(),\n        sendInCurrentMode: jest.fn(),\n        invite: jest.fn(),\n        uninvite: jest.fn(),\n        leaveGroup: jest.fn(),\n        setLeader: jest.fn(),\n        acceptInvite: jest.fn(),\n        declineInvite: jest.fn(),\n        onGroupEvent: jest.fn(),\n        onEntityEvent: jest.fn(),\n        onPacketError: jest.fn(),\n        getNearbyEntities: jest.fn(() => []),\n        getFriends: jest.fn(() => []),\n        addFriend: jest.fn(),\n        removeFriend: jest.fn(),\n        onFriendEvent: jest.fn(),\n      }),\n    ),\n    mockHandleClose,\n  };\n}\n\nconst { startDaemon } = await import(\"daemon/server\");\n\nconst exitSpy = jest\n  .spyOn(process, \"exit\")\n  .mockImplementation(() => undefined as never);\n\nconst signalListeners: Array<{\n  event: string;\n  fn: (...args: unknown[]) => void;\n}> = [];\nconst origOn = process.on.bind(process);\nprocess.on = ((event: string, fn: (...args: unknown[]) => void) => {\n  if (event === \"SIGTERM\" || event === \"SIGINT\") {\n    signalListeners.push({ event, fn });\n  }\n  return origOn(event, fn);\n}) as typeof process.on;\n\nasync function writeTestConfig(): Promise<void> {\n  await mkdir(cfgDir, { recursive: true });\n  await Bun.write(\n    `${cfgDir}/config.toml`,\n    serializeConfig({\n      account: \"TEST\",\n      password: \"TEST\",\n      character: \"Testchar\",\n      host: \"localhost\",\n      port: 3724,\n      language: 1,\n      timeout_minutes: 1,\n    }) + \"\\n\",\n  );\n}\n\nasync function waitForSetup(): Promise<void> {\n  for (let i = 0; i < 100; i++) {\n    try {\n      await access(`${rtDir}/sock`);\n      return;\n    } catch {\n      await Bun.sleep(1);\n    }\n  }\n  throw new Error(\"setup never completed\");\n}\n\nafterEach(async () => {\n  exitSpy.mockClear();\n  for (const { event, fn } of signalListeners) {\n    process.removeListener(event, fn);\n  }\n  signalListeners.length = 0;\n  await rm(tmpDir, { recursive: true, force: true });\n});\n\ndescribe(\"startDaemon\", () => {\n  test(\"creates pid file and socket, cleans up on closed\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    const pidContent = await Bun.file(`${rtDir}/pid`).text();\n    expect(pidContent).toBe(String(process.pid));\n\n    closedResolve();\n    await promise;\n\n    await Bun.sleep(1);\n    expect(await Bun.file(`${rtDir}/pid`).exists()).toBe(false);\n  });\n\n  test(\"idle timeout triggers process.exit\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const capturedCallbacks: Array<() => void> = [];\n    const realSetInterval = globalThis.setInterval;\n    const intervalSpy = jest\n      .spyOn(globalThis, \"setInterval\")\n      .mockImplementation(\n        (fn: (...args: unknown[]) => void, ..._rest: unknown[]) => {\n          capturedCallbacks.push(fn as () => void);\n          return realSetInterval(() => {}, 999_999) as ReturnType<\n            typeof setInterval\n          >;\n        },\n      );\n\n    try {\n      const promise = startDaemon(client);\n      await waitForSetup();\n\n      expect(capturedCallbacks).toHaveLength(1);\n\n      const origDateNow = Date.now;\n      const frozenTime = origDateNow() + 120_000;\n      Date.now = () => frozenTime;\n      try {\n        capturedCallbacks[0]!();\n      } finally {\n        Date.now = origDateNow;\n      }\n\n      expect(exitSpy).toHaveBeenCalledWith(0);\n\n      closedResolve();\n      await promise;\n    } finally {\n      intervalSpy.mockRestore();\n    }\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    closedResolve();\n    await promise;\n\n    expect(client.mockHandleClose).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"registers SIGTERM and SIGINT handlers\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    const events = signalListeners.map((l) => l.event);\n    expect(events).toContain(\"SIGTERM\");\n    expect(events).toContain(\"SIGINT\");\n\n    closedResolve();\n    await promise;\n  });\n\n  test(\"updates activity timestamp from IPC activity\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    const lines = await sendToSocket(\"STATUS\", `${rtDir}/sock`);\n    expect(lines).toEqual([\"CONNECTED\"]);\n\n    closedResolve();\n    await promise;\n  });\n\n  test(\"cleanup tolerates missing pid file\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    await unlink(`${rtDir}/pid`);\n    closedResolve();\n    await promise;\n    expect(client.mockHandleClose).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP cleans up pid file before exit\", async () => {\n    await writeTestConfig();\n    const client = makeMockClient();\n    const promise = startDaemon(client);\n    await waitForSetup();\n\n    const lines = await sendToSocket(\"STOP\", `${rtDir}/sock`);\n    expect(lines).toEqual([\"OK\"]);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n\n    for (let i = 0; i < 50; i++) {\n      if (!(await Bun.file(`${rtDir}/pid`).exists())) break;\n      await Bun.sleep(1);\n    }\n    expect(await Bun.file(`${rtDir}/pid`).exists()).toBe(false);\n\n    closedResolve();\n    await promise;\n  });\n});\n","structuredPatch":[{"oldStart":50,"oldLines":6,"newStart":50,"newLines":7,"lines":["         sendGuild: jest.fn(),","         sendParty: jest.fn(),","         sendRaid: jest.fn(),","+        sendEmote: jest.fn(),","         sendWhisper: jest.fn(),","         sendChannel: jest.fn(),","         getChannel: jest.fn(),"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"de01de73-9deb-444c-9f84-ae771eb8c707"}
{"parentUuid":"85411f60-caf2-4bc3-98a9-9823fb07a95d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Mdq4v7TVsrWEBa8ihZj56p","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019KfPBKtnocbBC1zg4YFzB6","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"in_progress","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":455,"cache_read_input_tokens":79257,"output_tokens":311,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":455,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMWEtmQTjthmDwPv4sQ","type":"assistant","uuid":"c0e0ca37-3fc0-48d5-af8a-8481fa781b4b","timestamp":"2026-02-28T23:43:22.096Z"}
{"parentUuid":"c0e0ca37-3fc0-48d5-af8a-8481fa781b4b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019KfPBKtnocbBC1zg4YFzB6","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"02938f1c-81eb-48bc-b198-ff590e7d67db","timestamp":"2026-02-28T23:43:22.097Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"in_progress","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"pending","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"pending","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"in_progress","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"c0e0ca37-3fc0-48d5-af8a-8481fa781b4b"}
{"parentUuid":"02938f1c-81eb-48bc-b198-ff590e7d67db","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SUkJKdyKBiyNYpjsEUhENZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add tests. Let me check existing test patterns to mirror them exactly."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":79712,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMWdHQmjJBS9uvuv3bU","type":"assistant","uuid":"73510e27-38e9-4809-9c9c-43b85054b7bd","timestamp":"2026-02-28T23:43:26.165Z"}
{"parentUuid":"73510e27-38e9-4809-9c9c-43b85054b7bd","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SUkJKdyKBiyNYpjsEUhENZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RkEJd9qC3jbnCSJG1SQFyC","name":"Grep","input":{"pattern":"sendSay|sendYell|/say|/yell","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":79712,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMWdHQmjJBS9uvuv3bU","type":"assistant","uuid":"03581113-45db-446b-967b-f5f8061db8e8","timestamp":"2026-02-28T23:43:27.710Z"}
{"parentUuid":"03581113-45db-446b-967b-f5f8061db8e8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RkEJd9qC3jbnCSJG1SQFyC","type":"tool_result","content":"39-    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42:  test(\"/say sends say\", () => {\n43:    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n45-      message: \"hello there\",\n46-    });\n--\n437-    await done;\n438-  });\n439-\n440:  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n441-    const handle = createMockHandle();\n442-    const input = new PassThrough();\n443-\n444-    const done = startTui(handle, false, { input, write: () => {} });\n445:    writeLine(input, \"/say hello\");\n446-    await flush();\n447-\n448:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n449-    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n450-\n451-    input.end();\n--\n463-    writeLine(input, \"/raid pull now\");\n464-    await flush();\n465-\n466:    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n467-    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n468-    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n469-    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");"}]},"uuid":"3b691b81-62f2-4d60-9251-5718f766d7db","timestamp":"2026-02-28T23:43:27.791Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"39-    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42:  test(\"/say sends say\", () => {\n43:    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n45-      message: \"hello there\",\n46-    });\n--\n437-    await done;\n438-  });\n439-\n440:  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n441-    const handle = createMockHandle();\n442-    const input = new PassThrough();\n443-\n444-    const done = startTui(handle, false, { input, write: () => {} });\n445:    writeLine(input, \"/say hello\");\n446-    await flush();\n447-\n448:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n449-    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n450-\n451-    input.end();\n--\n463-    writeLine(input, \"/raid pull now\");\n464-    await flush();\n465-\n466:    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n467-    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n468-    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n469-    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");","numLines":32},"sourceToolAssistantUUID":"03581113-45db-446b-967b-f5f8061db8e8"}
{"parentUuid":"3b691b81-62f2-4d60-9251-5718f766d7db","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SUkJKdyKBiyNYpjsEUhENZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EwToxKMynTJZrfKRpWSwc9","name":"Grep","input":{"pattern":"sendSay|sendYell|say.*echo|yell.*echo","path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":79712,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":353},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMWdHQmjJBS9uvuv3bU","type":"assistant","uuid":"7404adf0-5593-4535-aef9-e2ad9230a38f","timestamp":"2026-02-28T23:43:28.708Z"}
{"parentUuid":"7404adf0-5593-4535-aef9-e2ad9230a38f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EwToxKMynTJZrfKRpWSwc9","type":"tool_result","content":"53-  srpPrivateKey: clientPrivateKey,\n54-  clientSeed,\n55-};\n56-\n57-async function waitForEchoProbe(\n58:  handle: Pick<WorldHandle, \"onMessage\" | \"sendSay\">,\n59-): Promise<void> {\n60-  const received = new Promise<ChatMessage>((resolve) => {\n61-    handle.onMessage(resolve);\n62-  });\n63:  handle.sendSay(\"probe\");\n64-  await received;\n65-}\n66-\n67-function waitForGroupEvents(\n68-  handle: Pick<WorldHandle, \"onGroupEvent\">,\n--\n670-    } finally {\n671-      ws.stop();\n672-    }\n673-  });\n674-\n675:  test(\"sendSay sends message and receives echo\", async () => {\n676-    const ws = await startMockWorldServer();\n677-    try {\n678-      const handle = await worldSession(\n679-        { ...base, host: \"127.0.0.1\", port: ws.port },\n680-        fakeAuth(ws.port),\n681-      );\n682-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n683:      handle.sendSay(\"test say\");\n684-      const msg = await received;\n685-      expect(msg.type).toBe(ChatType.SAY);\n686-      expect(msg.message).toBe(\"test say\");\n687-      handle.close();\n688-      await handle.closed;\n689-    } finally {\n690-      ws.stop();\n691-    }\n692-  });\n693-\n694:  test(\"sendYell sends message and receives echo\", async () => {\n695-    const ws = await startMockWorldServer();\n696-    try {\n697-      const handle = await worldSession(\n698-        { ...base, host: \"127.0.0.1\", port: ws.port },\n699-        fakeAuth(ws.port),\n700-      );\n701-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n702:      handle.sendYell(\"test yell\");\n703-      const msg = await received;\n704-      expect(msg.type).toBe(ChatType.YELL);\n705-      expect(msg.message).toBe(\"test yell\");\n706-      handle.close();\n707-      await handle.closed;\n--\n794-        { ...base, host: \"127.0.0.1\", port: ws.port },\n795-        fakeAuth(ws.port),\n796-      );\n797-\n798-      const first = new Promise<ChatMessage>((r) => handle.onMessage(r));\n799:      handle.sendSay(\"first\");\n800-      await first;\n801-\n802-      const second = new Promise<ChatMessage>((r) => handle.onMessage(r));\n803:      handle.sendSay(\"second\");\n804-      const msg = await second;\n805-      expect(msg.sender).toBe(FIXTURE_CHARACTER);\n806-      expect(msg.message).toBe(\"second\");\n807-\n808-      handle.close();\n--\n826-          messages.push(msg);\n827-          if (messages.length === 2) resolve();\n828-        });\n829-      });\n830-\n831:      handle.sendSay(\"msg1\");\n832:      handle.sendSay(\"msg2\");\n833-      await gotTwo;\n834-\n835-      expect(messages[0]!.message).toBe(\"msg1\");\n836-      expect(messages[1]!.message).toBe(\"msg2\");\n837-"}]},"uuid":"db25efdd-2e96-44fb-b033-274899588887","timestamp":"2026-02-28T23:43:28.790Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"53-  srpPrivateKey: clientPrivateKey,\n54-  clientSeed,\n55-};\n56-\n57-async function waitForEchoProbe(\n58:  handle: Pick<WorldHandle, \"onMessage\" | \"sendSay\">,\n59-): Promise<void> {\n60-  const received = new Promise<ChatMessage>((resolve) => {\n61-    handle.onMessage(resolve);\n62-  });\n63:  handle.sendSay(\"probe\");\n64-  await received;\n65-}\n66-\n67-function waitForGroupEvents(\n68-  handle: Pick<WorldHandle, \"onGroupEvent\">,\n--\n670-    } finally {\n671-      ws.stop();\n672-    }\n673-  });\n674-\n675:  test(\"sendSay sends message and receives echo\", async () => {\n676-    const ws = await startMockWorldServer();\n677-    try {\n678-      const handle = await worldSession(\n679-        { ...base, host: \"127.0.0.1\", port: ws.port },\n680-        fakeAuth(ws.port),\n681-      );\n682-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n683:      handle.sendSay(\"test say\");\n684-      const msg = await received;\n685-      expect(msg.type).toBe(ChatType.SAY);\n686-      expect(msg.message).toBe(\"test say\");\n687-      handle.close();\n688-      await handle.closed;\n689-    } finally {\n690-      ws.stop();\n691-    }\n692-  });\n693-\n694:  test(\"sendYell sends message and receives echo\", async () => {\n695-    const ws = await startMockWorldServer();\n696-    try {\n697-      const handle = await worldSession(\n698-        { ...base, host: \"127.0.0.1\", port: ws.port },\n699-        fakeAuth(ws.port),\n700-      );\n701-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n702:      handle.sendYell(\"test yell\");\n703-      const msg = await received;\n704-      expect(msg.type).toBe(ChatType.YELL);\n705-      expect(msg.message).toBe(\"test yell\");\n706-      handle.close();\n707-      await handle.closed;\n--\n794-        { ...base, host: \"127.0.0.1\", port: ws.port },\n795-        fakeAuth(ws.port),\n796-      );\n797-\n798-      const first = new Promise<ChatMessage>((r) => handle.onMessage(r));\n799:      handle.sendSay(\"first\");\n800-      await first;\n801-\n802-      const second = new Promise<ChatMessage>((r) => handle.onMessage(r));\n803:      handle.sendSay(\"second\");\n804-      const msg = await second;\n805-      expect(msg.sender).toBe(FIXTURE_CHARACTER);\n806-      expect(msg.message).toBe(\"second\");\n807-\n808-      handle.close();\n--\n826-          messages.push(msg);\n827-          if (messages.length === 2) resolve();\n828-        });\n829-      });\n830-\n831:      handle.sendSay(\"msg1\");\n832:      handle.sendSay(\"msg2\");\n833-      await gotTwo;\n834-\n835-      expect(messages[0]!.message).toBe(\"msg1\");\n836-      expect(messages[1]!.message).toBe(\"msg2\");\n837-","numLines":84},"sourceToolAssistantUUID":"7404adf0-5593-4535-aef9-e2ad9230a38f"}
{"parentUuid":"db25efdd-2e96-44fb-b033-274899588887","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SUkJKdyKBiyNYpjsEUhENZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dh7y47zXomVYNhmMwyKEAm","name":"Grep","input":{"pattern":"sendSay|sendYell|SAY|YELL","path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":353,"cache_read_input_tokens":79712,"output_tokens":405,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":353,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMWdHQmjJBS9uvuv3bU","type":"assistant","uuid":"fa989595-c02e-4c24-a760-2620f3bed03e","timestamp":"2026-02-28T23:43:29.650Z"}
{"parentUuid":"fa989595-c02e-4c24-a760-2620f3bed03e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dh7y47zXomVYNhmMwyKEAm","type":"tool_result","content":"44-    },\n45-  };\n46-}\n47-\n48-describe(\"parseIpcCommand\", () => {\n49:  test(\"SAY\", () => {\n50:    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n51-      type: \"say\",\n52-      message: \"hello world\",\n53-    });\n54-  });\n55-\n56:  test(\"YELL\", () => {\n57:    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n58-      type: \"yell\",\n59-      message: \"hey everyone\",\n60-    });\n61-  });\n62-\n--\n392-    });\n393-  });\n394-});\n395-\n396-describe(\"dispatchCommand\", () => {\n397:  test(\"say calls sendSay and writes OK\", async () => {\n398-    const handle = createMockHandle();\n399-    const events = new RingBuffer<EventEntry>(10);\n400-    const socket = createMockSocket();\n401-    const cleanup = jest.fn();\n402-\n--\n407-      socket,\n408-      cleanup,\n409-    );\n410-\n411-    expect(result).toBe(false);\n412:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n413-    expect(socket.written()).toBe(\"OK\\n\\n\");\n414-  });\n415-\n416:  test(\"yell calls sendYell and writes OK\", async () => {\n417-    const handle = createMockHandle();\n418-    const events = new RingBuffer<EventEntry>(10);\n419-    const socket = createMockSocket();\n420-    const cleanup = jest.fn();\n421-\n--\n425-      events,\n426-      socket,\n427-      cleanup,\n428-    );\n429-\n430:    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n431-    expect(socket.written()).toBe(\"OK\\n\\n\");\n432-  });\n433-\n434-  test(\"guild calls sendGuild and writes OK\", async () => {\n435-    const handle = createMockHandle();\n--\n486-  });\n487-\n488-  test(\"read drains ring buffer text\", async () => {\n489-    const handle = createMockHandle();\n490-    const events = new RingBuffer<EventEntry>(10);\n491:    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n492:    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n493-    const socket = createMockSocket();\n494-    const cleanup = jest.fn();\n495-\n496-    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n497-\n--\n524-        socket,\n525-        cleanup,\n526-      );\n527-\n528-      expect(socket.written()).toBe(\"\");\n529:      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n530-      jest.advanceTimersByTime(1000);\n531-      await promise;\n532-      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n533-    } finally {\n534-      jest.useRealTimers();\n--\n538-  test(\"read_wait returns only events arriving during wait window\", async () => {\n539-    jest.useFakeTimers();\n540-    try {\n541-      const handle = createMockHandle();\n542-      const events = new RingBuffer<EventEntry>(10);\n543:      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n544-      const socket = createMockSocket();\n545-      const cleanup = jest.fn();\n546-\n547-      const promise = dispatchCommand(\n548-        { type: \"read_wait\", ms: 1000 },\n--\n550-        events,\n551-        socket,\n552-        cleanup,\n553-      );\n554-\n555:      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n556-      jest.advanceTimersByTime(1000);\n557-      await promise;\n558-      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n559-      expect(events.drain()).toEqual([\n560:        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n561:        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n562-      ]);\n563-    } finally {\n564-      jest.useRealTimers();\n565-    }\n566-  });\n--\n639-  test(\"read_json drains ring buffer json\", async () => {\n640-    const handle = createMockHandle();\n641-    const events = new RingBuffer<EventEntry>(10);\n642-    events.push({\n643-      text: \"[say] Alice: hi\",\n644:      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n645-    });\n646-    const socket = createMockSocket();\n647-    const cleanup = jest.fn();\n648-\n649-    await dispatchCommand(\n--\n653-      socket,\n654-      cleanup,\n655-    );\n656-\n657-    expect(socket.written()).toBe(\n658:      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n659-    );\n660-  });\n661-\n662-  test(\"read_wait_json delays then returns window events\", async () => {\n663-    jest.useFakeTimers();\n--\n674-        socket,\n675-        cleanup,\n676-      );\n677-\n678-      expect(socket.written()).toBe(\"\");\n679:      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n680-      jest.advanceTimersByTime(500);\n681-      await promise;\n682:      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n683-    } finally {\n684-      jest.useRealTimers();\n685-    }\n686-  });\n687-\n--\n1194-      cleanup,\n1195-    );\n1196-\n1197-    expect(result).toBe(false);\n1198-    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n1199:    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n1200-  });\n1201-\n1202-  test(\"chat mode label includes whisper target\", async () => {\n1203-    const handle = createMockHandle();\n1204-    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n--\n1262-    const log: SessionLog = {\n1263-      append: jest.fn(() => Promise.resolve()),\n1264-    } as unknown as SessionLog;\n1265-\n1266-    onChatMessage(\n1267:      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n1268-      events,\n1269-      log,\n1270-    );\n1271-\n1272-    const drained = events.drain();\n1273-    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n1274-    expect(JSON.parse(drained[0]!.json)).toEqual({\n1275:      type: \"SAY\",\n1276-      sender: \"Alice\",\n1277-      message: \"hi\",\n1278-    });\n1279-  });\n1280-\n--\n1652-    startTestServer();\n1653-    const lines = await sendToSocket(\"STATUS\", sockPath);\n1654-    expect(lines).toEqual([\"CONNECTED\"]);\n1655-  });\n1656-\n1657:  test(\"SAY returns OK and calls handle\", async () => {\n1658-    startTestServer();\n1659:    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n1660-    expect(lines).toEqual([\"OK\"]);\n1661:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n1662-  });\n1663-\n1664-  test(\"WHISPER returns OK\", async () => {\n1665-    startTestServer();\n1666-    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n--\n1668-    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n1669-  });\n1670-\n1671-  test(\"READ returns buffered events\", async () => {\n1672-    startTestServer();\n1673:    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n1674:    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n1675-    const lines = await sendToSocket(\"READ\", sockPath);\n1676-    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n1677-  });\n1678-\n1679-  test(\"bare text sends via sticky mode\", async () => {\n--\n1818-  });\n1819-\n1820-  test(\"onMessage wiring pushes to ring buffer\", async () => {\n1821-    startTestServer();\n1822-    handle.triggerMessage({\n1823:      type: ChatType.SAY,\n1824-      sender: \"Alice\",\n1825-      message: \"hi\",\n1826-    });\n1827-    const lines = await sendToSocket(\"READ\", sockPath);\n1828-    expect(lines).toEqual([\"[say] Alice: hi\"]);"}]},"uuid":"4bd49bc2-d0aa-4b90-9599-0ff602beeec1","timestamp":"2026-02-28T23:43:29.729Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"44-    },\n45-  };\n46-}\n47-\n48-describe(\"parseIpcCommand\", () => {\n49:  test(\"SAY\", () => {\n50:    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n51-      type: \"say\",\n52-      message: \"hello world\",\n53-    });\n54-  });\n55-\n56:  test(\"YELL\", () => {\n57:    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n58-      type: \"yell\",\n59-      message: \"hey everyone\",\n60-    });\n61-  });\n62-\n--\n392-    });\n393-  });\n394-});\n395-\n396-describe(\"dispatchCommand\", () => {\n397:  test(\"say calls sendSay and writes OK\", async () => {\n398-    const handle = createMockHandle();\n399-    const events = new RingBuffer<EventEntry>(10);\n400-    const socket = createMockSocket();\n401-    const cleanup = jest.fn();\n402-\n--\n407-      socket,\n408-      cleanup,\n409-    );\n410-\n411-    expect(result).toBe(false);\n412:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n413-    expect(socket.written()).toBe(\"OK\\n\\n\");\n414-  });\n415-\n416:  test(\"yell calls sendYell and writes OK\", async () => {\n417-    const handle = createMockHandle();\n418-    const events = new RingBuffer<EventEntry>(10);\n419-    const socket = createMockSocket();\n420-    const cleanup = jest.fn();\n421-\n--\n425-      events,\n426-      socket,\n427-      cleanup,\n428-    );\n429-\n430:    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n431-    expect(socket.written()).toBe(\"OK\\n\\n\");\n432-  });\n433-\n434-  test(\"guild calls sendGuild and writes OK\", async () => {\n435-    const handle = createMockHandle();\n--\n486-  });\n487-\n488-  test(\"read drains ring buffer text\", async () => {\n489-    const handle = createMockHandle();\n490-    const events = new RingBuffer<EventEntry>(10);\n491:    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n492:    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n493-    const socket = createMockSocket();\n494-    const cleanup = jest.fn();\n495-\n496-    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n497-\n--\n524-        socket,\n525-        cleanup,\n526-      );\n527-\n528-      expect(socket.written()).toBe(\"\");\n529:      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n530-      jest.advanceTimersByTime(1000);\n531-      await promise;\n532-      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n533-    } finally {\n534-      jest.useRealTimers();\n--\n538-  test(\"read_wait returns only events arriving during wait window\", async () => {\n539-    jest.useFakeTimers();\n540-    try {\n541-      const handle = createMockHandle();\n542-      const events = new RingBuffer<EventEntry>(10);\n543:      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n544-      const socket = createMockSocket();\n545-      const cleanup = jest.fn();\n546-\n547-      const promise = dispatchCommand(\n548-        { type: \"read_wait\", ms: 1000 },\n--\n550-        events,\n551-        socket,\n552-        cleanup,\n553-      );\n554-\n555:      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n556-      jest.advanceTimersByTime(1000);\n557-      await promise;\n558-      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n559-      expect(events.drain()).toEqual([\n560:        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n561:        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n562-      ]);\n563-    } finally {\n564-      jest.useRealTimers();\n565-    }\n566-  });\n--\n639-  test(\"read_json drains ring buffer json\", async () => {\n640-    const handle = createMockHandle();\n641-    const events = new RingBuffer<EventEntry>(10);\n642-    events.push({\n643-      text: \"[say] Alice: hi\",\n644:      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n645-    });\n646-    const socket = createMockSocket();\n647-    const cleanup = jest.fn();\n648-\n649-    await dispatchCommand(\n--\n653-      socket,\n654-      cleanup,\n655-    );\n656-\n657-    expect(socket.written()).toBe(\n658:      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n659-    );\n660-  });\n661-\n662-  test(\"read_wait_json delays then returns window events\", async () => {\n663-    jest.useFakeTimers();\n--\n674-        socket,\n675-        cleanup,\n676-      );\n677-\n678-      expect(socket.written()).toBe(\"\");\n679:      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n680-      jest.advanceTimersByTime(500);\n681-      await promise;\n682:      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n683-    } finally {\n684-      jest.useRealTimers();\n685-    }\n686-  });\n687-\n--\n1194-      cleanup,\n1195-    );\n1196-\n1197-    expect(result).toBe(false);\n1198-    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n1199:    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n1200-  });\n1201-\n1202-  test(\"chat mode label includes whisper target\", async () => {\n1203-    const handle = createMockHandle();\n1204-    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n--\n1262-    const log: SessionLog = {\n1263-      append: jest.fn(() => Promise.resolve()),\n1264-    } as unknown as SessionLog;\n1265-\n1266-    onChatMessage(\n1267:      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n1268-      events,\n1269-      log,\n1270-    );\n1271-\n1272-    const drained = events.drain();\n1273-    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n1274-    expect(JSON.parse(drained[0]!.json)).toEqual({\n1275:      type: \"SAY\",\n1276-      sender: \"Alice\",\n1277-      message: \"hi\",\n1278-    });\n1279-  });\n1280-\n--\n1652-    startTestServer();\n1653-    const lines = await sendToSocket(\"STATUS\", sockPath);\n1654-    expect(lines).toEqual([\"CONNECTED\"]);\n1655-  });\n1656-\n1657:  test(\"SAY returns OK and calls handle\", async () => {\n1658-    startTestServer();\n1659:    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n1660-    expect(lines).toEqual([\"OK\"]);\n1661:    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n1662-  });\n1663-\n1664-  test(\"WHISPER returns OK\", async () => {\n1665-    startTestServer();\n1666-    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n--\n1668-    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n1669-  });\n1670-\n1671-  test(\"READ returns buffered events\", async () => {\n1672-    startTestServer();\n1673:    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n1674:    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n1675-    const lines = await sendToSocket(\"READ\", sockPath);\n1676-    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n1677-  });\n1678-\n1679-  test(\"bare text sends via sticky mode\", async () => {\n--\n1818-  });\n1819-\n1820-  test(\"onMessage wiring pushes to ring buffer\", async () => {\n1821-    startTestServer();\n1822-    handle.triggerMessage({\n1823:      type: ChatType.SAY,\n1824-      sender: \"Alice\",\n1825-      message: \"hi\",\n1826-    });\n1827-    const lines = await sendToSocket(\"READ\", sockPath);\n1828-    expect(lines).toEqual([\"[say] Alice: hi\"]);","numLines":226},"sourceToolAssistantUUID":"fa989595-c02e-4c24-a760-2620f3bed03e"}
{"parentUuid":"4bd49bc2-d0aa-4b90-9599-0ff602beeec1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01JdMCSaCDkujoBspsqvgd8j","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have enough context to add the tests. Let me find the exact locations to add tests in each test file.\n\nFor tui.test.ts, I need to add:\n1. A parseCommand test for `/e` and `/emote`\n2. An executeCommand test for emote calling `sendEmote`\n\nFor commands.test.ts, I need to add:\n1. A parseIpcCommand test for \"EMOTE\"\n2. A dispatchCommand test for emote\n3. A test for `/emote` via slash in parseIpcCommand\n\nFor client.test.ts, I need to add:\n\n\n1. A sendEmote echo test\n\nNow I'm locating the right insertion points in each file.","signature":"EpwFCkYICxgCKkBVo3xXwEYt/HOqQRoYCiWAzHTpHJJEPIMx8eisCFWwMAtShwynkTvDK25vjAGHCvO6q7E/9kEF6Ip3ft+Sc0h5EgxVxnXLPDARr+XhNzQaDPLPYqVP44CzF707WCIw5in7ZtgDIhQHkspQk5uTyFcWmWf8Dc2c5s3BZpBUtF8bhg1wHa73XCz4uwNip9okKoMEiDaAD2Lm1BFQrQ2cfg1c5AlficLiVTK9bEjVrpUAM+5I+IEvv2CK7OKjcwsMqZjSI1hZ3s+0cGNW7e9lKGFITgLqv9B5Pw6o8mZyvGHCqim0bJoEG/ul6ajwS5z6mp2gbgT45ceH6w6H2iIWWHkVy7yYDcuPm9p3XeK/6hGzFvtLzACfh6af4PEeqCTDgurBLIDIGZiynPXzVdxdM+cSk4+fY6ti/BNf4s/NhH6efPqC9Qj+723rR8ZHdHxxBKqdnEzqnb05gk0HH2BDaqpCNNnduLPznS/PG1avhQtUaG/crBRSfrtoDHvNN92wqnv6lux46PxT3rTPVJyvPfpjFJaMb47Hb5yaEcFxGR2BwIa21xr+HSgETUwBLZ9YcS7Ze8sdJoYCyLTcNTNw/ORFfBQX424A5oCgSWX0iO8khO1lXfiVEnkHSU6zSi8D+hd/CSUbFAsrUM/stTfnk80WZvDE7P+H47dqJ5sx8Ea7huczypxqHXrMqVfWvaCr11v1x0aftk1NG9teS78iPQjgOE6kpAG07Wjlbz9YxFyt0QFW6KIwEVG64Viquu0Ykpp9/a0tT34OKttHudDk2yCVLkDvC6iceNfwJQiv1/XVt5aYXT2wWbjZK+EEvH6JMtIRal4QCHKfBqXL2RrDhrVwGBCdehD/BU7kUwLoK4s4sy4EG5IYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4234,"cache_read_input_tokens":80065,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4234},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMXBjnVe2RVQZFditb1","type":"assistant","uuid":"a6b53189-c6b4-4d20-a7be-41edb23245b6","timestamp":"2026-02-28T23:43:35.806Z"}
{"parentUuid":"a6b53189-c6b4-4d20-a7be-41edb23245b6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01JdMCSaCDkujoBspsqvgd8j","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me find the exact insertion points for each test file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4234,"cache_read_input_tokens":80065,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4234},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMXBjnVe2RVQZFditb1","type":"assistant","uuid":"3b4619a3-b6ed-44ef-b9f9-938906c989b5","timestamp":"2026-02-28T23:43:35.821Z"}
{"parentUuid":"3b4619a3-b6ed-44ef-b9f9-938906c989b5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01JdMCSaCDkujoBspsqvgd8j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013JpK5usHuJLjqmpQxypTgh","name":"Grep","input":{"pattern":"\\/say sends say|\\/raid|test.*parseCommand.*raid|emote.*unimpl","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4234,"cache_read_input_tokens":80065,"output_tokens":333,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":4234,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMXBjnVe2RVQZFditb1","type":"assistant","uuid":"f4eac0e2-0d10-4490-a82c-5d2bd25344a8","timestamp":"2026-02-28T23:43:38.141Z"}
{"parentUuid":"f4eac0e2-0d10-4490-a82c-5d2bd25344a8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013JpK5usHuJLjqmpQxypTgh","type":"tool_result","content":"37-\n38-  test(\"/s sends say\", () => {\n39-    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42:  test(\"/say sends say\", () => {\n43-    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n45-      message: \"hello there\",\n46-    });\n47-  });\n--\n99-      type: \"party\",\n100-      message: \"inv\",\n101-    });\n102-  });\n103-\n104:  test(\"/raid sends raid\", () => {\n105:    expect(parseCommand(\"/raid pull\")).toEqual({\n106-      type: \"raid\",\n107-      message: \"pull\",\n108-    });\n109-  });\n110-\n--\n295-      expect(parseCommand(\"/e waves\")).toEqual({\n296-        type: \"unimplemented\",\n297-        feature: \"Text emotes\",\n298-      });\n299-    });\n300:    test(\"/emote returns unimplemented\", () => {\n301-      expect(parseCommand(\"/emote waves\")).toEqual({\n302-        type: \"unimplemented\",\n303-        feature: \"Text emotes\",\n304-      });\n305-    });\n--\n458-\n459-    const done = startTui(handle, false, { input, write: () => {} });\n460-    writeLine(input, \"/y LOUD\");\n461-    writeLine(input, \"/g guild msg\");\n462-    writeLine(input, \"/p party msg\");\n463:    writeLine(input, \"/raid pull now\");\n464-    await flush();\n465-\n466-    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n467-    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n468-    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");"}]},"uuid":"6708233a-8201-4fee-9501-d13e9859fd9e","timestamp":"2026-02-28T23:43:38.224Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"37-\n38-  test(\"/s sends say\", () => {\n39-    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42:  test(\"/say sends say\", () => {\n43-    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n45-      message: \"hello there\",\n46-    });\n47-  });\n--\n99-      type: \"party\",\n100-      message: \"inv\",\n101-    });\n102-  });\n103-\n104:  test(\"/raid sends raid\", () => {\n105:    expect(parseCommand(\"/raid pull\")).toEqual({\n106-      type: \"raid\",\n107-      message: \"pull\",\n108-    });\n109-  });\n110-\n--\n295-      expect(parseCommand(\"/e waves\")).toEqual({\n296-        type: \"unimplemented\",\n297-        feature: \"Text emotes\",\n298-      });\n299-    });\n300:    test(\"/emote returns unimplemented\", () => {\n301-      expect(parseCommand(\"/emote waves\")).toEqual({\n302-        type: \"unimplemented\",\n303-        feature: \"Text emotes\",\n304-      });\n305-    });\n--\n458-\n459-    const done = startTui(handle, false, { input, write: () => {} });\n460-    writeLine(input, \"/y LOUD\");\n461-    writeLine(input, \"/g guild msg\");\n462-    writeLine(input, \"/p party msg\");\n463:    writeLine(input, \"/raid pull now\");\n464-    await flush();\n465-\n466-    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n467-    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n468-    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");","numLines":48},"sourceToolAssistantUUID":"f4eac0e2-0d10-4490-a82c-5d2bd25344a8"}
{"parentUuid":"6708233a-8201-4fee-9501-d13e9859fd9e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UmnrxEvtVVoH7FLnqCrafX","type":"message","role":"assistant","content":[{"type":"text","text":"I need to update the existing emote tests (they test for `unimplemented` — I need to change them to test for `emote` type). Let me read the full emote test context."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":823,"cache_read_input_tokens":84299,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":823},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMXp5aG1aYvx96k4xcz","type":"assistant","uuid":"69fd76a9-23c7-4f18-a069-e0524bce815f","timestamp":"2026-02-28T23:43:41.799Z"}
{"parentUuid":"69fd76a9-23c7-4f18-a069-e0524bce815f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01UmnrxEvtVVoH7FLnqCrafX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DXuYszrNzW2f1NY64QpNA6","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","offset":290,"limit":20},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":823,"cache_read_input_tokens":84299,"output_tokens":153,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":823,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMXp5aG1aYvx96k4xcz","type":"assistant","uuid":"bcb741e1-e22d-4bd7-aa0d-9d5ac281978b","timestamp":"2026-02-28T23:43:42.556Z"}
{"parentUuid":"bcb741e1-e22d-4bd7-aa0d-9d5ac281978b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DXuYszrNzW2f1NY64QpNA6","type":"tool_result","content":"   290→        type: \"unimplemented\",\n   291→        feature: \"Player status\",\n   292→      });\n   293→    });\n   294→    test(\"/e returns unimplemented\", () => {\n   295→      expect(parseCommand(\"/e waves\")).toEqual({\n   296→        type: \"unimplemented\",\n   297→        feature: \"Text emotes\",\n   298→      });\n   299→    });\n   300→    test(\"/emote returns unimplemented\", () => {\n   301→      expect(parseCommand(\"/emote waves\")).toEqual({\n   302→        type: \"unimplemented\",\n   303→        feature: \"Text emotes\",\n   304→      });\n   305→    });\n   306→  });\n   307→});\n   308→\n   309→describe(\"formatMessage\", () => {"}]},"uuid":"f5a383f3-993f-4083-a659-d68a6fb7459e","timestamp":"2026-02-28T23:43:42.558Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","content":"        type: \"unimplemented\",\n        feature: \"Player status\",\n      });\n    });\n    test(\"/e returns unimplemented\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n    test(\"/emote returns unimplemented\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n  });\n});\n\ndescribe(\"formatMessage\", () => {","numLines":20,"startLine":290,"totalLines":1935}},"sourceToolAssistantUUID":"bcb741e1-e22d-4bd7-aa0d-9d5ac281978b"}
{"parentUuid":"f5a383f3-993f-4083-a659-d68a6fb7459e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DPxUtPZy8kVjJecgjr41VV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KYS8CWVto8ZXeZDzdksdkH","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","old_string":"    test(\"/e returns unimplemented\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n    test(\"/emote returns unimplemented\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });","new_string":"    test(\"/e sends emote\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });\n    test(\"/emote sends emote\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":369,"cache_read_input_tokens":85122,"output_tokens":327,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":369,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMY8gWh7mUU8kjfqFwX","type":"assistant","uuid":"d3779d99-0681-4b19-bb6a-34631d144703","timestamp":"2026-02-28T23:43:47.201Z"}
{"parentUuid":"d3779d99-0681-4b19-bb6a-34631d144703","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KYS8CWVto8ZXeZDzdksdkH","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/ui/tui.test.ts has been updated successfully."}]},"uuid":"e754b91d-e396-401b-8660-0366148cc483","timestamp":"2026-02-28T23:43:47.211Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","oldString":"    test(\"/e returns unimplemented\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n    test(\"/emote returns unimplemented\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });","newString":"    test(\"/e sends emote\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });\n    test(\"/emote sends emote\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });","originalFile":"import { test, expect, describe, jest } from \"bun:test\";\nimport { PassThrough } from \"node:stream\";\nimport {\n  parseCommand,\n  formatMessage,\n  formatMessageJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  formatPrompt,\n  startTui,\n} from \"ui/tui\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { FriendEntry } from \"wow/friend-store\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction writeLine(stream: PassThrough, line: string): void {\n  stream.write(line + \"\\n\");\n}\n\nconst flush = async (turns = 1): Promise<void> => {\n  for (let i = 0; i < turns; i += 1) {\n    await Bun.sleep(0);\n  }\n};\n\ndescribe(\"parseCommand\", () => {\n  test(\"bare text becomes chat\", () => {\n    expect(parseCommand(\"hello\")).toEqual({ type: \"chat\", message: \"hello\" });\n  });\n\n  test(\"/s sends say\", () => {\n    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n  });\n\n  test(\"/say sends say\", () => {\n    expect(parseCommand(\"/say hello there\")).toEqual({\n      type: \"say\",\n      message: \"hello there\",\n    });\n  });\n\n  test(\"/w sends whisper\", () => {\n    expect(parseCommand(\"/w Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"/whisper sends whisper\", () => {\n    expect(parseCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"/r sends reply\", () => {\n    expect(parseCommand(\"/r hello\")).toEqual({\n      type: \"reply\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"/g sends guild\", () => {\n    expect(parseCommand(\"/g hello guild\")).toEqual({\n      type: \"guild\",\n      message: \"hello guild\",\n    });\n  });\n\n  test(\"/guild sends guild\", () => {\n    expect(parseCommand(\"/guild hi\")).toEqual({\n      type: \"guild\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"/y sends yell\", () => {\n    expect(parseCommand(\"/y HELLO\")).toEqual({\n      type: \"yell\",\n      message: \"HELLO\",\n    });\n  });\n\n  test(\"/p sends party\", () => {\n    expect(parseCommand(\"/p inv\")).toEqual({ type: \"party\", message: \"inv\" });\n  });\n\n  test(\"/party sends party\", () => {\n    expect(parseCommand(\"/party inv\")).toEqual({\n      type: \"party\",\n      message: \"inv\",\n    });\n  });\n\n  test(\"/raid sends raid\", () => {\n    expect(parseCommand(\"/raid pull\")).toEqual({\n      type: \"raid\",\n      message: \"pull\",\n    });\n  });\n\n  test(\"/1 sends channel 1\", () => {\n    expect(parseCommand(\"/1 hello general\")).toEqual({\n      type: \"channel\",\n      target: \"1\",\n      message: \"hello general\",\n    });\n  });\n\n  test(\"/2 sends channel 2\", () => {\n    expect(parseCommand(\"/2 lfg\")).toEqual({\n      type: \"channel\",\n      target: \"2\",\n      message: \"lfg\",\n    });\n  });\n\n  test(\"/who sends who query\", () => {\n    expect(parseCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"/who with name filter\", () => {\n    expect(parseCommand(\"/who Xiara\")).toEqual({\n      type: \"who\",\n      target: \"Xiara\",\n    });\n  });\n\n  test(\"/quit sends quit\", () => {\n    expect(parseCommand(\"/quit\")).toEqual({ type: \"quit\" });\n  });\n\n  test(\"empty string becomes chat with empty message\", () => {\n    expect(parseCommand(\"\")).toEqual({ type: \"chat\", message: \"\" });\n  });\n\n  test(\"unknown slash command becomes say with full input\", () => {\n    expect(parseCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"/invite\", () => {\n    expect(parseCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/kick\", () => {\n    expect(parseCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/leave\", () => {\n    expect(parseCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"/leader\", () => {\n    expect(parseCommand(\"/leader Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/accept\", () => {\n    expect(parseCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"/decline\", () => {\n    expect(parseCommand(\"/decline\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"/invite with no target falls back to say\", () => {\n    expect(parseCommand(\"/invite\")).toEqual({\n      type: \"say\",\n      message: \"/invite\",\n    });\n  });\n\n  test(\"/kick with no target falls back to say\", () => {\n    expect(parseCommand(\"/kick\")).toEqual({\n      type: \"say\",\n      message: \"/kick\",\n    });\n  });\n\n  test(\"/leader with no target falls back to say\", () => {\n    expect(parseCommand(\"/leader\")).toEqual({\n      type: \"say\",\n      message: \"/leader\",\n    });\n  });\n\n  test(\"/friends returns friends\", () => {\n    expect(parseCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"/f returns friends\", () => {\n    expect(parseCommand(\"/f\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"/friend add Arthas returns add-friend\", () => {\n    expect(parseCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add-friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"/friend remove Arthas returns remove-friend\", () => {\n    expect(parseCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"remove-friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"/friend bare returns friends\", () => {\n    expect(parseCommand(\"/friend\")).toEqual({ type: \"friends\" });\n  });\n\n  describe(\"unimplemented commands\", () => {\n    test(\"/ignore returns unimplemented\", () => {\n      expect(parseCommand(\"/ignore Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Ignore list\",\n      });\n    });\n    test(\"/join returns unimplemented\", () => {\n      expect(parseCommand(\"/join Trade\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Channel join/leave\",\n      });\n    });\n    test(\"/ginvite returns unimplemented\", () => {\n      expect(parseCommand(\"/ginvite Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gkick returns unimplemented\", () => {\n      expect(parseCommand(\"/gkick Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gleave returns unimplemented\", () => {\n      expect(parseCommand(\"/gleave\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gpromote returns unimplemented\", () => {\n      expect(parseCommand(\"/gpromote Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/mail returns unimplemented\", () => {\n      expect(parseCommand(\"/mail\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Mail\",\n      });\n    });\n    test(\"/roll returns unimplemented\", () => {\n      expect(parseCommand(\"/roll\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Random roll\",\n      });\n    });\n    test(\"/dnd returns unimplemented\", () => {\n      expect(parseCommand(\"/dnd\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Player status\",\n      });\n    });\n    test(\"/afk returns unimplemented\", () => {\n      expect(parseCommand(\"/afk\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Player status\",\n      });\n    });\n    test(\"/e returns unimplemented\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n    test(\"/emote returns unimplemented\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Text emotes\",\n      });\n    });\n  });\n});\n\ndescribe(\"formatMessage\", () => {\n  test(\"whisper from\", () => {\n    const msg = { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" };\n    expect(formatMessage(msg)).toBe(\"[whisper from Eve] psst\");\n  });\n\n  test(\"whisper to\", () => {\n    const msg = {\n      type: ChatType.WHISPER_INFORM,\n      sender: \"Eve\",\n      message: \"hey\",\n    };\n    expect(formatMessage(msg)).toBe(\"[whisper to Eve] hey\");\n  });\n\n  test(\"system message\", () => {\n    const msg = { type: ChatType.SYSTEM, sender: \"\", message: \"Welcome\" };\n    expect(formatMessage(msg)).toBe(\"[system] Welcome\");\n  });\n\n  test(\"channel message\", () => {\n    const msg = {\n      type: ChatType.CHANNEL,\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    };\n    expect(formatMessage(msg)).toBe(\"[General] Al: hey\");\n  });\n\n  test(\"generic say\", () => {\n    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n    expect(formatMessage(msg)).toBe(\"[say] Alice: hi\");\n  });\n\n  test(\"unknown type\", () => {\n    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n    expect(formatMessage(msg)).toBe(\"[type 99] Bob: wat\");\n  });\n\n  test(\"strips color codes from message\", () => {\n    const msg = {\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"|cff1eff00|Hitem:1234|h[Cool Sword]|h|r equipped\",\n    };\n    expect(formatMessage(msg)).toBe(\"[say] Alice: [Cool Sword] equipped\");\n  });\n});\n\ndescribe(\"formatMessageJson\", () => {\n  test(\"json say\", () => {\n    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"json whisper from\", () => {\n    const msg = { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"json whisper to\", () => {\n    const msg = {\n      type: ChatType.WHISPER_INFORM,\n      sender: \"Eve\",\n      message: \"hey\",\n    };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"WHISPER_TO\",\n      sender: \"Eve\",\n      message: \"hey\",\n    });\n  });\n\n  test(\"json channel includes channel field\", () => {\n    const msg = {\n      type: ChatType.CHANNEL,\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"CHANNEL\",\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    });\n  });\n\n  test(\"json system message\", () => {\n    const msg = { type: ChatType.SYSTEM, sender: \"\", message: \"Welcome\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"SYSTEM\",\n      sender: \"\",\n      message: \"Welcome\",\n    });\n  });\n\n  test(\"json unknown type uses TYPE_N\", () => {\n    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"TYPE_99\",\n      sender: \"Bob\",\n      message: \"wat\",\n    });\n  });\n});\n\ndescribe(\"startTui\", () => {\n  test(\"bare text sends via sticky mode\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"hello\");\n    await flush();\n\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/say hello\");\n    await flush();\n\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches yell, guild, party, raid commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches whisper command\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/w Alice hey there\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Alice\", \"hey there\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"reply without prior whisper shows error\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/r hello\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"No one has whispered you yet\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"reply after whisper sends to last sender\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/w Bob initial\");\n    writeLine(input, \"/r followup\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Bob\", \"followup\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"who command formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/who\");\n    await flush(2);\n\n    expect(output.join(\"\")).toContain(\"[who] 1 results: Test (80)\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"channel by number resolves via getChannel\", async () => {\n    const handle = createMockHandle();\n    (handle.getChannel as ReturnType<typeof jest.fn>).mockReturnValue(\n      \"General\",\n    );\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/1 hello general\");\n    await flush();\n\n    expect(handle.getChannel).toHaveBeenCalledWith(1);\n    expect(handle.sendChannel).toHaveBeenCalledWith(\"General\", \"hello general\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"channel by number not joined shows error\", async () => {\n    const handle = createMockHandle();\n    (handle.getChannel as ReturnType<typeof jest.fn>).mockReturnValue(\n      undefined,\n    );\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/3 hello\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Not in channel 3\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"quit command closes handle and resolves\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/quit\");\n    await done;\n\n    expect(handle.close).toHaveBeenCalled();\n  });\n\n  test(\"incoming message writes formatted output\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n\n    expect(output.join(\"\")).toContain(\"[say] Alice: hi\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming whisper sets lastWhisperFrom for reply\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    handle.triggerMessage({\n      type: ChatType.WHISPER,\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n\n    writeLine(input, \"/r got it\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Eve\", \"got it\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"SIGINT closes handle and resolves\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: () => {},\n      });\n      input.write(\"\\x03\");\n      await done;\n\n      expect(handle.close).toHaveBeenCalled();\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"stream close resolves promise\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    input.end();\n    await done;\n  });\n\n  test(\"server disconnect closes readline\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    handle.resolveClosed();\n    await done;\n  });\n\n  test(\"defaults to process.stdout.write when no write option\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, false, { input });\n      handle.triggerMessage({\n        type: ChatType.SAY,\n        sender: \"Al\",\n        message: \"hi\",\n      });\n\n      expect(spy).toHaveBeenCalled();\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"interactive who formats results inline\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const input = new PassThrough();\n    const output: string[] = [];\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: (s) => void output.push(s),\n      });\n      writeLine(input, \"/who\");\n      await flush(2);\n\n      expect(output.join(\"\")).toContain(\"[who] 1 results: Test (80)\");\n\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"interactive mode uses ANSI formatting\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: (s) => void output.push(s),\n      });\n      handle.triggerMessage({\n        type: ChatType.SAY,\n        sender: \"Alice\",\n        message: \"hi\",\n      });\n\n      expect(output.join(\"\")).toContain(\"\\r\\x1b[K[say] Alice: hi\\n\");\n\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"command error is caught and displayed\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"Timed out waiting for opcode 0x63\"),\n    );\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/who\");\n    await flush(2);\n\n    expect(output.join(\"\")).toContain(\"Timed out waiting for opcode 0x63\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/invite calls handle.invite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/invite Voidtrix\");\n    await flush();\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/kick calls handle.uninvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/kick Voidtrix\");\n    await flush();\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/leave calls handle.leaveGroup\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/leave\");\n    await flush();\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"/leader calls handle.setLeader\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/leader Voidtrix\");\n    await flush();\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/accept calls handle.acceptInvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/accept\");\n    await flush();\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"/decline calls handle.declineInvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/decline\");\n    await flush();\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"unimplemented command writes error message\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/ignore\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Ignore list is not yet implemented\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming displayable group event writes output\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerGroupEvent({\n      type: \"invite_declined\",\n      name: \"Voidtrix\",\n    });\n\n    expect(output.join(\"\")).toContain(\n      \"[group] Voidtrix has declined your invitation\",\n    );\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming non-displayable group event is ignored\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerGroupEvent({\n      type: \"group_list\",\n      members: [],\n      leader: \"\",\n    });\n\n    expect(output).toEqual([]);\n\n    input.end();\n    await done;\n  });\n});\n\ndescribe(\"formatPrompt\", () => {\n  test(\"say mode\", () => {\n    expect(formatPrompt({ type: \"say\" })).toBe(\"[say] > \");\n  });\n\n  test(\"party mode\", () => {\n    expect(formatPrompt({ type: \"party\" })).toBe(\"[party] > \");\n  });\n\n  test(\"whisper mode includes target\", () => {\n    expect(formatPrompt({ type: \"whisper\", target: \"Xiara\" })).toBe(\n      \"[whisper: Xiara] > \",\n    );\n  });\n\n  test(\"channel mode includes channel name\", () => {\n    expect(formatPrompt({ type: \"channel\", channel: \"General\" })).toBe(\n      \"[General] > \",\n    );\n  });\n});\n\ndescribe(\"formatGroupEvent\", () => {\n  test(\"invite success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Invited Voidtrix\");\n  });\n\n  test(\"invite failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.BAD_PLAYER_NAME,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: player not found\");\n  });\n\n  test(\"uninvite success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Removed Voidtrix from group\");\n  });\n\n  test(\"uninvite failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot kick Voidtrix: you are not the leader\");\n  });\n\n  test(\"leave success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.LEAVE,\n        target: \"\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Left the group\");\n  });\n\n  test(\"leave failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.LEAVE,\n        target: \"\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot leave: you are not the leader\");\n  });\n\n  test(\"command_result with empty target omits extra space\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot kick: you are not the leader\");\n  });\n\n  test(\"invite failure with group full label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.GROUP_FULL,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: group is full\");\n  });\n\n  test(\"invite failure with already in group label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.ALREADY_IN_GROUP,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: already in a group\");\n  });\n\n  test(\"invite failure with wrong faction label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.PLAYER_WRONG_FACTION,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: wrong faction\");\n  });\n\n  test(\"invite failure with ignoring you label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.IGNORING_YOU,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: player is ignoring you\");\n  });\n\n  test(\"leader changed\", () => {\n    expect(formatGroupEvent({ type: \"leader_changed\", name: \"Alice\" })).toBe(\n      \"[group] Alice is now the group leader\",\n    );\n  });\n\n  test(\"group destroyed\", () => {\n    expect(formatGroupEvent({ type: \"group_destroyed\" })).toBe(\n      \"[group] Group has been disbanded\",\n    );\n  });\n\n  test(\"kicked\", () => {\n    expect(formatGroupEvent({ type: \"kicked\" })).toBe(\n      \"[group] You have been removed from the group\",\n    );\n  });\n\n  test(\"invite declined\", () => {\n    expect(formatGroupEvent({ type: \"invite_declined\", name: \"Bob\" })).toBe(\n      \"[group] Bob has declined your invitation\",\n    );\n  });\n\n  test(\"group_list returns undefined\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"group_list\",\n        members: [],\n        leader: \"\",\n      }),\n    ).toBeUndefined();\n  });\n});\n\ndescribe(\"tuicraft command\", () => {\n  test(\"parseCommand handles /tuicraft entities on\", () => {\n    const cmd = parseCommand(\"/tuicraft entities on\");\n    expect(cmd).toEqual({\n      type: \"tuicraft\",\n      subcommand: \"entities\",\n      value: \"on\",\n    });\n  });\n\n  test(\"parseCommand handles /tuicraft entities off\", () => {\n    const cmd = parseCommand(\"/tuicraft entities off\");\n    expect(cmd).toEqual({\n      type: \"tuicraft\",\n      subcommand: \"entities\",\n      value: \"off\",\n    });\n  });\n\n  test(\"parseCommand handles /tuicraft with unknown subcommand\", () => {\n    const cmd = parseCommand(\"/tuicraft foo\");\n    expect(cmd).toEqual({ type: \"tuicraft\", subcommand: \"foo\", value: \"\" });\n  });\n\n  test(\"entities on enables display\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities on\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Entity events enabled\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entities with invalid value shows usage\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities toggle\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Usage: /tuicraft entities on|off\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entities off disables display\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities off\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Entity events disabled\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"unknown subcommand shows error\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft foo\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Unknown tuicraft command: foo\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entity events displayed when enabled\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities on\");\n    await flush();\n\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n\n    expect(output.join(\"\")).toContain(\n      \"[world] Innkeeper Palla appeared (NPC, level 55)\",\n    );\n\n    input.end();\n    await done;\n  });\n\n  test(\"entity events suppressed when disabled\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n\n    expect(output.join(\"\")).not.toContain(\"[world]\");\n\n    input.end();\n    await done;\n  });\n});\n\ndescribe(\"formatEntityEvent\", () => {\n  test(\"formats unit appear with name and level\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toBe(\"[world] Innkeeper Palla appeared (NPC, level 55)\");\n  });\n\n  test(\"suppresses appear without name\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 2n,\n        objectType: ObjectType.UNIT,\n        name: undefined,\n        level: 1,\n      } as any,\n    });\n    expect(result).toBeUndefined();\n  });\n\n  test(\"formats player appear\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 2n,\n        objectType: ObjectType.PLAYER,\n        name: \"Thrall\",\n        level: 80,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toBe(\"[world] Thrall appeared (Player, level 80)\");\n  });\n\n  test(\"formats gameobject appear\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 3n,\n        objectType: ObjectType.GAMEOBJECT,\n        name: \"Mailbox\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        displayId: 0,\n        flags: 0,\n        gameObjectType: 19,\n        bytes1: 0,\n      },\n    });\n    expect(result).toBe(\"[world] Mailbox appeared (GameObject)\");\n  });\n\n  test(\"formats disappear\", () => {\n    const result = formatEntityEvent({\n      type: \"disappear\",\n      guid: 1n,\n      name: \"Silvermoon Guardian\",\n    });\n    expect(result).toBe(\"[world] Silvermoon Guardian left range\");\n  });\n\n  test(\"formats disappear without name\", () => {\n    const result = formatEntityEvent({\n      type: \"disappear\",\n      guid: 1n,\n    });\n    expect(result).toBe(\"[world] Unknown entity left range\");\n  });\n\n  test(\"update returns undefined for non-name changes\", () => {\n    const result = formatEntityEvent({\n      type: \"update\",\n      entity: { guid: 1n } as any,\n      changed: [\"health\"],\n    });\n    expect(result).toBeUndefined();\n  });\n\n  test(\"update with name change formats appear-like message for NPC\", () => {\n    const result = formatEntityEvent({\n      type: \"update\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Springpaw Cub\",\n        level: 1,\n      } as any,\n      changed: [\"name\"],\n    });\n    expect(result).toBe(\"[world] Springpaw Cub appeared (NPC, level 1)\");\n  });\n\n  test(\"appear for CORPSE returns undefined\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 10n,\n        objectType: ObjectType.CORPSE,\n        name: \"Some Corpse\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n      },\n    });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatEntityEventObj\", () => {\n  test(\"appear for UNIT with position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: { mapId: 0, x: 100.5, y: 200.5, z: 50.0, orientation: 0 },\n        rawFields: new Map(),\n        health: 4200,\n        maxHealth: 5000,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.UNIT,\n      name: \"Innkeeper Palla\",\n      level: 55,\n      health: 4200,\n      maxHealth: 5000,\n      x: 100.5,\n      y: 200.5,\n      z: 50.0,\n    });\n  });\n\n  test(\"appear for UNIT without position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Guard\",\n        level: 75,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.UNIT,\n      name: \"Guard\",\n      level: 75,\n      health: 100,\n      maxHealth: 100,\n    });\n    expect(result).not.toHaveProperty(\"x\");\n    expect(result).not.toHaveProperty(\"y\");\n    expect(result).not.toHaveProperty(\"z\");\n  });\n\n  test(\"appear for PLAYER with position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 5n,\n        objectType: ObjectType.PLAYER,\n        name: \"Thrall\",\n        level: 80,\n        entry: 0,\n        scale: 1,\n        position: { mapId: 0, x: 1, y: 2, z: 3, orientation: 0 },\n        rawFields: new Map(),\n        health: 9000,\n        maxHealth: 9000,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x5\",\n      objectType: ObjectType.PLAYER,\n      name: \"Thrall\",\n      level: 80,\n      health: 9000,\n      maxHealth: 9000,\n      x: 1,\n      y: 2,\n      z: 3,\n    });\n  });\n\n  test(\"appear for GAMEOBJECT\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.GAMEOBJECT,\n        name: \"Mailbox\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        displayId: 0,\n        flags: 0,\n        gameObjectType: 19,\n        bytes1: 0,\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n    });\n    expect(result).not.toHaveProperty(\"level\");\n    expect(result).not.toHaveProperty(\"health\");\n    expect(result).not.toHaveProperty(\"maxHealth\");\n  });\n\n  test(\"disappear\", () => {\n    const result = formatEntityEventObj({\n      type: \"disappear\",\n      guid: 1n,\n      name: \"Silvermoon Guardian\",\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_DISAPPEAR\",\n      guid: \"0x1\",\n      name: \"Silvermoon Guardian\",\n    });\n  });\n\n  test(\"update returns undefined\", () => {\n    const result = formatEntityEventObj({\n      type: \"update\",\n      entity: { guid: 1n, objectType: ObjectType.UNIT } as any,\n      changed: [\"health\"],\n    });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatFriendList\", () => {\n  test(\"empty list returns no-friends message\", () => {\n    expect(formatFriendList([])).toBe(\"[friends] No friends on your list\");\n  });\n\n  test(\"shows online and offline friends\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 0,\n        level: 80,\n        playerClass: 6,\n      },\n      {\n        guid: 2n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"1/2 online\");\n    expect(result).toContain(\"Arthas — Online, Level 80 Death Knight\");\n    expect(result).toContain(\"Jaina — Offline\");\n  });\n\n  test(\"shows AFK and DND statuses\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Afker\",\n        note: \"\",\n        status: FriendStatus.AFK,\n        area: 0,\n        level: 70,\n        playerClass: 1,\n      },\n      {\n        guid: 2n,\n        name: \"Dnder\",\n        note: \"\",\n        status: FriendStatus.DND,\n        area: 0,\n        level: 60,\n        playerClass: 4,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"Afker — AFK, Level 70 Warrior\");\n    expect(result).toContain(\"Dnder — DND, Level 60 Rogue\");\n  });\n\n  test(\"falls back to guid when name is empty\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 42n,\n        name: \"\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 1,\n        playerClass: 1,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"guid:42 — Offline\");\n  });\n});\n\ndescribe(\"formatFriendListJson\", () => {\n  test(\"serializes friends with status, class, and area\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"buddy\",\n        status: FriendStatus.ONLINE,\n        area: 394,\n        level: 80,\n        playerClass: 6,\n      },\n      {\n        guid: 2n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    ];\n    const result = JSON.parse(formatFriendListJson(friends));\n    expect(result.type).toBe(\"FRIENDS\");\n    expect(result.count).toBe(2);\n    expect(result.online).toBe(1);\n    expect(result.friends[0].name).toBe(\"Arthas\");\n    expect(result.friends[0].note).toBe(\"buddy\");\n    expect(result.friends[0].status).toBe(\"ONLINE\");\n    expect(result.friends[0].level).toBe(80);\n    expect(result.friends[0].class).toBe(\"Death Knight\");\n    expect(result.friends[0].area).toBe(394);\n    expect(result.friends[1].name).toBe(\"Jaina\");\n    expect(result.friends[1].status).toBe(\"OFFLINE\");\n    expect(result.friends[1].class).toBe(\"Mage\");\n  });\n});\n\ndescribe(\"formatFriendEvent\", () => {\n  test(\"friend-online with class and level\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 0,\n        level: 80,\n        playerClass: 6,\n      },\n    });\n    expect(result).toBe(\n      \"[friends] Arthas is now online (Level 80 Death Knight)\",\n    );\n  });\n\n  test(\"friend-offline\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-offline\",\n      guid: 1n,\n      name: \"Arthas\",\n    });\n    expect(result).toBe(\"[friends] Arthas went offline\");\n  });\n\n  test(\"friend-added\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-added\",\n      friend: {\n        guid: 1n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    });\n    expect(result).toBe(\"[friends] Jaina added to friends list\");\n  });\n\n  test(\"friend-removed\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-removed\",\n      guid: 1n,\n      name: \"Jaina\",\n    });\n    expect(result).toBe(\"[friends] Jaina removed from friends list\");\n  });\n\n  test(\"friend-error\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-error\",\n      result: 0x04,\n      name: \"Nobody\",\n    });\n    expect(result).toBe(\"[friends] Error: player not found\");\n  });\n\n  test(\"friend-error with unknown code\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-error\",\n      result: 0xff,\n      name: \"Nobody\",\n    });\n    expect(result).toBe(\"[friends] Error: error 255\");\n  });\n\n  test(\"friend-list returns undefined\", () => {\n    const result = formatFriendEvent({ type: \"friend-list\", friends: [] });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatFriendEventObj\", () => {\n  test(\"friend-online\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 394,\n        level: 80,\n        playerClass: 6,\n      },\n    });\n    expect(result).toEqual({\n      type: \"FRIEND_ONLINE\",\n      name: \"Arthas\",\n      level: 80,\n      class: \"Death Knight\",\n      area: 394,\n    });\n  });\n\n  test(\"friend-offline\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-offline\",\n      guid: 1n,\n      name: \"Arthas\",\n    });\n    expect(result).toEqual({ type: \"FRIEND_OFFLINE\", name: \"Arthas\" });\n  });\n\n  test(\"friend-added\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-added\",\n      friend: {\n        guid: 1n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    });\n    expect(result).toEqual({ type: \"FRIEND_ADDED\", name: \"Jaina\" });\n  });\n\n  test(\"friend-removed\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-removed\",\n      guid: 1n,\n      name: \"Jaina\",\n    });\n    expect(result).toEqual({ type: \"FRIEND_REMOVED\", name: \"Jaina\" });\n  });\n\n  test(\"friend-error\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-error\",\n      result: 0x08,\n      name: \"Self\",\n    });\n    expect(result).toEqual({\n      type: \"FRIEND_ERROR\",\n      result: 0x08,\n      message: \"already on friends list\",\n    });\n  });\n\n  test(\"friend-list returns undefined\", () => {\n    const result = formatFriendEventObj({ type: \"friend-list\", friends: [] });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"friend TUI commands\", () => {\n  test(\"/friends calls getFriends and writes output\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/friends\");\n    await flush();\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(output.join(\"\")).toContain(\"No friends on your list\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/friend add calls addFriend\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/friend add Arthas\");\n    await flush();\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/friend remove calls removeFriend\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/friend remove Arthas\");\n    await flush();\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n\n    input.end();\n    await done;\n  });\n});\n","structuredPatch":[{"oldStart":291,"oldLines":16,"newStart":291,"newLines":16,"lines":["         feature: \"Player status\",","       });","     });","-    test(\"/e returns unimplemented\", () => {","+    test(\"/e sends emote\", () => {","       expect(parseCommand(\"/e waves\")).toEqual({","-        type: \"unimplemented\",","-        feature: \"Text emotes\",","+        type: \"emote\",","+        message: \"waves\",","       });","     });","-    test(\"/emote returns unimplemented\", () => {","+    test(\"/emote sends emote\", () => {","       expect(parseCommand(\"/emote waves\")).toEqual({","-        type: \"unimplemented\",","-        feature: \"Text emotes\",","+        type: \"emote\",","+        message: \"waves\",","       });","     });","   });"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d3779d99-0681-4b19-bb6a-34631d144703"}
{"parentUuid":"e754b91d-e396-401b-8660-0366148cc483","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01KeN6tZhxRGHYBWwxmZVdEp","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the executeCommand test for emote. Let me find the right insertion point."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":367,"cache_read_input_tokens":85491,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":367},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMYVRgidsMJUsppvRm7","type":"assistant","uuid":"afcc6e74-35c2-4202-b110-aa49738e96ba","timestamp":"2026-02-28T23:43:51.603Z"}
{"parentUuid":"afcc6e74-35c2-4202-b110-aa49738e96ba","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01KeN6tZhxRGHYBWwxmZVdEp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MtbRp8u51SQJeA5FU5rWgB","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","offset":440,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":367,"cache_read_input_tokens":85491,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":367},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMYVRgidsMJUsppvRm7","type":"assistant","uuid":"52f5b239-8e47-4565-b06e-9b57e9878717","timestamp":"2026-02-28T23:43:57.215Z"}
{"parentUuid":"52f5b239-8e47-4565-b06e-9b57e9878717","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MtbRp8u51SQJeA5FU5rWgB","type":"tool_result","content":"   440→  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n   441→    const handle = createMockHandle();\n   442→    const input = new PassThrough();\n   443→\n   444→    const done = startTui(handle, false, { input, write: () => {} });\n   445→    writeLine(input, \"/say hello\");\n   446→    await flush();\n   447→\n   448→    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n   449→    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n   450→\n   451→    input.end();\n   452→    await done;\n   453→  });\n   454→\n   455→  test(\"dispatches yell, guild, party, raid commands\", async () => {\n   456→    const handle = createMockHandle();\n   457→    const input = new PassThrough();\n   458→\n   459→    const done = startTui(handle, false, { input, write: () => {} });\n   460→    writeLine(input, \"/y LOUD\");\n   461→    writeLine(input, \"/g guild msg\");\n   462→    writeLine(input, \"/p party msg\");\n   463→    writeLine(input, \"/raid pull now\");\n   464→    await flush();\n   465→\n   466→    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n   467→    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n   468→    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n   469→    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n   470→\n   471→    input.end();\n   472→    await done;\n   473→  });\n   474→\n   475→  test(\"dispatches whisper command\", async () => {\n   476→    const handle = createMockHandle();\n   477→    const input = new PassThrough();\n   478→\n   479→    const done = startTui(handle, false, { input, write: () => {} });"}]},"uuid":"38e23f86-dcf5-4340-a4a7-e2368c3da28a","timestamp":"2026-02-28T23:43:57.217Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","content":"  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/say hello\");\n    await flush();\n\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches yell, guild, party, raid commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches whisper command\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });","numLines":40,"startLine":440,"totalLines":1935}},"sourceToolAssistantUUID":"52f5b239-8e47-4565-b06e-9b57e9878717"}
{"parentUuid":"38e23f86-dcf5-4340-a4a7-e2368c3da28a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01BA4fsQpReEYKLDapmNXf64","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017ofKNrsXM9PQU8WtXxbvPh","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","old_string":"  test(\"dispatches yell, guild, party, raid commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");","new_string":"  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    writeLine(input, \"/e waves hello\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":897,"cache_read_input_tokens":85858,"output_tokens":570,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":897,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMZN8fzmRaRFHTz56Bv","type":"assistant","uuid":"3ddf490d-2621-46cb-a271-707fbb1a9486","timestamp":"2026-02-28T23:44:06.247Z"}
{"parentUuid":"3ddf490d-2621-46cb-a271-707fbb1a9486","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ofKNrsXM9PQU8WtXxbvPh","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/ui/tui.test.ts has been updated successfully."}]},"uuid":"980c5add-82b3-4b47-85f9-e2e9bd0f8a4e","timestamp":"2026-02-28T23:44:06.267Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","oldString":"  test(\"dispatches yell, guild, party, raid commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");","newString":"  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    writeLine(input, \"/e waves hello\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");","originalFile":"import { test, expect, describe, jest } from \"bun:test\";\nimport { PassThrough } from \"node:stream\";\nimport {\n  parseCommand,\n  formatMessage,\n  formatMessageJson,\n  formatGroupEvent,\n  formatEntityEvent,\n  formatEntityEventObj,\n  formatFriendList,\n  formatFriendListJson,\n  formatFriendEvent,\n  formatFriendEventObj,\n  formatPrompt,\n  startTui,\n} from \"ui/tui\";\nimport { ChatType, PartyOperation, PartyResult } from \"wow/protocol/opcodes\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport type { FriendEntry } from \"wow/friend-store\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction writeLine(stream: PassThrough, line: string): void {\n  stream.write(line + \"\\n\");\n}\n\nconst flush = async (turns = 1): Promise<void> => {\n  for (let i = 0; i < turns; i += 1) {\n    await Bun.sleep(0);\n  }\n};\n\ndescribe(\"parseCommand\", () => {\n  test(\"bare text becomes chat\", () => {\n    expect(parseCommand(\"hello\")).toEqual({ type: \"chat\", message: \"hello\" });\n  });\n\n  test(\"/s sends say\", () => {\n    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n  });\n\n  test(\"/say sends say\", () => {\n    expect(parseCommand(\"/say hello there\")).toEqual({\n      type: \"say\",\n      message: \"hello there\",\n    });\n  });\n\n  test(\"/w sends whisper\", () => {\n    expect(parseCommand(\"/w Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"/whisper sends whisper\", () => {\n    expect(parseCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"/r sends reply\", () => {\n    expect(parseCommand(\"/r hello\")).toEqual({\n      type: \"reply\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"/g sends guild\", () => {\n    expect(parseCommand(\"/g hello guild\")).toEqual({\n      type: \"guild\",\n      message: \"hello guild\",\n    });\n  });\n\n  test(\"/guild sends guild\", () => {\n    expect(parseCommand(\"/guild hi\")).toEqual({\n      type: \"guild\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"/y sends yell\", () => {\n    expect(parseCommand(\"/y HELLO\")).toEqual({\n      type: \"yell\",\n      message: \"HELLO\",\n    });\n  });\n\n  test(\"/p sends party\", () => {\n    expect(parseCommand(\"/p inv\")).toEqual({ type: \"party\", message: \"inv\" });\n  });\n\n  test(\"/party sends party\", () => {\n    expect(parseCommand(\"/party inv\")).toEqual({\n      type: \"party\",\n      message: \"inv\",\n    });\n  });\n\n  test(\"/raid sends raid\", () => {\n    expect(parseCommand(\"/raid pull\")).toEqual({\n      type: \"raid\",\n      message: \"pull\",\n    });\n  });\n\n  test(\"/1 sends channel 1\", () => {\n    expect(parseCommand(\"/1 hello general\")).toEqual({\n      type: \"channel\",\n      target: \"1\",\n      message: \"hello general\",\n    });\n  });\n\n  test(\"/2 sends channel 2\", () => {\n    expect(parseCommand(\"/2 lfg\")).toEqual({\n      type: \"channel\",\n      target: \"2\",\n      message: \"lfg\",\n    });\n  });\n\n  test(\"/who sends who query\", () => {\n    expect(parseCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"/who with name filter\", () => {\n    expect(parseCommand(\"/who Xiara\")).toEqual({\n      type: \"who\",\n      target: \"Xiara\",\n    });\n  });\n\n  test(\"/quit sends quit\", () => {\n    expect(parseCommand(\"/quit\")).toEqual({ type: \"quit\" });\n  });\n\n  test(\"empty string becomes chat with empty message\", () => {\n    expect(parseCommand(\"\")).toEqual({ type: \"chat\", message: \"\" });\n  });\n\n  test(\"unknown slash command becomes say with full input\", () => {\n    expect(parseCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"/invite\", () => {\n    expect(parseCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/kick\", () => {\n    expect(parseCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/leave\", () => {\n    expect(parseCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"/leader\", () => {\n    expect(parseCommand(\"/leader Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"/accept\", () => {\n    expect(parseCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"/decline\", () => {\n    expect(parseCommand(\"/decline\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"/invite with no target falls back to say\", () => {\n    expect(parseCommand(\"/invite\")).toEqual({\n      type: \"say\",\n      message: \"/invite\",\n    });\n  });\n\n  test(\"/kick with no target falls back to say\", () => {\n    expect(parseCommand(\"/kick\")).toEqual({\n      type: \"say\",\n      message: \"/kick\",\n    });\n  });\n\n  test(\"/leader with no target falls back to say\", () => {\n    expect(parseCommand(\"/leader\")).toEqual({\n      type: \"say\",\n      message: \"/leader\",\n    });\n  });\n\n  test(\"/friends returns friends\", () => {\n    expect(parseCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"/f returns friends\", () => {\n    expect(parseCommand(\"/f\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"/friend add Arthas returns add-friend\", () => {\n    expect(parseCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add-friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"/friend remove Arthas returns remove-friend\", () => {\n    expect(parseCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"remove-friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"/friend bare returns friends\", () => {\n    expect(parseCommand(\"/friend\")).toEqual({ type: \"friends\" });\n  });\n\n  describe(\"unimplemented commands\", () => {\n    test(\"/ignore returns unimplemented\", () => {\n      expect(parseCommand(\"/ignore Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Ignore list\",\n      });\n    });\n    test(\"/join returns unimplemented\", () => {\n      expect(parseCommand(\"/join Trade\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Channel join/leave\",\n      });\n    });\n    test(\"/ginvite returns unimplemented\", () => {\n      expect(parseCommand(\"/ginvite Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gkick returns unimplemented\", () => {\n      expect(parseCommand(\"/gkick Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gleave returns unimplemented\", () => {\n      expect(parseCommand(\"/gleave\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/gpromote returns unimplemented\", () => {\n      expect(parseCommand(\"/gpromote Foo\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Guild management\",\n      });\n    });\n    test(\"/mail returns unimplemented\", () => {\n      expect(parseCommand(\"/mail\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Mail\",\n      });\n    });\n    test(\"/roll returns unimplemented\", () => {\n      expect(parseCommand(\"/roll\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Random roll\",\n      });\n    });\n    test(\"/dnd returns unimplemented\", () => {\n      expect(parseCommand(\"/dnd\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Player status\",\n      });\n    });\n    test(\"/afk returns unimplemented\", () => {\n      expect(parseCommand(\"/afk\")).toEqual({\n        type: \"unimplemented\",\n        feature: \"Player status\",\n      });\n    });\n    test(\"/e sends emote\", () => {\n      expect(parseCommand(\"/e waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });\n    test(\"/emote sends emote\", () => {\n      expect(parseCommand(\"/emote waves\")).toEqual({\n        type: \"emote\",\n        message: \"waves\",\n      });\n    });\n  });\n});\n\ndescribe(\"formatMessage\", () => {\n  test(\"whisper from\", () => {\n    const msg = { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" };\n    expect(formatMessage(msg)).toBe(\"[whisper from Eve] psst\");\n  });\n\n  test(\"whisper to\", () => {\n    const msg = {\n      type: ChatType.WHISPER_INFORM,\n      sender: \"Eve\",\n      message: \"hey\",\n    };\n    expect(formatMessage(msg)).toBe(\"[whisper to Eve] hey\");\n  });\n\n  test(\"system message\", () => {\n    const msg = { type: ChatType.SYSTEM, sender: \"\", message: \"Welcome\" };\n    expect(formatMessage(msg)).toBe(\"[system] Welcome\");\n  });\n\n  test(\"channel message\", () => {\n    const msg = {\n      type: ChatType.CHANNEL,\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    };\n    expect(formatMessage(msg)).toBe(\"[General] Al: hey\");\n  });\n\n  test(\"generic say\", () => {\n    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n    expect(formatMessage(msg)).toBe(\"[say] Alice: hi\");\n  });\n\n  test(\"unknown type\", () => {\n    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n    expect(formatMessage(msg)).toBe(\"[type 99] Bob: wat\");\n  });\n\n  test(\"strips color codes from message\", () => {\n    const msg = {\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"|cff1eff00|Hitem:1234|h[Cool Sword]|h|r equipped\",\n    };\n    expect(formatMessage(msg)).toBe(\"[say] Alice: [Cool Sword] equipped\");\n  });\n});\n\ndescribe(\"formatMessageJson\", () => {\n  test(\"json say\", () => {\n    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"json whisper from\", () => {\n    const msg = { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"json whisper to\", () => {\n    const msg = {\n      type: ChatType.WHISPER_INFORM,\n      sender: \"Eve\",\n      message: \"hey\",\n    };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"WHISPER_TO\",\n      sender: \"Eve\",\n      message: \"hey\",\n    });\n  });\n\n  test(\"json channel includes channel field\", () => {\n    const msg = {\n      type: ChatType.CHANNEL,\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"CHANNEL\",\n      sender: \"Al\",\n      message: \"hey\",\n      channel: \"General\",\n    });\n  });\n\n  test(\"json system message\", () => {\n    const msg = { type: ChatType.SYSTEM, sender: \"\", message: \"Welcome\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"SYSTEM\",\n      sender: \"\",\n      message: \"Welcome\",\n    });\n  });\n\n  test(\"json unknown type uses TYPE_N\", () => {\n    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n      type: \"TYPE_99\",\n      sender: \"Bob\",\n      message: \"wat\",\n    });\n  });\n});\n\ndescribe(\"startTui\", () => {\n  test(\"bare text sends via sticky mode\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"hello\");\n    await flush();\n\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/say explicitly sends say and not sendInCurrentMode\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/say hello\");\n    await flush();\n\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(handle.sendInCurrentMode).not.toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches yell, guild, party, raid commands\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/y LOUD\");\n    writeLine(input, \"/g guild msg\");\n    writeLine(input, \"/p party msg\");\n    writeLine(input, \"/raid pull now\");\n    await flush();\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n    expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n    expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"dispatches whisper command\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/w Alice hey there\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Alice\", \"hey there\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"reply without prior whisper shows error\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/r hello\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"No one has whispered you yet\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"reply after whisper sends to last sender\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/w Bob initial\");\n    writeLine(input, \"/r followup\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Bob\", \"followup\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"who command formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/who\");\n    await flush(2);\n\n    expect(output.join(\"\")).toContain(\"[who] 1 results: Test (80)\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"channel by number resolves via getChannel\", async () => {\n    const handle = createMockHandle();\n    (handle.getChannel as ReturnType<typeof jest.fn>).mockReturnValue(\n      \"General\",\n    );\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/1 hello general\");\n    await flush();\n\n    expect(handle.getChannel).toHaveBeenCalledWith(1);\n    expect(handle.sendChannel).toHaveBeenCalledWith(\"General\", \"hello general\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"channel by number not joined shows error\", async () => {\n    const handle = createMockHandle();\n    (handle.getChannel as ReturnType<typeof jest.fn>).mockReturnValue(\n      undefined,\n    );\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/3 hello\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Not in channel 3\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"quit command closes handle and resolves\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/quit\");\n    await done;\n\n    expect(handle.close).toHaveBeenCalled();\n  });\n\n  test(\"incoming message writes formatted output\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n\n    expect(output.join(\"\")).toContain(\"[say] Alice: hi\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming whisper sets lastWhisperFrom for reply\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    handle.triggerMessage({\n      type: ChatType.WHISPER,\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n\n    writeLine(input, \"/r got it\");\n    await flush();\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Eve\", \"got it\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"SIGINT closes handle and resolves\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: () => {},\n      });\n      input.write(\"\\x03\");\n      await done;\n\n      expect(handle.close).toHaveBeenCalled();\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"stream close resolves promise\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    input.end();\n    await done;\n  });\n\n  test(\"server disconnect closes readline\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    handle.resolveClosed();\n    await done;\n  });\n\n  test(\"defaults to process.stdout.write when no write option\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, false, { input });\n      handle.triggerMessage({\n        type: ChatType.SAY,\n        sender: \"Al\",\n        message: \"hi\",\n      });\n\n      expect(spy).toHaveBeenCalled();\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"interactive who formats results inline\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const input = new PassThrough();\n    const output: string[] = [];\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: (s) => void output.push(s),\n      });\n      writeLine(input, \"/who\");\n      await flush(2);\n\n      expect(output.join(\"\")).toContain(\"[who] 1 results: Test (80)\");\n\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"interactive mode uses ANSI formatting\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n    const spy = jest\n      .spyOn(process.stdout, \"write\")\n      .mockImplementation(() => true);\n\n    try {\n      const done = startTui(handle, true, {\n        input,\n        write: (s) => void output.push(s),\n      });\n      handle.triggerMessage({\n        type: ChatType.SAY,\n        sender: \"Alice\",\n        message: \"hi\",\n      });\n\n      expect(output.join(\"\")).toContain(\"\\r\\x1b[K[say] Alice: hi\\n\");\n\n      input.end();\n      await done;\n    } finally {\n      spy.mockRestore();\n    }\n  });\n\n  test(\"command error is caught and displayed\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"Timed out waiting for opcode 0x63\"),\n    );\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/who\");\n    await flush(2);\n\n    expect(output.join(\"\")).toContain(\"Timed out waiting for opcode 0x63\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/invite calls handle.invite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/invite Voidtrix\");\n    await flush();\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/kick calls handle.uninvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/kick Voidtrix\");\n    await flush();\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/leave calls handle.leaveGroup\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/leave\");\n    await flush();\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"/leader calls handle.setLeader\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/leader Voidtrix\");\n    await flush();\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/accept calls handle.acceptInvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/accept\");\n    await flush();\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"/decline calls handle.declineInvite\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/decline\");\n    await flush();\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n\n    input.end();\n    await done;\n  });\n\n  test(\"unimplemented command writes error message\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/ignore\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Ignore list is not yet implemented\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming displayable group event writes output\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerGroupEvent({\n      type: \"invite_declined\",\n      name: \"Voidtrix\",\n    });\n\n    expect(output.join(\"\")).toContain(\n      \"[group] Voidtrix has declined your invitation\",\n    );\n\n    input.end();\n    await done;\n  });\n\n  test(\"incoming non-displayable group event is ignored\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    handle.triggerGroupEvent({\n      type: \"group_list\",\n      members: [],\n      leader: \"\",\n    });\n\n    expect(output).toEqual([]);\n\n    input.end();\n    await done;\n  });\n});\n\ndescribe(\"formatPrompt\", () => {\n  test(\"say mode\", () => {\n    expect(formatPrompt({ type: \"say\" })).toBe(\"[say] > \");\n  });\n\n  test(\"party mode\", () => {\n    expect(formatPrompt({ type: \"party\" })).toBe(\"[party] > \");\n  });\n\n  test(\"whisper mode includes target\", () => {\n    expect(formatPrompt({ type: \"whisper\", target: \"Xiara\" })).toBe(\n      \"[whisper: Xiara] > \",\n    );\n  });\n\n  test(\"channel mode includes channel name\", () => {\n    expect(formatPrompt({ type: \"channel\", channel: \"General\" })).toBe(\n      \"[General] > \",\n    );\n  });\n});\n\ndescribe(\"formatGroupEvent\", () => {\n  test(\"invite success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Invited Voidtrix\");\n  });\n\n  test(\"invite failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.BAD_PLAYER_NAME,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: player not found\");\n  });\n\n  test(\"uninvite success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Removed Voidtrix from group\");\n  });\n\n  test(\"uninvite failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot kick Voidtrix: you are not the leader\");\n  });\n\n  test(\"leave success\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.LEAVE,\n        target: \"\",\n        result: PartyResult.SUCCESS,\n      }),\n    ).toBe(\"[group] Left the group\");\n  });\n\n  test(\"leave failure\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.LEAVE,\n        target: \"\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot leave: you are not the leader\");\n  });\n\n  test(\"command_result with empty target omits extra space\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.UNINVITE,\n        target: \"\",\n        result: PartyResult.NOT_LEADER,\n      }),\n    ).toBe(\"[group] Cannot kick: you are not the leader\");\n  });\n\n  test(\"invite failure with group full label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.GROUP_FULL,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: group is full\");\n  });\n\n  test(\"invite failure with already in group label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.ALREADY_IN_GROUP,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: already in a group\");\n  });\n\n  test(\"invite failure with wrong faction label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.PLAYER_WRONG_FACTION,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: wrong faction\");\n  });\n\n  test(\"invite failure with ignoring you label\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"command_result\",\n        operation: PartyOperation.INVITE,\n        target: \"Voidtrix\",\n        result: PartyResult.IGNORING_YOU,\n      }),\n    ).toBe(\"[group] Cannot invite Voidtrix: player is ignoring you\");\n  });\n\n  test(\"leader changed\", () => {\n    expect(formatGroupEvent({ type: \"leader_changed\", name: \"Alice\" })).toBe(\n      \"[group] Alice is now the group leader\",\n    );\n  });\n\n  test(\"group destroyed\", () => {\n    expect(formatGroupEvent({ type: \"group_destroyed\" })).toBe(\n      \"[group] Group has been disbanded\",\n    );\n  });\n\n  test(\"kicked\", () => {\n    expect(formatGroupEvent({ type: \"kicked\" })).toBe(\n      \"[group] You have been removed from the group\",\n    );\n  });\n\n  test(\"invite declined\", () => {\n    expect(formatGroupEvent({ type: \"invite_declined\", name: \"Bob\" })).toBe(\n      \"[group] Bob has declined your invitation\",\n    );\n  });\n\n  test(\"group_list returns undefined\", () => {\n    expect(\n      formatGroupEvent({\n        type: \"group_list\",\n        members: [],\n        leader: \"\",\n      }),\n    ).toBeUndefined();\n  });\n});\n\ndescribe(\"tuicraft command\", () => {\n  test(\"parseCommand handles /tuicraft entities on\", () => {\n    const cmd = parseCommand(\"/tuicraft entities on\");\n    expect(cmd).toEqual({\n      type: \"tuicraft\",\n      subcommand: \"entities\",\n      value: \"on\",\n    });\n  });\n\n  test(\"parseCommand handles /tuicraft entities off\", () => {\n    const cmd = parseCommand(\"/tuicraft entities off\");\n    expect(cmd).toEqual({\n      type: \"tuicraft\",\n      subcommand: \"entities\",\n      value: \"off\",\n    });\n  });\n\n  test(\"parseCommand handles /tuicraft with unknown subcommand\", () => {\n    const cmd = parseCommand(\"/tuicraft foo\");\n    expect(cmd).toEqual({ type: \"tuicraft\", subcommand: \"foo\", value: \"\" });\n  });\n\n  test(\"entities on enables display\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities on\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Entity events enabled\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entities with invalid value shows usage\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities toggle\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Usage: /tuicraft entities on|off\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entities off disables display\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities off\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Entity events disabled\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"unknown subcommand shows error\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft foo\");\n    await flush();\n\n    expect(output.join(\"\")).toContain(\"Unknown tuicraft command: foo\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"entity events displayed when enabled\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/tuicraft entities on\");\n    await flush();\n\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n\n    expect(output.join(\"\")).toContain(\n      \"[world] Innkeeper Palla appeared (NPC, level 55)\",\n    );\n\n    input.end();\n    await done;\n  });\n\n  test(\"entity events suppressed when disabled\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n\n    expect(output.join(\"\")).not.toContain(\"[world]\");\n\n    input.end();\n    await done;\n  });\n});\n\ndescribe(\"formatEntityEvent\", () => {\n  test(\"formats unit appear with name and level\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toBe(\"[world] Innkeeper Palla appeared (NPC, level 55)\");\n  });\n\n  test(\"suppresses appear without name\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 2n,\n        objectType: ObjectType.UNIT,\n        name: undefined,\n        level: 1,\n      } as any,\n    });\n    expect(result).toBeUndefined();\n  });\n\n  test(\"formats player appear\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 2n,\n        objectType: ObjectType.PLAYER,\n        name: \"Thrall\",\n        level: 80,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toBe(\"[world] Thrall appeared (Player, level 80)\");\n  });\n\n  test(\"formats gameobject appear\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 3n,\n        objectType: ObjectType.GAMEOBJECT,\n        name: \"Mailbox\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        displayId: 0,\n        flags: 0,\n        gameObjectType: 19,\n        bytes1: 0,\n      },\n    });\n    expect(result).toBe(\"[world] Mailbox appeared (GameObject)\");\n  });\n\n  test(\"formats disappear\", () => {\n    const result = formatEntityEvent({\n      type: \"disappear\",\n      guid: 1n,\n      name: \"Silvermoon Guardian\",\n    });\n    expect(result).toBe(\"[world] Silvermoon Guardian left range\");\n  });\n\n  test(\"formats disappear without name\", () => {\n    const result = formatEntityEvent({\n      type: \"disappear\",\n      guid: 1n,\n    });\n    expect(result).toBe(\"[world] Unknown entity left range\");\n  });\n\n  test(\"update returns undefined for non-name changes\", () => {\n    const result = formatEntityEvent({\n      type: \"update\",\n      entity: { guid: 1n } as any,\n      changed: [\"health\"],\n    });\n    expect(result).toBeUndefined();\n  });\n\n  test(\"update with name change formats appear-like message for NPC\", () => {\n    const result = formatEntityEvent({\n      type: \"update\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Springpaw Cub\",\n        level: 1,\n      } as any,\n      changed: [\"name\"],\n    });\n    expect(result).toBe(\"[world] Springpaw Cub appeared (NPC, level 1)\");\n  });\n\n  test(\"appear for CORPSE returns undefined\", () => {\n    const result = formatEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 10n,\n        objectType: ObjectType.CORPSE,\n        name: \"Some Corpse\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n      },\n    });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatEntityEventObj\", () => {\n  test(\"appear for UNIT with position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Innkeeper Palla\",\n        level: 55,\n        entry: 0,\n        scale: 1,\n        position: { mapId: 0, x: 100.5, y: 200.5, z: 50.0, orientation: 0 },\n        rawFields: new Map(),\n        health: 4200,\n        maxHealth: 5000,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.UNIT,\n      name: \"Innkeeper Palla\",\n      level: 55,\n      health: 4200,\n      maxHealth: 5000,\n      x: 100.5,\n      y: 200.5,\n      z: 50.0,\n    });\n  });\n\n  test(\"appear for UNIT without position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Guard\",\n        level: 75,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        health: 100,\n        maxHealth: 100,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.UNIT,\n      name: \"Guard\",\n      level: 75,\n      health: 100,\n      maxHealth: 100,\n    });\n    expect(result).not.toHaveProperty(\"x\");\n    expect(result).not.toHaveProperty(\"y\");\n    expect(result).not.toHaveProperty(\"z\");\n  });\n\n  test(\"appear for PLAYER with position\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 5n,\n        objectType: ObjectType.PLAYER,\n        name: \"Thrall\",\n        level: 80,\n        entry: 0,\n        scale: 1,\n        position: { mapId: 0, x: 1, y: 2, z: 3, orientation: 0 },\n        rawFields: new Map(),\n        health: 9000,\n        maxHealth: 9000,\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [],\n        maxPower: [],\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x5\",\n      objectType: ObjectType.PLAYER,\n      name: \"Thrall\",\n      level: 80,\n      health: 9000,\n      maxHealth: 9000,\n      x: 1,\n      y: 2,\n      z: 3,\n    });\n  });\n\n  test(\"appear for GAMEOBJECT\", () => {\n    const result = formatEntityEventObj({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.GAMEOBJECT,\n        name: \"Mailbox\",\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        displayId: 0,\n        flags: 0,\n        gameObjectType: 19,\n        bytes1: 0,\n      },\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_APPEAR\",\n      guid: \"0x1\",\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n    });\n    expect(result).not.toHaveProperty(\"level\");\n    expect(result).not.toHaveProperty(\"health\");\n    expect(result).not.toHaveProperty(\"maxHealth\");\n  });\n\n  test(\"disappear\", () => {\n    const result = formatEntityEventObj({\n      type: \"disappear\",\n      guid: 1n,\n      name: \"Silvermoon Guardian\",\n    });\n    expect(result).toEqual({\n      type: \"ENTITY_DISAPPEAR\",\n      guid: \"0x1\",\n      name: \"Silvermoon Guardian\",\n    });\n  });\n\n  test(\"update returns undefined\", () => {\n    const result = formatEntityEventObj({\n      type: \"update\",\n      entity: { guid: 1n, objectType: ObjectType.UNIT } as any,\n      changed: [\"health\"],\n    });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatFriendList\", () => {\n  test(\"empty list returns no-friends message\", () => {\n    expect(formatFriendList([])).toBe(\"[friends] No friends on your list\");\n  });\n\n  test(\"shows online and offline friends\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 0,\n        level: 80,\n        playerClass: 6,\n      },\n      {\n        guid: 2n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"1/2 online\");\n    expect(result).toContain(\"Arthas — Online, Level 80 Death Knight\");\n    expect(result).toContain(\"Jaina — Offline\");\n  });\n\n  test(\"shows AFK and DND statuses\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Afker\",\n        note: \"\",\n        status: FriendStatus.AFK,\n        area: 0,\n        level: 70,\n        playerClass: 1,\n      },\n      {\n        guid: 2n,\n        name: \"Dnder\",\n        note: \"\",\n        status: FriendStatus.DND,\n        area: 0,\n        level: 60,\n        playerClass: 4,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"Afker — AFK, Level 70 Warrior\");\n    expect(result).toContain(\"Dnder — DND, Level 60 Rogue\");\n  });\n\n  test(\"falls back to guid when name is empty\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 42n,\n        name: \"\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 1,\n        playerClass: 1,\n      },\n    ];\n    const result = formatFriendList(friends);\n    expect(result).toContain(\"guid:42 — Offline\");\n  });\n});\n\ndescribe(\"formatFriendListJson\", () => {\n  test(\"serializes friends with status, class, and area\", () => {\n    const friends: FriendEntry[] = [\n      {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"buddy\",\n        status: FriendStatus.ONLINE,\n        area: 394,\n        level: 80,\n        playerClass: 6,\n      },\n      {\n        guid: 2n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    ];\n    const result = JSON.parse(formatFriendListJson(friends));\n    expect(result.type).toBe(\"FRIENDS\");\n    expect(result.count).toBe(2);\n    expect(result.online).toBe(1);\n    expect(result.friends[0].name).toBe(\"Arthas\");\n    expect(result.friends[0].note).toBe(\"buddy\");\n    expect(result.friends[0].status).toBe(\"ONLINE\");\n    expect(result.friends[0].level).toBe(80);\n    expect(result.friends[0].class).toBe(\"Death Knight\");\n    expect(result.friends[0].area).toBe(394);\n    expect(result.friends[1].name).toBe(\"Jaina\");\n    expect(result.friends[1].status).toBe(\"OFFLINE\");\n    expect(result.friends[1].class).toBe(\"Mage\");\n  });\n});\n\ndescribe(\"formatFriendEvent\", () => {\n  test(\"friend-online with class and level\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 0,\n        level: 80,\n        playerClass: 6,\n      },\n    });\n    expect(result).toBe(\n      \"[friends] Arthas is now online (Level 80 Death Knight)\",\n    );\n  });\n\n  test(\"friend-offline\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-offline\",\n      guid: 1n,\n      name: \"Arthas\",\n    });\n    expect(result).toBe(\"[friends] Arthas went offline\");\n  });\n\n  test(\"friend-added\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-added\",\n      friend: {\n        guid: 1n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    });\n    expect(result).toBe(\"[friends] Jaina added to friends list\");\n  });\n\n  test(\"friend-removed\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-removed\",\n      guid: 1n,\n      name: \"Jaina\",\n    });\n    expect(result).toBe(\"[friends] Jaina removed from friends list\");\n  });\n\n  test(\"friend-error\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-error\",\n      result: 0x04,\n      name: \"Nobody\",\n    });\n    expect(result).toBe(\"[friends] Error: player not found\");\n  });\n\n  test(\"friend-error with unknown code\", () => {\n    const result = formatFriendEvent({\n      type: \"friend-error\",\n      result: 0xff,\n      name: \"Nobody\",\n    });\n    expect(result).toBe(\"[friends] Error: error 255\");\n  });\n\n  test(\"friend-list returns undefined\", () => {\n    const result = formatFriendEvent({ type: \"friend-list\", friends: [] });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"formatFriendEventObj\", () => {\n  test(\"friend-online\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        note: \"\",\n        status: FriendStatus.ONLINE,\n        area: 394,\n        level: 80,\n        playerClass: 6,\n      },\n    });\n    expect(result).toEqual({\n      type: \"FRIEND_ONLINE\",\n      name: \"Arthas\",\n      level: 80,\n      class: \"Death Knight\",\n      area: 394,\n    });\n  });\n\n  test(\"friend-offline\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-offline\",\n      guid: 1n,\n      name: \"Arthas\",\n    });\n    expect(result).toEqual({ type: \"FRIEND_OFFLINE\", name: \"Arthas\" });\n  });\n\n  test(\"friend-added\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-added\",\n      friend: {\n        guid: 1n,\n        name: \"Jaina\",\n        note: \"\",\n        status: FriendStatus.OFFLINE,\n        area: 0,\n        level: 80,\n        playerClass: 8,\n      },\n    });\n    expect(result).toEqual({ type: \"FRIEND_ADDED\", name: \"Jaina\" });\n  });\n\n  test(\"friend-removed\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-removed\",\n      guid: 1n,\n      name: \"Jaina\",\n    });\n    expect(result).toEqual({ type: \"FRIEND_REMOVED\", name: \"Jaina\" });\n  });\n\n  test(\"friend-error\", () => {\n    const result = formatFriendEventObj({\n      type: \"friend-error\",\n      result: 0x08,\n      name: \"Self\",\n    });\n    expect(result).toEqual({\n      type: \"FRIEND_ERROR\",\n      result: 0x08,\n      message: \"already on friends list\",\n    });\n  });\n\n  test(\"friend-list returns undefined\", () => {\n    const result = formatFriendEventObj({ type: \"friend-list\", friends: [] });\n    expect(result).toBeUndefined();\n  });\n});\n\ndescribe(\"friend TUI commands\", () => {\n  test(\"/friends calls getFriends and writes output\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const input = new PassThrough();\n    const output: string[] = [];\n\n    const done = startTui(handle, false, {\n      input,\n      write: (s) => void output.push(s),\n    });\n    writeLine(input, \"/friends\");\n    await flush();\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(output.join(\"\")).toContain(\"No friends on your list\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/friend add calls addFriend\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/friend add Arthas\");\n    await flush();\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n\n    input.end();\n    await done;\n  });\n\n  test(\"/friend remove calls removeFriend\", async () => {\n    const handle = createMockHandle();\n    const input = new PassThrough();\n\n    const done = startTui(handle, false, { input, write: () => {} });\n    writeLine(input, \"/friend remove Arthas\");\n    await flush();\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n\n    input.end();\n    await done;\n  });\n});\n","structuredPatch":[{"oldStart":452,"oldLines":7,"newStart":452,"newLines":7,"lines":["     await done;","   });"," ","-  test(\"dispatches yell, guild, party, raid commands\", async () => {","+  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {","     const handle = createMockHandle();","     const input = new PassThrough();"," "]},{"oldStart":461,"oldLines":12,"newStart":461,"newLines":14,"lines":["     writeLine(input, \"/g guild msg\");","     writeLine(input, \"/p party msg\");","     writeLine(input, \"/raid pull now\");","+    writeLine(input, \"/e waves hello\");","     await flush();"," ","     expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");","     expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");","     expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");","     expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");","+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");"," ","     input.end();","     await done;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3ddf490d-2621-46cb-a271-707fbb1a9486"}
{"parentUuid":"980c5add-82b3-4b47-85f9-e2e9bd0f8a4e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DWRBthW11tRhaKkfuTh7Bw","type":"message","role":"assistant","content":[{"type":"text","text":"Now add IPC tests in `commands.test.ts`. Let me find the right spots."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":610,"cache_read_input_tokens":86755,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":610},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMZtzYsxRqd9WuBpYEB","type":"assistant","uuid":"81882882-9913-4ca5-abb3-f48871368686","timestamp":"2026-02-28T23:44:10.646Z"}
{"parentUuid":"81882882-9913-4ca5-abb3-f48871368686","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01DWRBthW11tRhaKkfuTh7Bw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CCR3C4fM6PoZ6iGDpvReWB","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","offset":56,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":610,"cache_read_input_tokens":86755,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":610},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMZtzYsxRqd9WuBpYEB","type":"assistant","uuid":"89217ebb-fa47-44bf-a2f7-168317b2336a","timestamp":"2026-02-28T23:44:11.493Z"}
{"parentUuid":"89217ebb-fa47-44bf-a2f7-168317b2336a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CCR3C4fM6PoZ6iGDpvReWB","type":"tool_result","content":"    56→  test(\"YELL\", () => {\n    57→    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n    58→      type: \"yell\",\n    59→      message: \"hey everyone\",\n    60→    });\n    61→  });\n    62→\n    63→  test(\"GUILD\", () => {\n    64→    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n    65→      type: \"guild\",\n    66→      message: \"inv pls\",\n    67→    });\n    68→  });\n    69→\n    70→  test(\"PARTY\", () => {\n    71→    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n    72→      type: \"party\",\n    73→      message: \"pull now\",\n    74→    });\n    75→  });\n    76→\n    77→  test(\"WHISPER\", () => {\n    78→    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n    79→      type: \"whisper\",\n    80→      target: \"Xiara\",\n    81→      message: \"follow me\",\n    82→    });\n    83→  });\n    84→\n    85→  test(\"WHISPER without message\", () => {\n    86→    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n    87→      type: \"whisper\",\n    88→      target: \"Xiara\",\n    89→      message: \"\",\n    90→    });\n    91→  });\n    92→\n    93→  test(\"READ\", () => {\n    94→    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n    95→  });"}]},"uuid":"25e08b64-84b7-4e18-873f-375752d0519a","timestamp":"2026-02-28T23:44:11.496Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","content":"  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });","numLines":40,"startLine":56,"totalLines":1961}},"sourceToolAssistantUUID":"89217ebb-fa47-44bf-a2f7-168317b2336a"}
{"parentUuid":"25e08b64-84b7-4e18-873f-375752d0519a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01KYe1pBWYNhXU5LXHPopp28","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CxrcqxcHeHKSmSsbUYyqFY","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","old_string":"  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"WHISPER\", () => {","new_string":"  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":568,"cache_read_input_tokens":87365,"output_tokens":295,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":568,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMaGkkDn3tLzH2WNyBW","type":"assistant","uuid":"964c2282-6571-434d-8af5-d5142397285c","timestamp":"2026-02-28T23:44:32.859Z"}
{"parentUuid":"964c2282-6571-434d-8af5-d5142397285c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CxrcqxcHeHKSmSsbUYyqFY","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.test.ts has been updated successfully."}]},"uuid":"38c965b0-4fae-4a20-9826-8c4fe630e692","timestamp":"2026-02-28T23:44:32.879Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","oldString":"  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"WHISPER\", () => {","newString":"  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {","originalFile":"import { test, expect, describe, jest, afterEach } from \"bun:test\";\nimport { unlink } from \"node:fs/promises\";\nimport {\n  parseIpcCommand,\n  dispatchCommand,\n  onChatMessage,\n  onGroupEvent,\n  onEntityEvent,\n  onFriendEvent,\n  writeLines,\n  type EventEntry,\n} from \"daemon/commands\";\nimport { startDaemonServer } from \"daemon/server\";\nimport { sendToSocket } from \"cli/ipc\";\nimport { RingBuffer } from \"lib/ring-buffer\";\nimport { ChatType } from \"wow/protocol/opcodes\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  UnitEntity,\n  GameObjectEntity,\n  BaseEntity,\n} from \"wow/entity-store\";\nimport { SessionLog } from \"lib/session-log\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction createMockSocket(): {\n  write: ReturnType<typeof jest.fn>;\n  end: ReturnType<typeof jest.fn>;\n  written(): string;\n} {\n  const chunks: string[] = [];\n  return {\n    write: jest.fn((data: string | Uint8Array) => {\n      chunks.push(\n        typeof data === \"string\" ? data : Buffer.from(data).toString(),\n      );\n      return (typeof data === \"string\" ? data : Buffer.from(data).toString())\n        .length;\n    }),\n    end: jest.fn(),\n    written() {\n      return chunks.join(\"\");\n    },\n  };\n}\n\ndescribe(\"parseIpcCommand\", () => {\n  test(\"SAY\", () => {\n    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n      type: \"say\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });\n\n  test(\"READ_WAIT\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 3000\")).toEqual({\n      type: \"read_wait\",\n      ms: 3000,\n    });\n  });\n\n  test(\"STOP\", () => {\n    expect(parseIpcCommand(\"STOP\")).toEqual({ type: \"stop\" });\n  });\n\n  test(\"STATUS\", () => {\n    expect(parseIpcCommand(\"STATUS\")).toEqual({ type: \"status\" });\n  });\n\n  test(\"WHO without filter\", () => {\n    expect(parseIpcCommand(\"WHO\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"WHO with filter\", () => {\n    expect(parseIpcCommand(\"WHO mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"READ_JSON\", () => {\n    expect(parseIpcCommand(\"READ_JSON\")).toEqual({ type: \"read_json\" });\n  });\n\n  test(\"READ_WAIT_JSON\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 2000\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 2000,\n    });\n  });\n\n  test(\"WHO_JSON without filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON\")).toEqual({ type: \"who_json\" });\n  });\n\n  test(\"WHO_JSON with filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON mage\")).toEqual({\n      type: \"who_json\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"INVITE\", () => {\n    expect(parseIpcCommand(\"INVITE Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"KICK\", () => {\n    expect(parseIpcCommand(\"KICK Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"LEAVE\", () => {\n    expect(parseIpcCommand(\"LEAVE\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"LEADER\", () => {\n    expect(parseIpcCommand(\"LEADER Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"ACCEPT\", () => {\n    expect(parseIpcCommand(\"ACCEPT\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"DECLINE\", () => {\n    expect(parseIpcCommand(\"DECLINE\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"NEARBY\", () => {\n    expect(parseIpcCommand(\"NEARBY\")).toEqual({ type: \"nearby\" });\n  });\n\n  test(\"NEARBY_JSON\", () => {\n    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n  });\n\n  test(\"slash /accept maps to accept\", () => {\n    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"slash /say maps to say\", () => {\n    expect(parseIpcCommand(\"/say hello\")).toEqual({\n      type: \"say\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"slash /whisper maps to whisper\", () => {\n    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {\n    expect(parseIpcCommand(\"/who mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"slash /who maps to who without filter\", () => {\n    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"slash /invite maps to invite\", () => {\n    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /kick maps to kick\", () => {\n    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /leave maps to leave\", () => {\n    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"slash /friends maps to friends\", () => {\n    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"slash /ignore maps to unimplemented\", () => {\n    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n      type: \"unimplemented\",\n      feature: \"Ignore list\",\n    });\n  });\n\n  test(\"unknown slash command maps to say with full input\", () => {\n    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"slash command unsupported by daemon falls back to say\", () => {\n    expect(parseIpcCommand(\"/r hello\")).toEqual({\n      type: \"say\",\n      message: \"/r hello\",\n    });\n  });\n\n  test(\"INVITE with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"INVITE\")).toBeUndefined();\n  });\n\n  test(\"KICK with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"KICK\")).toBeUndefined();\n  });\n\n  test(\"LEADER with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"LEADER\")).toBeUndefined();\n  });\n\n  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n\n  test(\"unrecognized verb becomes chat\", () => {\n    expect(parseIpcCommand(\"DANCE\")).toEqual({\n      type: \"chat\",\n      message: \"DANCE\",\n    });\n  });\n\n  test(\"unrecognized text becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello world\")).toEqual({\n      type: \"chat\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"single word becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello\")).toEqual({\n      type: \"chat\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"empty string returns undefined\", () => {\n    expect(parseIpcCommand(\"\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with non-numeric argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT abc\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with negative value returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT -100\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 120000\")).toEqual({\n      type: \"read_wait\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"READ_WAIT_JSON with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT_JSON clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 999999\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"FRIENDS\", () => {\n    expect(parseIpcCommand(\"FRIENDS\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"FRIENDS_JSON\", () => {\n    expect(parseIpcCommand(\"FRIENDS_JSON\")).toEqual({ type: \"friends_json\" });\n  });\n\n  test(\"ADD_FRIEND\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"ADD_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"DEL_FRIEND\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"DEL_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"slash /friend add maps to add_friend\", () => {\n    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"slash /friend remove maps to del_friend\", () => {\n    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n});\n\ndescribe(\"dispatchCommand\", () => {\n  test(\"say calls sendSay and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"say\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"yell calls sendYell and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"yell\", message: \"HEY\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"party\", message: \"pull\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"[say] Alice: hi\\n[say] Bob: hey\\n\\n\");\n  });\n\n  test(\"read on empty buffer writes just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"read_wait delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n      expect(events.drain()).toEqual([\n        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n      ]);\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"status writes CONNECTED\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"status\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n  });\n\n  test(\"stop calls cleanup and returns true\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"stop\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(true);\n    expect(cleanup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who passes filter and formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    expect(socket.written()).toContain(\"[who] 1 results: Test (80)\");\n  });\n\n  test(\"who without filter passes empty object\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"who\" }, handle, events, socket, cleanup);\n\n    expect(handle.who).toHaveBeenCalledWith({});\n  });\n\n  test(\"read_json drains ring buffer json\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({\n      text: \"[say] Alice: hi\",\n      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n    });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"read_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\n      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n    );\n  });\n\n  test(\"read_wait_json delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait_json returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"old\":true}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"new\":true}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"new\":true}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"invite calls handle.invite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"invite\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"kick calls handle.uninvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"kick\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leave calls handle.leaveGroup and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"leave\" }, handle, events, socket, cleanup);\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leader calls handle.setLeader and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"leader\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"accept calls handle.acceptInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"accept\" }, handle, events, socket, cleanup);\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"decline calls handle.declineInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"decline\" }, handle, events, socket, cleanup);\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who_json returns JSON formatted results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who_json\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"WHO\");\n    expect(parsed.count).toBe(1);\n    expect(parsed.results[0].name).toBe(\"Test\");\n  });\n\n  test(\"nearby returns formatted entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.5, y: 4.6, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 19,\n      bytes1: 0,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n      testGo,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Thrall (NPC, level 80) HP 5000/5000 at 1.23, 4.56, 7.89\",\n    );\n    expect(output).toContain(\"Mailbox (GameObject) at 1.50, 4.60, 7.89\");\n  });\n\n  test(\"nearby_json returns JSONL entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.guid).toBe(\"0x1\");\n    expect(parsed.type).toBe(\"unit\");\n    expect(parsed.name).toBe(\"Thrall\");\n    expect(parsed.level).toBe(80);\n    expect(parsed.health).toBe(5000);\n    expect(parsed.maxHealth).toBe(5000);\n    expect(parsed.x).toBe(1.23);\n    expect(parsed.y).toBe(4.56);\n    expect(parsed.z).toBe(7.89);\n  });\n\n  test(\"nearby with no entities returns just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"nearby formats player entity\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 10n,\n      objectType: ObjectType.PLAYER,\n      name: \"Arthas\",\n      level: 55,\n      health: 3000,\n      maxHealth: 4000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 0, x: 10.0, y: 20.0, z: 30.0, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Arthas (Player, level 55) HP 3000/4000 at 10.00, 20.00, 30.00\",\n    );\n  });\n\n  test(\"nearby formats unknown entity type\", async () => {\n    const handle = createMockHandle();\n    const testCorpse: BaseEntity = {\n      guid: 0xabn,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\"Entity 0xab (type 7)\");\n  });\n\n  test(\"nearby_json formats player and gameobject types\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.PLAYER,\n      name: \"Jaina\",\n      level: 70,\n      health: 8000,\n      maxHealth: 8000,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Chest\",\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 3,\n      bytes1: 0,\n    };\n    const testCorpse: BaseEntity = {\n      guid: 3n,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n      testGo,\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    expect(lines).toHaveLength(3);\n    const player = JSON.parse(lines[0]!);\n    const go = JSON.parse(lines[1]!);\n    const corpse = JSON.parse(lines[2]!);\n    expect(player.type).toBe(\"player\");\n    expect(player.level).toBe(70);\n    expect(player.health).toBe(8000);\n    expect(go.type).toBe(\"gameobject\");\n    expect(go.gameObjectType).toBe(3);\n    expect(corpse.type).toBe(\"object\");\n  });\n\n  test(\"friends calls getFriends and writes friend list\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"friends\" }, handle, events, socket, cleanup);\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(socket.written()).toContain(\"No friends on your list\");\n  });\n\n  test(\"friends_json calls getFriends and writes JSON\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"friends_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"FRIENDS\");\n    expect(parsed.count).toBe(0);\n  });\n\n  test(\"add_friend calls handle.addFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"add_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"del_friend calls handle.removeFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"del_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"unimplemented writes UNIMPLEMENTED response\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"unimplemented\", feature: \"Friends list\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(socket.written()).toBe(\"UNIMPLEMENTED Friends list\\n\\n\");\n  });\n\n  test(\"chat sends via sendInCurrentMode and responds with mode\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"say\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"chat\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n  });\n\n  test(\"chat mode label includes whisper target\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"whisper\",\n      target: \"Xiara\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"follow me\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK WHISPER Xiara\\n\\n\");\n  });\n\n  test(\"chat mode label includes channel name\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"channel\",\n      channel: \"General\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"hello general\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK CHANNEL General\\n\\n\");\n  });\n});\n\ndescribe(\"writeLines\", () => {\n  test(\"writes each line with newline then blank terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, [\"line1\", \"line2\"]);\n    expect(socket.written()).toBe(\"line1\\nline2\\n\\n\");\n  });\n\n  test(\"empty array writes just terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, []);\n    expect(socket.written()).toBe(\"\\n\");\n  });\n});\n\ndescribe(\"onChatMessage\", () => {\n  test(\"pushes formatted message to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"appends JSON to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"swallows session log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onGroupEvent\", () => {\n  test(\"pushes group_list with undefined text to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"group_list\",\n        members: [{ name: \"Alice\", guidLow: 1, guidHigh: 0, online: true }],\n        leader: \"Alice\",\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toBeUndefined();\n    expect(JSON.parse(drained[0]!.json)).toMatchObject({ type: \"GROUP_LIST\" });\n  });\n\n  test(\"pushes member_stats to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent(\n      { type: \"member_stats\", guidLow: 42, hp: 100, maxHp: 200 },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith(\n      expect.objectContaining({ type: \"PARTY_MEMBER_STATS\", guidLow: 42 }),\n    );\n  });\n\n  test(\"swallows group event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n\n  test(\"pushes displayable events with text\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"invite_received\", from: \"Bob\" }, events, log);\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[group] Bob invites you to a group\");\n  });\n\n  test(\"serializes command_result event details\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"command_result\",\n        operation: 1,\n        target: \"Voidtrix\",\n        result: 0,\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"GROUP_COMMAND_RESULT\",\n      operation: 1,\n      target: \"Voidtrix\",\n      result: 0,\n    });\n  });\n\n  test(\"serializes leader/group lifecycle events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"leader_changed\", name: \"Alice\" }, events, log);\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    onGroupEvent({ type: \"kicked\" }, events, log);\n    onGroupEvent({ type: \"invite_declined\", name: \"Bob\" }, events, log);\n\n    const drained = events.drain().map((entry) => JSON.parse(entry.json));\n    expect(drained).toEqual([\n      { type: \"GROUP_LEADER_CHANGED\", name: \"Alice\" },\n      { type: \"GROUP_DESTROYED\" },\n      { type: \"GROUP_KICKED\" },\n      { type: \"GROUP_INVITE_DECLINED\", name: \"Bob\" },\n    ]);\n  });\n});\n\ndescribe(\"onEntityEvent\", () => {\n  test(\"pushes appear event to ring buffer with text and json\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"appear\", entity }, events, log);\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Test NPC\");\n    expect(drained[0]!.text).toContain(\"appeared\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_APPEAR\");\n    expect(json.name).toBe(\"Test NPC\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes disappear event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Gone NPC\");\n    expect(drained[0]!.text).toContain(\"left range\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_DISAPPEAR\");\n  });\n\n  test(\"skips update events with no obj\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"update\", entity, changed: [\"health\"] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"swallows entity event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onFriendEvent\", () => {\n  test(\"pushes friend-online event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      {\n        type: \"friend-online\",\n        friend: {\n          guid: 1n,\n          name: \"Arthas\",\n          note: \"\",\n          status: FriendStatus.ONLINE,\n          area: 0,\n          level: 80,\n          playerClass: 6,\n        },\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"online\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ONLINE\");\n    expect(json.name).toBe(\"Arthas\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes friend-offline event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Arthas\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"offline\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_OFFLINE\");\n  });\n\n  test(\"skips friend-list events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent({ type: \"friend-list\", friends: [] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"pushes friend-error event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-error\", result: 0x04, name: \"Nobody\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"player not found\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ERROR\");\n    expect(json.result).toBe(0x04);\n  });\n\n  test(\"swallows friend event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Gone\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"IPC round-trip\", () => {\n  let sockCounter = 0;\n  let sockPath: string;\n  let handle: ReturnType<typeof createMockHandle>;\n  let result: ReturnType<typeof startDaemonServer>;\n  let exitSpy: ReturnType<typeof jest.fn>;\n\n  function startTestServer(opts?: { onActivity?: () => void }) {\n    sockPath = `./tmp/test-daemon-${++sockCounter}-${Date.now()}.sock`;\n    handle = createMockHandle();\n    const log = new SessionLog(`./tmp/test-daemon-${sockCounter}.jsonl`);\n    exitSpy = jest\n      .spyOn(process, \"exit\")\n      .mockImplementation(() => undefined as never);\n    result = startDaemonServer({ handle, sock: sockPath, log, ...opts });\n  }\n\n  afterEach(async () => {\n    exitSpy?.mockRestore();\n    result?.cleanup();\n  });\n\n  test(\"STATUS returns CONNECTED\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STATUS\", sockPath);\n    expect(lines).toEqual([\"CONNECTED\"]);\n  });\n\n  test(\"SAY returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {\n    startTestServer();\n    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n  });\n\n  test(\"bare text sends via sticky mode\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"hello world\", sockPath);\n    expect(lines[0]).toMatch(/^OK /);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"empty command returns ERR\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"\", sockPath);\n    expect(lines).toEqual([\"ERR unknown command\"]);\n  });\n\n  test(\"sendToSocket rejects on missing socket\", async () => {\n    await expect(\n      sendToSocket(\"STATUS\", \"./tmp/nonexistent.sock\"),\n    ).rejects.toThrow();\n  });\n\n  test(\"onActivity fires on each IPC command\", async () => {\n    const activity = jest.fn();\n    startTestServer({ onActivity: activity });\n    await sendToSocket(\"STATUS\", sockPath);\n    await sendToSocket(\"STATUS\", sockPath);\n    expect(activity).toHaveBeenCalledTimes(2);\n  });\n\n  test(\"cleanup closes handle and stops server\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalled();\n    await expect(sendToSocket(\"STATUS\", sockPath)).rejects.toThrow();\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    startTestServer();\n    result.cleanup();\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"cleanup ignores missing socket file\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    await unlink(sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP triggers process.exit\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STOP\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    await Bun.sleep(0);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"buffers split command chunks before parsing\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-split-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-split-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STA\"));\n      capturedData!(socket, Buffer.from(\"TUS\\n\"));\n      await Promise.resolve();\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"processes multiple commands from a single chunk\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-multi-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-multi-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STATUS\\nSTATUS\\n\"));\n      await Bun.sleep(0);\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\nCONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"onMessage wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\"]);\n  });\n\n  test(\"onGroupEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerGroupEvent({ type: \"group_destroyed\" });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[group] Group has been disbanded\"]);\n  });\n\n  test(\"onFriendEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        level: 80,\n        playerClass: 1,\n        area: 0,\n        status: 0,\n        note: \"\",\n      },\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Arthas\");\n  });\n\n  test(\"onEntityEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Test NPC\");\n  });\n\n  test(\"onEntityEvent wiring round-trip via READ_JSON\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ_JSON\", sockPath);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.type).toBe(\"ENTITY_APPEAR\");\n    expect(parsed.name).toBe(\"Test NPC\");\n  });\n\n  test(\"NEARBY round-trip returns formatted entities\", async () => {\n    startTestServer();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const lines = await sendToSocket(\"NEARBY\", sockPath);\n    expect(lines[0]).toContain(\"Thrall\");\n    expect(lines[0]).toContain(\"level 80\");\n  });\n\n  test(\"dispatch error returns ERR internal\", async () => {\n    startTestServer();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"db fail\"),\n    );\n    const lines = await sendToSocket(\"WHO\", sockPath);\n    expect(lines).toEqual([\"ERR internal\"]);\n  });\n});\n","structuredPatch":[{"oldStart":74,"oldLines":6,"newStart":74,"newLines":13,"lines":["     });","   });"," ","+  test(\"EMOTE\", () => {","+    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({","+      type: \"emote\",","+      message: \"waves hello\",","+    });","+  });","+","   test(\"WHISPER\", () => {","     expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({","       type: \"whisper\","]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"964c2282-6571-434d-8af5-d5142397285c"}
{"parentUuid":"38c965b0-4fae-4a20-9826-8c4fe630e692","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0199JK9TySUhxq2xo2Da3kCV","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the slash command parse test for `/emote` in the IPC section. Let me find where slash commands are tested in the IPC test."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":334,"cache_read_input_tokens":87933,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":334},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMbroPr2Nb4BpXRziou","type":"assistant","uuid":"d5d33dd8-78df-4afe-a2a8-d570adaa82d5","timestamp":"2026-02-28T23:44:36.732Z"}
{"parentUuid":"d5d33dd8-78df-4afe-a2a8-d570adaa82d5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0199JK9TySUhxq2xo2Da3kCV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MUkK7zSieii9Fvs5J1aYba","name":"Grep","input":{"pattern":"slash.*say|/say.*returns|parseIpc.*slash|parseIpc.*/","path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":334,"cache_read_input_tokens":87933,"output_tokens":178,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":334,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMbroPr2Nb4BpXRziou","type":"assistant","uuid":"89bacc45-aa23-402f-bedf-317cc6c1db5d","timestamp":"2026-02-28T23:44:38.620Z"}
{"parentUuid":"89bacc45-aa23-402f-bedf-317cc6c1db5d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MUkK7zSieii9Fvs5J1aYba","type":"tool_result","content":"189-  test(\"NEARBY_JSON\", () => {\n190-    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n191-  });\n192-\n193-  test(\"slash /accept maps to accept\", () => {\n194:    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n195-  });\n196-\n197:  test(\"slash /say maps to say\", () => {\n198:    expect(parseIpcCommand(\"/say hello\")).toEqual({\n199-      type: \"say\",\n200-      message: \"hello\",\n201-    });\n202-  });\n203-\n204-  test(\"slash /whisper maps to whisper\", () => {\n205:    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n206-      type: \"whisper\",\n207-      target: \"Xiara\",\n208-      message: \"hi\",\n209-    });\n210-  });\n211-\n212-  test(\"slash /who maps to who with filter\", () => {\n213:    expect(parseIpcCommand(\"/who mage\")).toEqual({\n214-      type: \"who\",\n215-      filter: \"mage\",\n216-    });\n217-  });\n218-\n219-  test(\"slash /who maps to who without filter\", () => {\n220:    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n221-  });\n222-\n223-  test(\"slash /invite maps to invite\", () => {\n224:    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n225-      type: \"invite\",\n226-      target: \"Voidtrix\",\n227-    });\n228-  });\n229-\n230-  test(\"slash /kick maps to kick\", () => {\n231:    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n232-      type: \"kick\",\n233-      target: \"Voidtrix\",\n234-    });\n235-  });\n236-\n237-  test(\"slash /leave maps to leave\", () => {\n238:    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n239-  });\n240-\n241-  test(\"slash /friends maps to friends\", () => {\n242:    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n243-  });\n244-\n245-  test(\"slash /ignore maps to unimplemented\", () => {\n246:    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n247-      type: \"unimplemented\",\n248-      feature: \"Ignore list\",\n249-    });\n250-  });\n251-\n252:  test(\"unknown slash command maps to say with full input\", () => {\n253:    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n254-      type: \"say\",\n255-      message: \"/dance hello\",\n256-    });\n257-  });\n258-\n259:  test(\"slash command unsupported by daemon falls back to say\", () => {\n260:    expect(parseIpcCommand(\"/r hello\")).toEqual({\n261-      type: \"say\",\n262-      message: \"/r hello\",\n263-    });\n264-  });\n265-\n--\n384-  test(\"DEL_FRIEND with no target returns undefined\", () => {\n385-    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n386-  });\n387-\n388-  test(\"slash /friend add maps to add_friend\", () => {\n389:    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n390-      type: \"add_friend\",\n391-      target: \"Arthas\",\n392-    });\n393-  });\n394-\n395-  test(\"slash /friend remove maps to del_friend\", () => {\n396:    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n397-      type: \"del_friend\",\n398-      target: \"Arthas\",\n399-    });\n400-  });\n401-});"}]},"uuid":"7edd37c4-acbd-4d35-b753-5eb2859efa26","timestamp":"2026-02-28T23:44:38.702Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"189-  test(\"NEARBY_JSON\", () => {\n190-    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n191-  });\n192-\n193-  test(\"slash /accept maps to accept\", () => {\n194:    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n195-  });\n196-\n197:  test(\"slash /say maps to say\", () => {\n198:    expect(parseIpcCommand(\"/say hello\")).toEqual({\n199-      type: \"say\",\n200-      message: \"hello\",\n201-    });\n202-  });\n203-\n204-  test(\"slash /whisper maps to whisper\", () => {\n205:    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n206-      type: \"whisper\",\n207-      target: \"Xiara\",\n208-      message: \"hi\",\n209-    });\n210-  });\n211-\n212-  test(\"slash /who maps to who with filter\", () => {\n213:    expect(parseIpcCommand(\"/who mage\")).toEqual({\n214-      type: \"who\",\n215-      filter: \"mage\",\n216-    });\n217-  });\n218-\n219-  test(\"slash /who maps to who without filter\", () => {\n220:    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n221-  });\n222-\n223-  test(\"slash /invite maps to invite\", () => {\n224:    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n225-      type: \"invite\",\n226-      target: \"Voidtrix\",\n227-    });\n228-  });\n229-\n230-  test(\"slash /kick maps to kick\", () => {\n231:    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n232-      type: \"kick\",\n233-      target: \"Voidtrix\",\n234-    });\n235-  });\n236-\n237-  test(\"slash /leave maps to leave\", () => {\n238:    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n239-  });\n240-\n241-  test(\"slash /friends maps to friends\", () => {\n242:    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n243-  });\n244-\n245-  test(\"slash /ignore maps to unimplemented\", () => {\n246:    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n247-      type: \"unimplemented\",\n248-      feature: \"Ignore list\",\n249-    });\n250-  });\n251-\n252:  test(\"unknown slash command maps to say with full input\", () => {\n253:    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n254-      type: \"say\",\n255-      message: \"/dance hello\",\n256-    });\n257-  });\n258-\n259:  test(\"slash command unsupported by daemon falls back to say\", () => {\n260:    expect(parseIpcCommand(\"/r hello\")).toEqual({\n261-      type: \"say\",\n262-      message: \"/r hello\",\n263-    });\n264-  });\n265-\n--\n384-  test(\"DEL_FRIEND with no target returns undefined\", () => {\n385-    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n386-  });\n387-\n388-  test(\"slash /friend add maps to add_friend\", () => {\n389:    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n390-      type: \"add_friend\",\n391-      target: \"Arthas\",\n392-    });\n393-  });\n394-\n395-  test(\"slash /friend remove maps to del_friend\", () => {\n396:    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n397-      type: \"del_friend\",\n398-      target: \"Arthas\",\n399-    });\n400-  });\n401-});","numLines":96},"sourceToolAssistantUUID":"89bacc45-aa23-402f-bedf-317cc6c1db5d"}
{"parentUuid":"7edd37c4-acbd-4d35-b753-5eb2859efa26","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01N7DazM7dNqLXzotwW9qkVK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K2DQps7uscDJM6e21FtQEu","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","old_string":"  test(\"slash /who maps to who with filter\", () => {","new_string":"  test(\"slash /emote maps to emote\", () => {\n    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n      type: \"emote\",\n      message: \"waves\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1194,"cache_read_input_tokens":88267,"output_tokens":211,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1194,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMcGd7UkxPcX29y35qr","type":"assistant","uuid":"a52c701b-e24a-48d5-b57b-d3a8445c41a2","timestamp":"2026-02-28T23:44:43.165Z"}
{"parentUuid":"a52c701b-e24a-48d5-b57b-d3a8445c41a2","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K2DQps7uscDJM6e21FtQEu","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.test.ts has been updated successfully."}]},"uuid":"b03480af-c8c5-40a0-878e-2185406fb94c","timestamp":"2026-02-28T23:44:43.174Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","oldString":"  test(\"slash /who maps to who with filter\", () => {","newString":"  test(\"slash /emote maps to emote\", () => {\n    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n      type: \"emote\",\n      message: \"waves\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {","originalFile":"import { test, expect, describe, jest, afterEach } from \"bun:test\";\nimport { unlink } from \"node:fs/promises\";\nimport {\n  parseIpcCommand,\n  dispatchCommand,\n  onChatMessage,\n  onGroupEvent,\n  onEntityEvent,\n  onFriendEvent,\n  writeLines,\n  type EventEntry,\n} from \"daemon/commands\";\nimport { startDaemonServer } from \"daemon/server\";\nimport { sendToSocket } from \"cli/ipc\";\nimport { RingBuffer } from \"lib/ring-buffer\";\nimport { ChatType } from \"wow/protocol/opcodes\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  UnitEntity,\n  GameObjectEntity,\n  BaseEntity,\n} from \"wow/entity-store\";\nimport { SessionLog } from \"lib/session-log\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction createMockSocket(): {\n  write: ReturnType<typeof jest.fn>;\n  end: ReturnType<typeof jest.fn>;\n  written(): string;\n} {\n  const chunks: string[] = [];\n  return {\n    write: jest.fn((data: string | Uint8Array) => {\n      chunks.push(\n        typeof data === \"string\" ? data : Buffer.from(data).toString(),\n      );\n      return (typeof data === \"string\" ? data : Buffer.from(data).toString())\n        .length;\n    }),\n    end: jest.fn(),\n    written() {\n      return chunks.join(\"\");\n    },\n  };\n}\n\ndescribe(\"parseIpcCommand\", () => {\n  test(\"SAY\", () => {\n    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n      type: \"say\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });\n\n  test(\"READ_WAIT\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 3000\")).toEqual({\n      type: \"read_wait\",\n      ms: 3000,\n    });\n  });\n\n  test(\"STOP\", () => {\n    expect(parseIpcCommand(\"STOP\")).toEqual({ type: \"stop\" });\n  });\n\n  test(\"STATUS\", () => {\n    expect(parseIpcCommand(\"STATUS\")).toEqual({ type: \"status\" });\n  });\n\n  test(\"WHO without filter\", () => {\n    expect(parseIpcCommand(\"WHO\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"WHO with filter\", () => {\n    expect(parseIpcCommand(\"WHO mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"READ_JSON\", () => {\n    expect(parseIpcCommand(\"READ_JSON\")).toEqual({ type: \"read_json\" });\n  });\n\n  test(\"READ_WAIT_JSON\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 2000\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 2000,\n    });\n  });\n\n  test(\"WHO_JSON without filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON\")).toEqual({ type: \"who_json\" });\n  });\n\n  test(\"WHO_JSON with filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON mage\")).toEqual({\n      type: \"who_json\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"INVITE\", () => {\n    expect(parseIpcCommand(\"INVITE Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"KICK\", () => {\n    expect(parseIpcCommand(\"KICK Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"LEAVE\", () => {\n    expect(parseIpcCommand(\"LEAVE\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"LEADER\", () => {\n    expect(parseIpcCommand(\"LEADER Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"ACCEPT\", () => {\n    expect(parseIpcCommand(\"ACCEPT\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"DECLINE\", () => {\n    expect(parseIpcCommand(\"DECLINE\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"NEARBY\", () => {\n    expect(parseIpcCommand(\"NEARBY\")).toEqual({ type: \"nearby\" });\n  });\n\n  test(\"NEARBY_JSON\", () => {\n    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n  });\n\n  test(\"slash /accept maps to accept\", () => {\n    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"slash /say maps to say\", () => {\n    expect(parseIpcCommand(\"/say hello\")).toEqual({\n      type: \"say\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"slash /whisper maps to whisper\", () => {\n    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {\n    expect(parseIpcCommand(\"/who mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"slash /who maps to who without filter\", () => {\n    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"slash /invite maps to invite\", () => {\n    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /kick maps to kick\", () => {\n    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /leave maps to leave\", () => {\n    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"slash /friends maps to friends\", () => {\n    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"slash /ignore maps to unimplemented\", () => {\n    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n      type: \"unimplemented\",\n      feature: \"Ignore list\",\n    });\n  });\n\n  test(\"unknown slash command maps to say with full input\", () => {\n    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"slash command unsupported by daemon falls back to say\", () => {\n    expect(parseIpcCommand(\"/r hello\")).toEqual({\n      type: \"say\",\n      message: \"/r hello\",\n    });\n  });\n\n  test(\"INVITE with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"INVITE\")).toBeUndefined();\n  });\n\n  test(\"KICK with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"KICK\")).toBeUndefined();\n  });\n\n  test(\"LEADER with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"LEADER\")).toBeUndefined();\n  });\n\n  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n\n  test(\"unrecognized verb becomes chat\", () => {\n    expect(parseIpcCommand(\"DANCE\")).toEqual({\n      type: \"chat\",\n      message: \"DANCE\",\n    });\n  });\n\n  test(\"unrecognized text becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello world\")).toEqual({\n      type: \"chat\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"single word becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello\")).toEqual({\n      type: \"chat\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"empty string returns undefined\", () => {\n    expect(parseIpcCommand(\"\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with non-numeric argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT abc\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with negative value returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT -100\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 120000\")).toEqual({\n      type: \"read_wait\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"READ_WAIT_JSON with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT_JSON clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 999999\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"FRIENDS\", () => {\n    expect(parseIpcCommand(\"FRIENDS\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"FRIENDS_JSON\", () => {\n    expect(parseIpcCommand(\"FRIENDS_JSON\")).toEqual({ type: \"friends_json\" });\n  });\n\n  test(\"ADD_FRIEND\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"ADD_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"DEL_FRIEND\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"DEL_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"slash /friend add maps to add_friend\", () => {\n    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"slash /friend remove maps to del_friend\", () => {\n    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n});\n\ndescribe(\"dispatchCommand\", () => {\n  test(\"say calls sendSay and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"say\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"yell calls sendYell and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"yell\", message: \"HEY\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"party\", message: \"pull\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"[say] Alice: hi\\n[say] Bob: hey\\n\\n\");\n  });\n\n  test(\"read on empty buffer writes just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"read_wait delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n      expect(events.drain()).toEqual([\n        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n      ]);\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"status writes CONNECTED\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"status\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n  });\n\n  test(\"stop calls cleanup and returns true\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"stop\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(true);\n    expect(cleanup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who passes filter and formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    expect(socket.written()).toContain(\"[who] 1 results: Test (80)\");\n  });\n\n  test(\"who without filter passes empty object\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"who\" }, handle, events, socket, cleanup);\n\n    expect(handle.who).toHaveBeenCalledWith({});\n  });\n\n  test(\"read_json drains ring buffer json\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({\n      text: \"[say] Alice: hi\",\n      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n    });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"read_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\n      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n    );\n  });\n\n  test(\"read_wait_json delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait_json returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"old\":true}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"new\":true}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"new\":true}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"invite calls handle.invite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"invite\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"kick calls handle.uninvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"kick\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leave calls handle.leaveGroup and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"leave\" }, handle, events, socket, cleanup);\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leader calls handle.setLeader and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"leader\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"accept calls handle.acceptInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"accept\" }, handle, events, socket, cleanup);\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"decline calls handle.declineInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"decline\" }, handle, events, socket, cleanup);\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who_json returns JSON formatted results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who_json\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"WHO\");\n    expect(parsed.count).toBe(1);\n    expect(parsed.results[0].name).toBe(\"Test\");\n  });\n\n  test(\"nearby returns formatted entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.5, y: 4.6, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 19,\n      bytes1: 0,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n      testGo,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Thrall (NPC, level 80) HP 5000/5000 at 1.23, 4.56, 7.89\",\n    );\n    expect(output).toContain(\"Mailbox (GameObject) at 1.50, 4.60, 7.89\");\n  });\n\n  test(\"nearby_json returns JSONL entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.guid).toBe(\"0x1\");\n    expect(parsed.type).toBe(\"unit\");\n    expect(parsed.name).toBe(\"Thrall\");\n    expect(parsed.level).toBe(80);\n    expect(parsed.health).toBe(5000);\n    expect(parsed.maxHealth).toBe(5000);\n    expect(parsed.x).toBe(1.23);\n    expect(parsed.y).toBe(4.56);\n    expect(parsed.z).toBe(7.89);\n  });\n\n  test(\"nearby with no entities returns just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"nearby formats player entity\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 10n,\n      objectType: ObjectType.PLAYER,\n      name: \"Arthas\",\n      level: 55,\n      health: 3000,\n      maxHealth: 4000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 0, x: 10.0, y: 20.0, z: 30.0, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Arthas (Player, level 55) HP 3000/4000 at 10.00, 20.00, 30.00\",\n    );\n  });\n\n  test(\"nearby formats unknown entity type\", async () => {\n    const handle = createMockHandle();\n    const testCorpse: BaseEntity = {\n      guid: 0xabn,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\"Entity 0xab (type 7)\");\n  });\n\n  test(\"nearby_json formats player and gameobject types\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.PLAYER,\n      name: \"Jaina\",\n      level: 70,\n      health: 8000,\n      maxHealth: 8000,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Chest\",\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 3,\n      bytes1: 0,\n    };\n    const testCorpse: BaseEntity = {\n      guid: 3n,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n      testGo,\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    expect(lines).toHaveLength(3);\n    const player = JSON.parse(lines[0]!);\n    const go = JSON.parse(lines[1]!);\n    const corpse = JSON.parse(lines[2]!);\n    expect(player.type).toBe(\"player\");\n    expect(player.level).toBe(70);\n    expect(player.health).toBe(8000);\n    expect(go.type).toBe(\"gameobject\");\n    expect(go.gameObjectType).toBe(3);\n    expect(corpse.type).toBe(\"object\");\n  });\n\n  test(\"friends calls getFriends and writes friend list\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"friends\" }, handle, events, socket, cleanup);\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(socket.written()).toContain(\"No friends on your list\");\n  });\n\n  test(\"friends_json calls getFriends and writes JSON\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"friends_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"FRIENDS\");\n    expect(parsed.count).toBe(0);\n  });\n\n  test(\"add_friend calls handle.addFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"add_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"del_friend calls handle.removeFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"del_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"unimplemented writes UNIMPLEMENTED response\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"unimplemented\", feature: \"Friends list\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(socket.written()).toBe(\"UNIMPLEMENTED Friends list\\n\\n\");\n  });\n\n  test(\"chat sends via sendInCurrentMode and responds with mode\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"say\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"chat\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n  });\n\n  test(\"chat mode label includes whisper target\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"whisper\",\n      target: \"Xiara\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"follow me\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK WHISPER Xiara\\n\\n\");\n  });\n\n  test(\"chat mode label includes channel name\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"channel\",\n      channel: \"General\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"hello general\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK CHANNEL General\\n\\n\");\n  });\n});\n\ndescribe(\"writeLines\", () => {\n  test(\"writes each line with newline then blank terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, [\"line1\", \"line2\"]);\n    expect(socket.written()).toBe(\"line1\\nline2\\n\\n\");\n  });\n\n  test(\"empty array writes just terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, []);\n    expect(socket.written()).toBe(\"\\n\");\n  });\n});\n\ndescribe(\"onChatMessage\", () => {\n  test(\"pushes formatted message to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"appends JSON to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"swallows session log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onGroupEvent\", () => {\n  test(\"pushes group_list with undefined text to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"group_list\",\n        members: [{ name: \"Alice\", guidLow: 1, guidHigh: 0, online: true }],\n        leader: \"Alice\",\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toBeUndefined();\n    expect(JSON.parse(drained[0]!.json)).toMatchObject({ type: \"GROUP_LIST\" });\n  });\n\n  test(\"pushes member_stats to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent(\n      { type: \"member_stats\", guidLow: 42, hp: 100, maxHp: 200 },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith(\n      expect.objectContaining({ type: \"PARTY_MEMBER_STATS\", guidLow: 42 }),\n    );\n  });\n\n  test(\"swallows group event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n\n  test(\"pushes displayable events with text\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"invite_received\", from: \"Bob\" }, events, log);\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[group] Bob invites you to a group\");\n  });\n\n  test(\"serializes command_result event details\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"command_result\",\n        operation: 1,\n        target: \"Voidtrix\",\n        result: 0,\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"GROUP_COMMAND_RESULT\",\n      operation: 1,\n      target: \"Voidtrix\",\n      result: 0,\n    });\n  });\n\n  test(\"serializes leader/group lifecycle events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"leader_changed\", name: \"Alice\" }, events, log);\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    onGroupEvent({ type: \"kicked\" }, events, log);\n    onGroupEvent({ type: \"invite_declined\", name: \"Bob\" }, events, log);\n\n    const drained = events.drain().map((entry) => JSON.parse(entry.json));\n    expect(drained).toEqual([\n      { type: \"GROUP_LEADER_CHANGED\", name: \"Alice\" },\n      { type: \"GROUP_DESTROYED\" },\n      { type: \"GROUP_KICKED\" },\n      { type: \"GROUP_INVITE_DECLINED\", name: \"Bob\" },\n    ]);\n  });\n});\n\ndescribe(\"onEntityEvent\", () => {\n  test(\"pushes appear event to ring buffer with text and json\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"appear\", entity }, events, log);\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Test NPC\");\n    expect(drained[0]!.text).toContain(\"appeared\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_APPEAR\");\n    expect(json.name).toBe(\"Test NPC\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes disappear event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Gone NPC\");\n    expect(drained[0]!.text).toContain(\"left range\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_DISAPPEAR\");\n  });\n\n  test(\"skips update events with no obj\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"update\", entity, changed: [\"health\"] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"swallows entity event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onFriendEvent\", () => {\n  test(\"pushes friend-online event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      {\n        type: \"friend-online\",\n        friend: {\n          guid: 1n,\n          name: \"Arthas\",\n          note: \"\",\n          status: FriendStatus.ONLINE,\n          area: 0,\n          level: 80,\n          playerClass: 6,\n        },\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"online\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ONLINE\");\n    expect(json.name).toBe(\"Arthas\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes friend-offline event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Arthas\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"offline\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_OFFLINE\");\n  });\n\n  test(\"skips friend-list events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent({ type: \"friend-list\", friends: [] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"pushes friend-error event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-error\", result: 0x04, name: \"Nobody\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"player not found\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ERROR\");\n    expect(json.result).toBe(0x04);\n  });\n\n  test(\"swallows friend event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Gone\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"IPC round-trip\", () => {\n  let sockCounter = 0;\n  let sockPath: string;\n  let handle: ReturnType<typeof createMockHandle>;\n  let result: ReturnType<typeof startDaemonServer>;\n  let exitSpy: ReturnType<typeof jest.fn>;\n\n  function startTestServer(opts?: { onActivity?: () => void }) {\n    sockPath = `./tmp/test-daemon-${++sockCounter}-${Date.now()}.sock`;\n    handle = createMockHandle();\n    const log = new SessionLog(`./tmp/test-daemon-${sockCounter}.jsonl`);\n    exitSpy = jest\n      .spyOn(process, \"exit\")\n      .mockImplementation(() => undefined as never);\n    result = startDaemonServer({ handle, sock: sockPath, log, ...opts });\n  }\n\n  afterEach(async () => {\n    exitSpy?.mockRestore();\n    result?.cleanup();\n  });\n\n  test(\"STATUS returns CONNECTED\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STATUS\", sockPath);\n    expect(lines).toEqual([\"CONNECTED\"]);\n  });\n\n  test(\"SAY returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {\n    startTestServer();\n    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n  });\n\n  test(\"bare text sends via sticky mode\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"hello world\", sockPath);\n    expect(lines[0]).toMatch(/^OK /);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"empty command returns ERR\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"\", sockPath);\n    expect(lines).toEqual([\"ERR unknown command\"]);\n  });\n\n  test(\"sendToSocket rejects on missing socket\", async () => {\n    await expect(\n      sendToSocket(\"STATUS\", \"./tmp/nonexistent.sock\"),\n    ).rejects.toThrow();\n  });\n\n  test(\"onActivity fires on each IPC command\", async () => {\n    const activity = jest.fn();\n    startTestServer({ onActivity: activity });\n    await sendToSocket(\"STATUS\", sockPath);\n    await sendToSocket(\"STATUS\", sockPath);\n    expect(activity).toHaveBeenCalledTimes(2);\n  });\n\n  test(\"cleanup closes handle and stops server\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalled();\n    await expect(sendToSocket(\"STATUS\", sockPath)).rejects.toThrow();\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    startTestServer();\n    result.cleanup();\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"cleanup ignores missing socket file\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    await unlink(sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP triggers process.exit\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STOP\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    await Bun.sleep(0);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"buffers split command chunks before parsing\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-split-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-split-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STA\"));\n      capturedData!(socket, Buffer.from(\"TUS\\n\"));\n      await Promise.resolve();\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"processes multiple commands from a single chunk\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-multi-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-multi-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STATUS\\nSTATUS\\n\"));\n      await Bun.sleep(0);\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\nCONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"onMessage wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\"]);\n  });\n\n  test(\"onGroupEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerGroupEvent({ type: \"group_destroyed\" });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[group] Group has been disbanded\"]);\n  });\n\n  test(\"onFriendEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        level: 80,\n        playerClass: 1,\n        area: 0,\n        status: 0,\n        note: \"\",\n      },\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Arthas\");\n  });\n\n  test(\"onEntityEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Test NPC\");\n  });\n\n  test(\"onEntityEvent wiring round-trip via READ_JSON\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ_JSON\", sockPath);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.type).toBe(\"ENTITY_APPEAR\");\n    expect(parsed.name).toBe(\"Test NPC\");\n  });\n\n  test(\"NEARBY round-trip returns formatted entities\", async () => {\n    startTestServer();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const lines = await sendToSocket(\"NEARBY\", sockPath);\n    expect(lines[0]).toContain(\"Thrall\");\n    expect(lines[0]).toContain(\"level 80\");\n  });\n\n  test(\"dispatch error returns ERR internal\", async () => {\n    startTestServer();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"db fail\"),\n    );\n    const lines = await sendToSocket(\"WHO\", sockPath);\n    expect(lines).toEqual([\"ERR internal\"]);\n  });\n});\n","structuredPatch":[{"oldStart":209,"oldLines":6,"newStart":209,"newLines":13,"lines":["     });","   });"," ","+  test(\"slash /emote maps to emote\", () => {","+    expect(parseIpcCommand(\"/emote waves\")).toEqual({","+      type: \"emote\",","+      message: \"waves\",","+    });","+  });","+","   test(\"slash /who maps to who with filter\", () => {","     expect(parseIpcCommand(\"/who mage\")).toEqual({","       type: \"who\","]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a52c701b-e24a-48d5-b57b-d3a8445c41a2"}
{"parentUuid":"b03480af-c8c5-40a0-878e-2185406fb94c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01X49qVSZwwAVwxCsRKGdc6Z","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the dispatchCommand test for emote. Let me find the right spot."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":250,"cache_read_input_tokens":89461,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":250},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMccnp2dpKr619oASC7","type":"assistant","uuid":"4bc37517-d3da-4f23-9c4e-9b1db83a5b3e","timestamp":"2026-02-28T23:44:46.694Z"}
{"parentUuid":"4bc37517-d3da-4f23-9c4e-9b1db83a5b3e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01X49qVSZwwAVwxCsRKGdc6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AumCEKKz2PcLE8ShfPHJBq","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","offset":438,"limit":30},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":250,"cache_read_input_tokens":89461,"output_tokens":126,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":250,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMccnp2dpKr619oASC7","type":"assistant","uuid":"3d7c56a6-1e69-4cb2-89af-0bbd34d19126","timestamp":"2026-02-28T23:44:47.363Z"}
{"parentUuid":"3d7c56a6-1e69-4cb2-89af-0bbd34d19126","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AumCEKKz2PcLE8ShfPHJBq","type":"tool_result","content":"   438→      handle,\n   439→      events,\n   440→      socket,\n   441→      cleanup,\n   442→    );\n   443→\n   444→    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n   445→    expect(socket.written()).toBe(\"OK\\n\\n\");\n   446→  });\n   447→\n   448→  test(\"guild calls sendGuild and writes OK\", async () => {\n   449→    const handle = createMockHandle();\n   450→    const events = new RingBuffer<EventEntry>(10);\n   451→    const socket = createMockSocket();\n   452→    const cleanup = jest.fn();\n   453→\n   454→    await dispatchCommand(\n   455→      { type: \"guild\", message: \"inv pls\" },\n   456→      handle,\n   457→      events,\n   458→      socket,\n   459→      cleanup,\n   460→    );\n   461→\n   462→    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n   463→    expect(socket.written()).toBe(\"OK\\n\\n\");\n   464→  });\n   465→\n   466→  test(\"party calls sendParty and writes OK\", async () => {\n   467→    const handle = createMockHandle();"}]},"uuid":"3642d840-1223-43ff-8b19-15c84d13e029","timestamp":"2026-02-28T23:44:47.365Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","content":"      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();","numLines":30,"startLine":438,"totalLines":1975}},"sourceToolAssistantUUID":"3d7c56a6-1e69-4cb2-89af-0bbd34d19126"}
{"parentUuid":"3642d840-1223-43ff-8b19-15c84d13e029","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Ai6Lu4AWyUjZ1TqGjdaepB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011wsrb15SPVm5AEGF8aRkfF","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","offset":478,"limit":25},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":467,"cache_read_input_tokens":89711,"output_tokens":107,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":467,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMcum2Z5wiU9PXwpiJP","type":"assistant","uuid":"ba116b63-8fb3-485a-ad00-c6f1f95540c4","timestamp":"2026-02-28T23:44:51.911Z"}
{"parentUuid":"ba116b63-8fb3-485a-ad00-c6f1f95540c4","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011wsrb15SPVm5AEGF8aRkfF","type":"tool_result","content":"   478→    );\n   479→\n   480→    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n   481→    expect(socket.written()).toBe(\"OK\\n\\n\");\n   482→  });\n   483→\n   484→  test(\"whisper calls sendWhisper and writes OK\", async () => {\n   485→    const handle = createMockHandle();\n   486→    const events = new RingBuffer<EventEntry>(10);\n   487→    const socket = createMockSocket();\n   488→    const cleanup = jest.fn();\n   489→\n   490→    await dispatchCommand(\n   491→      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n   492→      handle,\n   493→      events,\n   494→      socket,\n   495→      cleanup,\n   496→    );\n   497→\n   498→    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n   499→    expect(socket.written()).toBe(\"OK\\n\\n\");\n   500→  });\n   501→\n   502→  test(\"read drains ring buffer text\", async () => {"}]},"uuid":"ce912991-47f5-49bd-9721-abebae0d680d","timestamp":"2026-02-28T23:44:51.912Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","content":"    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {","numLines":25,"startLine":478,"totalLines":1975}},"sourceToolAssistantUUID":"ba116b63-8fb3-485a-ad00-c6f1f95540c4"}
{"parentUuid":"ce912991-47f5-49bd-9721-abebae0d680d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Ggmyw5nrvUxiYVX7MZjhmt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015MSKZFrC6oB4yaU8CdsrAC","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","old_string":"    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {","new_string":"    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"emote calls sendEmote and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"emote\", message: \"waves hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":639,"cache_read_input_tokens":90178,"output_tokens":392,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":639,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMdFF3UtiYW3skg5W8Q","type":"assistant","uuid":"bb40e4ce-67df-4dce-bad3-dff6c644a5dd","timestamp":"2026-02-28T23:44:56.972Z"}
{"parentUuid":"bb40e4ce-67df-4dce-bad3-dff6c644a5dd","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015MSKZFrC6oB4yaU8CdsrAC","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.test.ts has been updated successfully."}]},"uuid":"4d74ebdd-aae9-4700-a04e-6d445b0bb59b","timestamp":"2026-02-28T23:44:56.990Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","oldString":"    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {","newString":"    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"emote calls sendEmote and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"emote\", message: \"waves hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {","originalFile":"import { test, expect, describe, jest, afterEach } from \"bun:test\";\nimport { unlink } from \"node:fs/promises\";\nimport {\n  parseIpcCommand,\n  dispatchCommand,\n  onChatMessage,\n  onGroupEvent,\n  onEntityEvent,\n  onFriendEvent,\n  writeLines,\n  type EventEntry,\n} from \"daemon/commands\";\nimport { startDaemonServer } from \"daemon/server\";\nimport { sendToSocket } from \"cli/ipc\";\nimport { RingBuffer } from \"lib/ring-buffer\";\nimport { ChatType } from \"wow/protocol/opcodes\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  UnitEntity,\n  GameObjectEntity,\n  BaseEntity,\n} from \"wow/entity-store\";\nimport { SessionLog } from \"lib/session-log\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction createMockSocket(): {\n  write: ReturnType<typeof jest.fn>;\n  end: ReturnType<typeof jest.fn>;\n  written(): string;\n} {\n  const chunks: string[] = [];\n  return {\n    write: jest.fn((data: string | Uint8Array) => {\n      chunks.push(\n        typeof data === \"string\" ? data : Buffer.from(data).toString(),\n      );\n      return (typeof data === \"string\" ? data : Buffer.from(data).toString())\n        .length;\n    }),\n    end: jest.fn(),\n    written() {\n      return chunks.join(\"\");\n    },\n  };\n}\n\ndescribe(\"parseIpcCommand\", () => {\n  test(\"SAY\", () => {\n    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n      type: \"say\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });\n\n  test(\"READ_WAIT\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 3000\")).toEqual({\n      type: \"read_wait\",\n      ms: 3000,\n    });\n  });\n\n  test(\"STOP\", () => {\n    expect(parseIpcCommand(\"STOP\")).toEqual({ type: \"stop\" });\n  });\n\n  test(\"STATUS\", () => {\n    expect(parseIpcCommand(\"STATUS\")).toEqual({ type: \"status\" });\n  });\n\n  test(\"WHO without filter\", () => {\n    expect(parseIpcCommand(\"WHO\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"WHO with filter\", () => {\n    expect(parseIpcCommand(\"WHO mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"READ_JSON\", () => {\n    expect(parseIpcCommand(\"READ_JSON\")).toEqual({ type: \"read_json\" });\n  });\n\n  test(\"READ_WAIT_JSON\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 2000\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 2000,\n    });\n  });\n\n  test(\"WHO_JSON without filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON\")).toEqual({ type: \"who_json\" });\n  });\n\n  test(\"WHO_JSON with filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON mage\")).toEqual({\n      type: \"who_json\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"INVITE\", () => {\n    expect(parseIpcCommand(\"INVITE Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"KICK\", () => {\n    expect(parseIpcCommand(\"KICK Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"LEAVE\", () => {\n    expect(parseIpcCommand(\"LEAVE\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"LEADER\", () => {\n    expect(parseIpcCommand(\"LEADER Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"ACCEPT\", () => {\n    expect(parseIpcCommand(\"ACCEPT\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"DECLINE\", () => {\n    expect(parseIpcCommand(\"DECLINE\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"NEARBY\", () => {\n    expect(parseIpcCommand(\"NEARBY\")).toEqual({ type: \"nearby\" });\n  });\n\n  test(\"NEARBY_JSON\", () => {\n    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n  });\n\n  test(\"slash /accept maps to accept\", () => {\n    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"slash /say maps to say\", () => {\n    expect(parseIpcCommand(\"/say hello\")).toEqual({\n      type: \"say\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"slash /whisper maps to whisper\", () => {\n    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"slash /emote maps to emote\", () => {\n    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n      type: \"emote\",\n      message: \"waves\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {\n    expect(parseIpcCommand(\"/who mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"slash /who maps to who without filter\", () => {\n    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"slash /invite maps to invite\", () => {\n    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /kick maps to kick\", () => {\n    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /leave maps to leave\", () => {\n    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"slash /friends maps to friends\", () => {\n    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"slash /ignore maps to unimplemented\", () => {\n    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n      type: \"unimplemented\",\n      feature: \"Ignore list\",\n    });\n  });\n\n  test(\"unknown slash command maps to say with full input\", () => {\n    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"slash command unsupported by daemon falls back to say\", () => {\n    expect(parseIpcCommand(\"/r hello\")).toEqual({\n      type: \"say\",\n      message: \"/r hello\",\n    });\n  });\n\n  test(\"INVITE with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"INVITE\")).toBeUndefined();\n  });\n\n  test(\"KICK with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"KICK\")).toBeUndefined();\n  });\n\n  test(\"LEADER with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"LEADER\")).toBeUndefined();\n  });\n\n  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n\n  test(\"unrecognized verb becomes chat\", () => {\n    expect(parseIpcCommand(\"DANCE\")).toEqual({\n      type: \"chat\",\n      message: \"DANCE\",\n    });\n  });\n\n  test(\"unrecognized text becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello world\")).toEqual({\n      type: \"chat\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"single word becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello\")).toEqual({\n      type: \"chat\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"empty string returns undefined\", () => {\n    expect(parseIpcCommand(\"\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with non-numeric argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT abc\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with negative value returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT -100\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 120000\")).toEqual({\n      type: \"read_wait\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"READ_WAIT_JSON with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT_JSON clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 999999\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"FRIENDS\", () => {\n    expect(parseIpcCommand(\"FRIENDS\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"FRIENDS_JSON\", () => {\n    expect(parseIpcCommand(\"FRIENDS_JSON\")).toEqual({ type: \"friends_json\" });\n  });\n\n  test(\"ADD_FRIEND\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"ADD_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"DEL_FRIEND\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"DEL_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"slash /friend add maps to add_friend\", () => {\n    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"slash /friend remove maps to del_friend\", () => {\n    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n});\n\ndescribe(\"dispatchCommand\", () => {\n  test(\"say calls sendSay and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"say\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"yell calls sendYell and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"yell\", message: \"HEY\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"party\", message: \"pull\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"[say] Alice: hi\\n[say] Bob: hey\\n\\n\");\n  });\n\n  test(\"read on empty buffer writes just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"read_wait delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n      expect(events.drain()).toEqual([\n        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n      ]);\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"status writes CONNECTED\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"status\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n  });\n\n  test(\"stop calls cleanup and returns true\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"stop\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(true);\n    expect(cleanup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who passes filter and formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    expect(socket.written()).toContain(\"[who] 1 results: Test (80)\");\n  });\n\n  test(\"who without filter passes empty object\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"who\" }, handle, events, socket, cleanup);\n\n    expect(handle.who).toHaveBeenCalledWith({});\n  });\n\n  test(\"read_json drains ring buffer json\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({\n      text: \"[say] Alice: hi\",\n      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n    });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"read_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\n      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n    );\n  });\n\n  test(\"read_wait_json delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait_json returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"old\":true}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"new\":true}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"new\":true}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"invite calls handle.invite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"invite\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"kick calls handle.uninvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"kick\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leave calls handle.leaveGroup and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"leave\" }, handle, events, socket, cleanup);\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leader calls handle.setLeader and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"leader\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"accept calls handle.acceptInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"accept\" }, handle, events, socket, cleanup);\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"decline calls handle.declineInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"decline\" }, handle, events, socket, cleanup);\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who_json returns JSON formatted results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who_json\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"WHO\");\n    expect(parsed.count).toBe(1);\n    expect(parsed.results[0].name).toBe(\"Test\");\n  });\n\n  test(\"nearby returns formatted entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.5, y: 4.6, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 19,\n      bytes1: 0,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n      testGo,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Thrall (NPC, level 80) HP 5000/5000 at 1.23, 4.56, 7.89\",\n    );\n    expect(output).toContain(\"Mailbox (GameObject) at 1.50, 4.60, 7.89\");\n  });\n\n  test(\"nearby_json returns JSONL entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.guid).toBe(\"0x1\");\n    expect(parsed.type).toBe(\"unit\");\n    expect(parsed.name).toBe(\"Thrall\");\n    expect(parsed.level).toBe(80);\n    expect(parsed.health).toBe(5000);\n    expect(parsed.maxHealth).toBe(5000);\n    expect(parsed.x).toBe(1.23);\n    expect(parsed.y).toBe(4.56);\n    expect(parsed.z).toBe(7.89);\n  });\n\n  test(\"nearby with no entities returns just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"nearby formats player entity\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 10n,\n      objectType: ObjectType.PLAYER,\n      name: \"Arthas\",\n      level: 55,\n      health: 3000,\n      maxHealth: 4000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 0, x: 10.0, y: 20.0, z: 30.0, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Arthas (Player, level 55) HP 3000/4000 at 10.00, 20.00, 30.00\",\n    );\n  });\n\n  test(\"nearby formats unknown entity type\", async () => {\n    const handle = createMockHandle();\n    const testCorpse: BaseEntity = {\n      guid: 0xabn,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\"Entity 0xab (type 7)\");\n  });\n\n  test(\"nearby_json formats player and gameobject types\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.PLAYER,\n      name: \"Jaina\",\n      level: 70,\n      health: 8000,\n      maxHealth: 8000,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Chest\",\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 3,\n      bytes1: 0,\n    };\n    const testCorpse: BaseEntity = {\n      guid: 3n,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n      testGo,\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    expect(lines).toHaveLength(3);\n    const player = JSON.parse(lines[0]!);\n    const go = JSON.parse(lines[1]!);\n    const corpse = JSON.parse(lines[2]!);\n    expect(player.type).toBe(\"player\");\n    expect(player.level).toBe(70);\n    expect(player.health).toBe(8000);\n    expect(go.type).toBe(\"gameobject\");\n    expect(go.gameObjectType).toBe(3);\n    expect(corpse.type).toBe(\"object\");\n  });\n\n  test(\"friends calls getFriends and writes friend list\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"friends\" }, handle, events, socket, cleanup);\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(socket.written()).toContain(\"No friends on your list\");\n  });\n\n  test(\"friends_json calls getFriends and writes JSON\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"friends_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"FRIENDS\");\n    expect(parsed.count).toBe(0);\n  });\n\n  test(\"add_friend calls handle.addFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"add_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"del_friend calls handle.removeFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"del_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"unimplemented writes UNIMPLEMENTED response\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"unimplemented\", feature: \"Friends list\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(socket.written()).toBe(\"UNIMPLEMENTED Friends list\\n\\n\");\n  });\n\n  test(\"chat sends via sendInCurrentMode and responds with mode\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"say\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"chat\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n  });\n\n  test(\"chat mode label includes whisper target\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"whisper\",\n      target: \"Xiara\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"follow me\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK WHISPER Xiara\\n\\n\");\n  });\n\n  test(\"chat mode label includes channel name\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"channel\",\n      channel: \"General\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"hello general\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK CHANNEL General\\n\\n\");\n  });\n});\n\ndescribe(\"writeLines\", () => {\n  test(\"writes each line with newline then blank terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, [\"line1\", \"line2\"]);\n    expect(socket.written()).toBe(\"line1\\nline2\\n\\n\");\n  });\n\n  test(\"empty array writes just terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, []);\n    expect(socket.written()).toBe(\"\\n\");\n  });\n});\n\ndescribe(\"onChatMessage\", () => {\n  test(\"pushes formatted message to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"appends JSON to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"swallows session log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onGroupEvent\", () => {\n  test(\"pushes group_list with undefined text to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"group_list\",\n        members: [{ name: \"Alice\", guidLow: 1, guidHigh: 0, online: true }],\n        leader: \"Alice\",\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toBeUndefined();\n    expect(JSON.parse(drained[0]!.json)).toMatchObject({ type: \"GROUP_LIST\" });\n  });\n\n  test(\"pushes member_stats to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent(\n      { type: \"member_stats\", guidLow: 42, hp: 100, maxHp: 200 },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith(\n      expect.objectContaining({ type: \"PARTY_MEMBER_STATS\", guidLow: 42 }),\n    );\n  });\n\n  test(\"swallows group event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n\n  test(\"pushes displayable events with text\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"invite_received\", from: \"Bob\" }, events, log);\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[group] Bob invites you to a group\");\n  });\n\n  test(\"serializes command_result event details\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"command_result\",\n        operation: 1,\n        target: \"Voidtrix\",\n        result: 0,\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"GROUP_COMMAND_RESULT\",\n      operation: 1,\n      target: \"Voidtrix\",\n      result: 0,\n    });\n  });\n\n  test(\"serializes leader/group lifecycle events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"leader_changed\", name: \"Alice\" }, events, log);\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    onGroupEvent({ type: \"kicked\" }, events, log);\n    onGroupEvent({ type: \"invite_declined\", name: \"Bob\" }, events, log);\n\n    const drained = events.drain().map((entry) => JSON.parse(entry.json));\n    expect(drained).toEqual([\n      { type: \"GROUP_LEADER_CHANGED\", name: \"Alice\" },\n      { type: \"GROUP_DESTROYED\" },\n      { type: \"GROUP_KICKED\" },\n      { type: \"GROUP_INVITE_DECLINED\", name: \"Bob\" },\n    ]);\n  });\n});\n\ndescribe(\"onEntityEvent\", () => {\n  test(\"pushes appear event to ring buffer with text and json\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"appear\", entity }, events, log);\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Test NPC\");\n    expect(drained[0]!.text).toContain(\"appeared\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_APPEAR\");\n    expect(json.name).toBe(\"Test NPC\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes disappear event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Gone NPC\");\n    expect(drained[0]!.text).toContain(\"left range\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_DISAPPEAR\");\n  });\n\n  test(\"skips update events with no obj\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"update\", entity, changed: [\"health\"] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"swallows entity event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onFriendEvent\", () => {\n  test(\"pushes friend-online event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      {\n        type: \"friend-online\",\n        friend: {\n          guid: 1n,\n          name: \"Arthas\",\n          note: \"\",\n          status: FriendStatus.ONLINE,\n          area: 0,\n          level: 80,\n          playerClass: 6,\n        },\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"online\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ONLINE\");\n    expect(json.name).toBe(\"Arthas\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes friend-offline event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Arthas\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"offline\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_OFFLINE\");\n  });\n\n  test(\"skips friend-list events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent({ type: \"friend-list\", friends: [] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"pushes friend-error event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-error\", result: 0x04, name: \"Nobody\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"player not found\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ERROR\");\n    expect(json.result).toBe(0x04);\n  });\n\n  test(\"swallows friend event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Gone\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"IPC round-trip\", () => {\n  let sockCounter = 0;\n  let sockPath: string;\n  let handle: ReturnType<typeof createMockHandle>;\n  let result: ReturnType<typeof startDaemonServer>;\n  let exitSpy: ReturnType<typeof jest.fn>;\n\n  function startTestServer(opts?: { onActivity?: () => void }) {\n    sockPath = `./tmp/test-daemon-${++sockCounter}-${Date.now()}.sock`;\n    handle = createMockHandle();\n    const log = new SessionLog(`./tmp/test-daemon-${sockCounter}.jsonl`);\n    exitSpy = jest\n      .spyOn(process, \"exit\")\n      .mockImplementation(() => undefined as never);\n    result = startDaemonServer({ handle, sock: sockPath, log, ...opts });\n  }\n\n  afterEach(async () => {\n    exitSpy?.mockRestore();\n    result?.cleanup();\n  });\n\n  test(\"STATUS returns CONNECTED\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STATUS\", sockPath);\n    expect(lines).toEqual([\"CONNECTED\"]);\n  });\n\n  test(\"SAY returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {\n    startTestServer();\n    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n  });\n\n  test(\"bare text sends via sticky mode\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"hello world\", sockPath);\n    expect(lines[0]).toMatch(/^OK /);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"empty command returns ERR\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"\", sockPath);\n    expect(lines).toEqual([\"ERR unknown command\"]);\n  });\n\n  test(\"sendToSocket rejects on missing socket\", async () => {\n    await expect(\n      sendToSocket(\"STATUS\", \"./tmp/nonexistent.sock\"),\n    ).rejects.toThrow();\n  });\n\n  test(\"onActivity fires on each IPC command\", async () => {\n    const activity = jest.fn();\n    startTestServer({ onActivity: activity });\n    await sendToSocket(\"STATUS\", sockPath);\n    await sendToSocket(\"STATUS\", sockPath);\n    expect(activity).toHaveBeenCalledTimes(2);\n  });\n\n  test(\"cleanup closes handle and stops server\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalled();\n    await expect(sendToSocket(\"STATUS\", sockPath)).rejects.toThrow();\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    startTestServer();\n    result.cleanup();\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"cleanup ignores missing socket file\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    await unlink(sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP triggers process.exit\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STOP\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    await Bun.sleep(0);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"buffers split command chunks before parsing\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-split-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-split-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STA\"));\n      capturedData!(socket, Buffer.from(\"TUS\\n\"));\n      await Promise.resolve();\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"processes multiple commands from a single chunk\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-multi-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-multi-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STATUS\\nSTATUS\\n\"));\n      await Bun.sleep(0);\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\nCONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"onMessage wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\"]);\n  });\n\n  test(\"onGroupEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerGroupEvent({ type: \"group_destroyed\" });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[group] Group has been disbanded\"]);\n  });\n\n  test(\"onFriendEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        level: 80,\n        playerClass: 1,\n        area: 0,\n        status: 0,\n        note: \"\",\n      },\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Arthas\");\n  });\n\n  test(\"onEntityEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Test NPC\");\n  });\n\n  test(\"onEntityEvent wiring round-trip via READ_JSON\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ_JSON\", sockPath);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.type).toBe(\"ENTITY_APPEAR\");\n    expect(parsed.name).toBe(\"Test NPC\");\n  });\n\n  test(\"NEARBY round-trip returns formatted entities\", async () => {\n    startTestServer();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const lines = await sendToSocket(\"NEARBY\", sockPath);\n    expect(lines[0]).toContain(\"Thrall\");\n    expect(lines[0]).toContain(\"level 80\");\n  });\n\n  test(\"dispatch error returns ERR internal\", async () => {\n    startTestServer();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"db fail\"),\n    );\n    const lines = await sendToSocket(\"WHO\", sockPath);\n    expect(lines).toEqual([\"ERR internal\"]);\n  });\n});\n","structuredPatch":[{"oldStart":481,"oldLines":6,"newStart":481,"newLines":24,"lines":["     expect(socket.written()).toBe(\"OK\\n\\n\");","   });"," ","+  test(\"emote calls sendEmote and writes OK\", async () => {","+    const handle = createMockHandle();","+    const events = new RingBuffer<EventEntry>(10);","+    const socket = createMockSocket();","+    const cleanup = jest.fn();","+","+    await dispatchCommand(","+      { type: \"emote\", message: \"waves hello\" },","+      handle,","+      events,","+      socket,","+      cleanup,","+    );","+","+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");","+    expect(socket.written()).toBe(\"OK\\n\\n\");","+  });","+","   test(\"whisper calls sendWhisper and writes OK\", async () => {","     const handle = createMockHandle();","     const events = new RingBuffer<EventEntry>(10);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"bb40e4ce-67df-4dce-bad3-dff6c644a5dd"}
{"parentUuid":"4d74ebdd-aae9-4700-a04e-6d445b0bb59b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0161nSDLChxEU9CBm2fdETE2","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the client.test.ts test for sendEmote echo."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":431,"cache_read_input_tokens":90817,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":431},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMdduZFcNn1u2Xv8GBU","type":"assistant","uuid":"ca07043e-8608-408e-b73c-3e6b654ee23d","timestamp":"2026-02-28T23:45:00.072Z"}
{"parentUuid":"ca07043e-8608-408e-b73c-3e6b654ee23d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0161nSDLChxEU9CBm2fdETE2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CVkj551wYyKyitGTpbHSL1","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","offset":694,"limit":40},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":431,"cache_read_input_tokens":90817,"output_tokens":123,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":431,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMdduZFcNn1u2Xv8GBU","type":"assistant","uuid":"4f886a78-6972-4ede-b0bb-aaa9806c5c39","timestamp":"2026-02-28T23:45:00.731Z"}
{"parentUuid":"4f886a78-6972-4ede-b0bb-aaa9806c5c39","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CVkj551wYyKyitGTpbHSL1","type":"tool_result","content":"   694→  test(\"sendYell sends message and receives echo\", async () => {\n   695→    const ws = await startMockWorldServer();\n   696→    try {\n   697→      const handle = await worldSession(\n   698→        { ...base, host: \"127.0.0.1\", port: ws.port },\n   699→        fakeAuth(ws.port),\n   700→      );\n   701→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n   702→      handle.sendYell(\"test yell\");\n   703→      const msg = await received;\n   704→      expect(msg.type).toBe(ChatType.YELL);\n   705→      expect(msg.message).toBe(\"test yell\");\n   706→      handle.close();\n   707→      await handle.closed;\n   708→    } finally {\n   709→      ws.stop();\n   710→    }\n   711→  });\n   712→\n   713→  test(\"sendGuild sends message and receives echo\", async () => {\n   714→    const ws = await startMockWorldServer();\n   715→    try {\n   716→      const handle = await worldSession(\n   717→        { ...base, host: \"127.0.0.1\", port: ws.port },\n   718→        fakeAuth(ws.port),\n   719→      );\n   720→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n   721→      handle.sendGuild(\"test guild\");\n   722→      const msg = await received;\n   723→      expect(msg.type).toBe(ChatType.GUILD);\n   724→      expect(msg.message).toBe(\"test guild\");\n   725→      handle.close();\n   726→      await handle.closed;\n   727→    } finally {\n   728→      ws.stop();\n   729→    }\n   730→  });\n   731→\n   732→  test(\"sendParty sends message and receives echo\", async () => {\n   733→    const ws = await startMockWorldServer();"}]},"uuid":"1d3594ba-6375-4033-8c6b-4fac84625fff","timestamp":"2026-02-28T23:45:00.732Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","content":"  test(\"sendYell sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendYell(\"test yell\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.YELL);\n      expect(msg.message).toBe(\"test yell\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendGuild sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendGuild(\"test guild\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.GUILD);\n      expect(msg.message).toBe(\"test guild\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendParty sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();","numLines":40,"startLine":694,"totalLines":2659}},"sourceToolAssistantUUID":"4f886a78-6972-4ede-b0bb-aaa9806c5c39"}
{"parentUuid":"1d3594ba-6375-4033-8c6b-4fac84625fff","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01E9J5EkkgTEMaCha2AX6G4B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ANRAFrtF92PxsvVL4p6r98","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","offset":730,"limit":40},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":648,"cache_read_input_tokens":91248,"output_tokens":107,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":648,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMdtuhy2AdEW9NRTS4f","type":"assistant","uuid":"2f3a8101-edbe-4d38-95e3-674d95b63c59","timestamp":"2026-02-28T23:45:04.124Z"}
{"parentUuid":"2f3a8101-edbe-4d38-95e3-674d95b63c59","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ANRAFrtF92PxsvVL4p6r98","type":"tool_result","content":"   730→  });\n   731→\n   732→  test(\"sendParty sends message and receives echo\", async () => {\n   733→    const ws = await startMockWorldServer();\n   734→    try {\n   735→      const handle = await worldSession(\n   736→        { ...base, host: \"127.0.0.1\", port: ws.port },\n   737→        fakeAuth(ws.port),\n   738→      );\n   739→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n   740→      handle.sendParty(\"test party\");\n   741→      const msg = await received;\n   742→      expect(msg.type).toBe(ChatType.PARTY);\n   743→      expect(msg.message).toBe(\"test party\");\n   744→      handle.close();\n   745→      await handle.closed;\n   746→    } finally {\n   747→      ws.stop();\n   748→    }\n   749→  });\n   750→\n   751→  test(\"sendRaid sends message and receives echo\", async () => {\n   752→    const ws = await startMockWorldServer();\n   753→    try {\n   754→      const handle = await worldSession(\n   755→        { ...base, host: \"127.0.0.1\", port: ws.port },\n   756→        fakeAuth(ws.port),\n   757→      );\n   758→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n   759→      handle.sendRaid(\"test raid\");\n   760→      const msg = await received;\n   761→      expect(msg.type).toBe(ChatType.RAID);\n   762→      expect(msg.message).toBe(\"test raid\");\n   763→      handle.close();\n   764→      await handle.closed;\n   765→    } finally {\n   766→      ws.stop();\n   767→    }\n   768→  });\n   769→"}]},"uuid":"732b4412-eed1-4310-bd1b-0fb947c5de98","timestamp":"2026-02-28T23:45:04.126Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","content":"  });\n\n  test(\"sendParty sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendParty(\"test party\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.PARTY);\n      expect(msg.message).toBe(\"test party\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendRaid sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendRaid(\"test raid\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.RAID);\n      expect(msg.message).toBe(\"test raid\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n","numLines":40,"startLine":730,"totalLines":2659}},"sourceToolAssistantUUID":"2f3a8101-edbe-4d38-95e3-674d95b63c59"}
{"parentUuid":"732b4412-eed1-4310-bd1b-0fb947c5de98","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_012jXUWr98qzRDCx5Qe25XbE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WpVSU81vzsSFk6z3W23ubU","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","offset":768,"limit":10},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":604,"cache_read_input_tokens":91896,"output_tokens":107,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":604,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMe9YXAFuMYSKfaa5Xu","type":"assistant","uuid":"27b95f63-cfee-457e-9363-90ee49b47a23","timestamp":"2026-02-28T23:45:06.984Z"}
{"parentUuid":"27b95f63-cfee-457e-9363-90ee49b47a23","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WpVSU81vzsSFk6z3W23ubU","type":"tool_result","content":"   768→  });\n   769→\n   770→  test(\"sendChannel sends message and receives echo\", async () => {\n   771→    const ws = await startMockWorldServer();\n   772→    try {\n   773→      const handle = await worldSession(\n   774→        { ...base, host: \"127.0.0.1\", port: ws.port },\n   775→        fakeAuth(ws.port),\n   776→      );\n   777→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));"}]},"uuid":"34dd693f-2cd6-46dd-923b-e81b14ec8157","timestamp":"2026-02-28T23:45:06.985Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","content":"  });\n\n  test(\"sendChannel sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));","numLines":10,"startLine":768,"totalLines":2659}},"sourceToolAssistantUUID":"27b95f63-cfee-457e-9363-90ee49b47a23"}
{"parentUuid":"34dd693f-2cd6-46dd-923b-e81b14ec8157","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01L5tLEGwUUGrfXjPdqquq1G","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G6Tc81wKQhYdkbcxdMBa9D","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","old_string":"  test(\"sendChannel sends message and receives echo\", async () => {","new_string":"  test(\"sendEmote sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendEmote(\"test emote\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.EMOTE);\n      expect(msg.message).toBe(\"test emote\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendChannel sends message and receives echo\", async () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":251,"cache_read_input_tokens":92500,"output_tokens":341,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":251,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMeMhGUJ8LtbQf7NZpa","type":"assistant","uuid":"5997711d-4103-4a99-aed8-fcaf06399c10","timestamp":"2026-02-28T23:45:12.337Z"}
{"parentUuid":"5997711d-4103-4a99-aed8-fcaf06399c10","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G6Tc81wKQhYdkbcxdMBa9D","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.test.ts has been updated successfully."}]},"uuid":"2e4d1409-2ac1-48ff-b123-413b09334998","timestamp":"2026-02-28T23:45:12.356Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","oldString":"  test(\"sendChannel sends message and receives echo\", async () => {","newString":"  test(\"sendEmote sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendEmote(\"test emote\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.EMOTE);\n      expect(msg.message).toBe(\"test emote\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendChannel sends message and receives echo\", async () => {","originalFile":"import { test, expect, describe, beforeAll, afterAll } from \"bun:test\";\nimport { deflateSync } from \"node:zlib\";\nimport {\n  authHandshake,\n  authWithRetry,\n  worldSession,\n  ReconnectRequiredError,\n  type ChatMessage,\n  type GroupEvent,\n  type WorldHandle,\n  type FriendEvent,\n} from \"wow/client\";\nimport type { AuthResult } from \"wow/client\";\nimport { startMockAuthServer } from \"test/mock-auth-server\";\nimport { startMockWorldServer } from \"test/mock-world-server\";\nimport { PacketWriter, PacketReader } from \"wow/protocol/packet\";\nimport {\n  AuthOpcode,\n  GameOpcode,\n  ChatType,\n  ChannelNotify,\n  PartyOperation,\n  PartyResult,\n  GroupUpdateFlag,\n} from \"wow/protocol/opcodes\";\nimport { bigIntToLeBytes } from \"wow/crypto/srp\";\nimport type { EntityEvent } from \"wow/entity-store\";\nimport {\n  UpdateFlag,\n  OBJECT_FIELDS,\n  UNIT_FIELDS,\n  GAMEOBJECT_FIELDS,\n} from \"wow/protocol/entity-fields\";\nimport {\n  FIXTURE_ACCOUNT,\n  FIXTURE_PASSWORD,\n  FIXTURE_CHARACTER,\n  clientPrivateKey,\n  clientSeed,\n  sessionKey,\n  salt,\n  g,\n  N,\n  B_LE,\n  M2_bytes,\n  reconnectChallengeData,\n} from \"test/fixtures\";\n\nconst base = {\n  account: FIXTURE_ACCOUNT,\n  password: FIXTURE_PASSWORD,\n  character: FIXTURE_CHARACTER,\n  srpPrivateKey: clientPrivateKey,\n  clientSeed,\n};\n\nasync function waitForEchoProbe(\n  handle: Pick<WorldHandle, \"onMessage\" | \"sendSay\">,\n): Promise<void> {\n  const received = new Promise<ChatMessage>((resolve) => {\n    handle.onMessage(resolve);\n  });\n  handle.sendSay(\"probe\");\n  await received;\n}\n\nfunction waitForGroupEvents(\n  handle: Pick<WorldHandle, \"onGroupEvent\">,\n  count: number,\n): Promise<GroupEvent[]> {\n  const events: GroupEvent[] = [];\n  return new Promise((resolve) => {\n    handle.onGroupEvent((event) => {\n      events.push(event);\n      if (events.length === count) resolve(events);\n    });\n  });\n}\n\nfunction buildChallengeResponse(): Uint8Array {\n  const w = new PacketWriter();\n  w.uint8(AuthOpcode.LOGON_CHALLENGE);\n  w.uint8(0x00);\n  w.uint8(0x00);\n  w.rawBytes(B_LE);\n  w.uint8(1);\n  w.uint8(Number(g));\n  w.uint8(32);\n  w.rawBytes(bigIntToLeBytes(N, 32));\n  w.rawBytes(salt);\n  w.rawBytes(new Uint8Array(16));\n  w.uint8(0x00);\n  return w.finish();\n}\n\nfunction buildSuccessProofResponse(): Uint8Array {\n  const w = new PacketWriter();\n  w.uint8(AuthOpcode.LOGON_PROOF);\n  w.uint8(0x00);\n  w.rawBytes(M2_bytes);\n  w.uint32LE(0x00800000);\n  w.uint32LE(0);\n  w.uint16LE(0);\n  return w.finish();\n}\n\ndescribe(\"mock integration\", () => {\n  let authServer: { port: number; stop(): void };\n  let worldServer: { port: number; stop(): void };\n\n  beforeAll(async () => {\n    worldServer = await startMockWorldServer();\n    authServer = await startMockAuthServer({\n      realmAddress: `127.0.0.1:${worldServer.port}`,\n    });\n  });\n\n  afterAll(() => {\n    authServer?.stop();\n    worldServer?.stop();\n  });\n\n  test(\"authHandshake completes SRP and returns session key\", async () => {\n    const auth = await authHandshake({\n      ...base,\n      host: \"127.0.0.1\",\n      port: authServer.port,\n    });\n\n    expect(auth.sessionKey).toEqual(sessionKey);\n    expect(auth.realmHost).toBe(\"127.0.0.1\");\n    expect(auth.realmPort).toBe(worldServer.port);\n    expect(auth.realmId).toBe(1);\n  });\n\n  test(\"full login flow: auth → world → character select → login\", async () => {\n    const auth = await authHandshake({\n      ...base,\n      host: \"127.0.0.1\",\n      port: authServer.port,\n    });\n    const handle = await worldSession(\n      { ...base, host: \"127.0.0.1\", port: worldServer.port },\n      auth,\n    );\n\n    handle.close();\n    await handle.closed;\n  });\n});\n\ndescribe(\"auth error paths\", () => {\n  test(\"rejects when challenge status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          socket.write(new Uint8Array([0x00, 0x00, 0x05]));\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"Auth challenge failed: status 0x5\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when proof status is non-zero\", async () => {\n    const server = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          account: \"WRONG\",\n          srpPrivateKey:\n            0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefn,\n          host: \"127.0.0.1\",\n          port: server.port,\n        }),\n      ).rejects.toThrow(\"Auth proof failed: status 0x5\");\n    } finally {\n      server.stop();\n    }\n  });\n\n  test(\"rejects when server M2 does not match\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(buildChallengeResponse());\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.LOGON_PROOF);\n            w.uint8(0x00);\n            w.rawBytes(new Uint8Array(20));\n            w.uint32LE(0x00800000);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"Server M2 mismatch\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"handles fragmented challenge response\", async () => {\n    const challengeData = buildChallengeResponse();\n    const splitAt = 50;\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(challengeData.slice(0, splitAt));\n            setTimeout(() => socket.write(challengeData.slice(splitAt)), 0);\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            socket.write(buildSuccessProofResponse());\n          } else if (opcode === AuthOpcode.REALM_LIST) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.REALM_LIST);\n            w.uint16LE(8);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"No realms available\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when no realms are available\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(buildChallengeResponse());\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            socket.write(buildSuccessProofResponse());\n          } else if (opcode === AuthOpcode.REALM_LIST) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.REALM_LIST);\n            w.uint16LE(8);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"No realms available\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"reconnect challenge succeeds with cached session key\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      const auth = await authHandshake({\n        ...base,\n        host: \"127.0.0.1\",\n        port: authServer.port,\n        cachedSessionKey: sessionKey,\n      });\n\n      expect(auth.sessionKey).toEqual(sessionKey);\n      expect(auth.realmHost).toBe(\"127.0.0.1\");\n      expect(auth.realmPort).toBe(1234);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"rejects when reconnect challenge status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          const w = new PacketWriter();\n          w.uint8(AuthOpcode.RECONNECT_CHALLENGE);\n          w.uint8(0x04);\n          socket.write(w.finish());\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          host: \"127.0.0.1\",\n          port: server.port,\n          cachedSessionKey: sessionKey,\n        }),\n      ).rejects.toThrow(\"Reconnect challenge failed: status 0x4\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when reconnect proof status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.RECONNECT_CHALLENGE);\n            w.uint8(0x00);\n            w.rawBytes(reconnectChallengeData);\n            w.rawBytes(new Uint8Array(16));\n            socket.write(w.finish());\n          } else if (opcode === AuthOpcode.RECONNECT_PROOF) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.RECONNECT_PROOF);\n            w.uint8(0x0b);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          host: \"127.0.0.1\",\n          port: server.port,\n          cachedSessionKey: sessionKey,\n        }),\n      ).rejects.toThrow(\"Reconnect proof failed: status 0xb\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"reconnect challenge without cached key throws ReconnectRequiredError\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: authServer.port }),\n      ).rejects.toThrow(ReconnectRequiredError);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry succeeds on first attempt with cached key\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      const auth = await authWithRetry(\n        {\n          ...base,\n          host: \"127.0.0.1\",\n          port: authServer.port,\n          cachedSessionKey: sessionKey,\n        },\n        { maxAttempts: 3, baseDelayMs: 1 },\n      );\n\n      expect(auth.sessionKey).toEqual(sessionKey);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry gives up after maxAttempts\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      await expect(\n        authWithRetry(\n          { ...base, host: \"127.0.0.1\", port: authServer.port },\n          { maxAttempts: 2, baseDelayMs: 1 },\n        ),\n      ).rejects.toThrow(ReconnectRequiredError);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry propagates non-reconnect errors immediately\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          socket.write(new Uint8Array([0x00, 0x00, 0x05]));\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authWithRetry(\n          { ...base, host: \"127.0.0.1\", port: server.port },\n          { maxAttempts: 3, baseDelayMs: 1 },\n        ),\n      ).rejects.toThrow(\"Auth challenge failed: status 0x5\");\n    } finally {\n      server.stop(true);\n    }\n  });\n});\n\ndescribe(\"world error paths\", () => {\n  function fakeAuth(port: number): AuthResult {\n    return {\n      sessionKey,\n      realmHost: \"127.0.0.1\",\n      realmPort: port,\n      realmId: 1,\n    };\n  }\n\n  test(\"handles SMSG_TIME_SYNC_REQ\", async () => {\n    const ws = await startMockWorldServer({ sendTimeSyncAfterLogin: true });\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      await waitForEchoProbe(handle);\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects when world auth status is not 0x0c\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x01 });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: status 0x1\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects with named message for system error (0x0d)\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x0d });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: system error\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects with named message for account in use (0x15)\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x15 });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: account in use\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects when character is not found\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      await expect(\n        worldSession(\n          {\n            ...base,\n            character: \"Nonexistent\",\n            host: \"127.0.0.1\",\n            port: ws.port,\n          },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow('Character \"Nonexistent\" not found');\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"ping interval fires and server handles CMSG_PING\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port, pingIntervalMs: 1 },\n        fakeAuth(ws.port),\n      );\n      await Bun.sleep(2);\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendWhisper with empty target does not poison sticky mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.sendWhisper(\"\", \"\");\n      expect(handle.getLastChatMode()).toEqual({ type: \"say\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendWhisper sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const messageReceived = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage(resolve);\n      });\n\n      handle.sendWhisper(\"Someone\", \"test whisper\");\n      const msg = await messageReceived;\n\n      expect(msg.message).toBe(\"test whisper\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"channel tracking populates from SMSG_CHANNEL_NOTIFY\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      await waitForEchoProbe(handle);\n\n      expect(handle.getChannel(1)).toBe(\"General\");\n      expect(handle.getChannel(2)).toBe(\"Trade\");\n      expect(handle.getChannel(3)).toBeUndefined();\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"who returns results from mock server\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const results = await handle.who({});\n      expect(results.length).toBe(1);\n      expect(results[0]!.name).toBe(FIXTURE_CHARACTER);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendSay sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"test say\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SAY);\n      expect(msg.message).toBe(\"test say\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendYell sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendYell(\"test yell\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.YELL);\n      expect(msg.message).toBe(\"test yell\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendGuild sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendGuild(\"test guild\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.GUILD);\n      expect(msg.message).toBe(\"test guild\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendParty sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendParty(\"test party\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.PARTY);\n      expect(msg.message).toBe(\"test party\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendRaid sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendRaid(\"test raid\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.RAID);\n      expect(msg.message).toBe(\"test raid\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendChannel sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendChannel(\"General\", \"test channel\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.CHANNEL);\n      expect(msg.message).toBe(\"test channel\");\n      expect(msg.channel).toBe(\"General\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"cached sender name skips name query on second message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const first = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"first\");\n      await first;\n\n      const second = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"second\");\n      const msg = await second;\n      expect(msg.sender).toBe(FIXTURE_CHARACTER);\n      expect(msg.message).toBe(\"second\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"multiple pending messages for same guid\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const messages: ChatMessage[] = [];\n      const gotTwo = new Promise<void>((resolve) => {\n        handle.onMessage((msg) => {\n          messages.push(msg);\n          if (messages.length === 2) resolve();\n        });\n      });\n\n      handle.sendSay(\"msg1\");\n      handle.sendSay(\"msg2\");\n      await gotTwo;\n\n      expect(messages[0]!.message).toBe(\"msg1\");\n      expect(messages[1]!.message).toBe(\"msg2\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"zero-guid system message delivers with empty sender\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint8(ChatType.SYSTEM);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      const msgBytes = new TextEncoder().encode(\"Server shutting down\");\n      w.uint32LE(msgBytes.byteLength);\n      w.rawBytes(msgBytes);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_MESSAGE_CHAT, w.finish());\n\n      const msg = await received;\n      expect(msg.sender).toBe(\"\");\n      expect(msg.message).toBe(\"Server shutting down\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"GM chat message delivers with sender name from packet\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint8(ChatType.SAY);\n      w.uint32LE(0);\n      w.uint32LE(0x42);\n      w.uint32LE(0x00);\n      w.uint32LE(0);\n      const nameBytes = new TextEncoder().encode(\"GameMaster\");\n      w.uint32LE(nameBytes.byteLength);\n      w.rawBytes(nameBytes);\n      w.uint32LE(0x42);\n      w.uint32LE(0x00);\n      const msgBytes = new TextEncoder().encode(\"hello from gm\");\n      w.uint32LE(msgBytes.byteLength);\n      w.rawBytes(msgBytes);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_GM_MESSAGECHAT, w.finish());\n\n      const msg = await received;\n      expect(msg.sender).toBe(\"GameMaster\");\n      expect(msg.message).toBe(\"hello from gm\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"player not found delivers system message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.cString(\"Ghostplayer\");\n      ws.inject(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, w.finish());\n\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toBe(\n        'No player named \"Ghostplayer\" is currently playing.',\n      );\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"SMSG_MOTD delivers each line as a system message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint32LE(2);\n      w.cString(\"Welcome to the server!\");\n      w.cString(\"Enjoy your stay.\");\n      ws.inject(GameOpcode.SMSG_MOTD, w.finish());\n\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toBe(\"Welcome to the server!\\nEnjoy your stay.\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"channel left removes from channel list\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      await waitForEchoProbe(handle);\n      expect(handle.getChannel(1)).toBe(\"General\");\n\n      const w = new PacketWriter();\n      w.uint8(ChannelNotify.YOU_LEFT);\n      w.cString(\"General\");\n      w.uint32LE(0);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_CHANNEL_NOTIFY, w.finish());\n\n      await waitForEchoProbe(handle);\n      expect(handle.getChannel(1)).toBe(\"Trade\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"getLastChatMode defaults to say\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      expect(handle.getLastChatMode()).toEqual({ type: \"say\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"setLastChatMode updates mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"guild\" });\n      expect(handle.getLastChatMode()).toEqual({ type: \"guild\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches based on last mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"hello via say\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SAY);\n      expect(msg.message).toBe(\"hello via say\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches whisper after mode change\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"whisper\", target: \"Someone\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"whisper test\");\n      const msg = await received;\n      expect(msg.message).toBe(\"whisper test\");\n      expect(handle.getLastChatMode()).toEqual({\n        type: \"whisper\",\n        target: \"Someone\",\n      });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches yell\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"yell\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"yell test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.YELL);\n      expect(msg.message).toBe(\"yell test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches guild\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"guild\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"guild test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.GUILD);\n      expect(msg.message).toBe(\"guild test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches party\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"party\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"party test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.PARTY);\n      expect(msg.message).toBe(\"party test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches raid\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"raid\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"raid test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.RAID);\n      expect(msg.message).toBe(\"raid test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches channel\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"channel test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.CHANNEL);\n      expect(msg.message).toBe(\"channel test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"handler error in drainWorldPackets calls onPacketError\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const errors: { opcode: number; message: string }[] = [];\n      handle.onPacketError((opcode, err) => {\n        errors.push({ opcode, message: err.message });\n      });\n\n      ws.inject(GameOpcode.SMSG_TIME_SYNC_REQ, new Uint8Array(0));\n      await waitForEchoProbe(handle);\n\n      expect(errors.length).toBeGreaterThan(0);\n      expect(errors[0]!.opcode).toBe(GameOpcode.SMSG_TIME_SYNC_REQ);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group opcodes emit expected group events\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = waitForGroupEvents(handle, 9);\n\n      const result = new PacketWriter();\n      result.uint32LE(PartyOperation.INVITE);\n      result.cString(\"Voidtrix\");\n      result.uint32LE(PartyResult.SUCCESS);\n      result.uint32LE(0);\n      ws.inject(GameOpcode.SMSG_PARTY_COMMAND_RESULT, result.finish());\n\n      const invite = new PacketWriter();\n      invite.uint8(1);\n      invite.cString(\"Leader\");\n      invite.uint32LE(0);\n      invite.uint8(0);\n      invite.uint32LE(0);\n      ws.inject(GameOpcode.SMSG_GROUP_INVITE, invite.finish());\n\n      const leader = new PacketWriter();\n      leader.cString(\"Newleader\");\n      ws.inject(GameOpcode.SMSG_GROUP_SET_LEADER, leader.finish());\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n\n      ws.inject(GameOpcode.SMSG_GROUP_DESTROYED, new Uint8Array(0));\n      ws.inject(GameOpcode.SMSG_GROUP_UNINVITE, new Uint8Array(0));\n\n      const decline = new PacketWriter();\n      decline.cString(\"Decliner\");\n      ws.inject(GameOpcode.SMSG_GROUP_DECLINE, decline.finish());\n\n      const stats = new PacketWriter();\n      stats.uint8(0x01);\n      stats.uint8(0x42);\n      stats.uint32LE(GroupUpdateFlag.STATUS | GroupUpdateFlag.CUR_HP);\n      stats.uint16LE(0x01);\n      stats.uint32LE(12000);\n      ws.inject(GameOpcode.SMSG_PARTY_MEMBER_STATS, stats.finish());\n\n      const fullStats = new PacketWriter();\n      fullStats.uint8(0);\n      fullStats.uint8(0x01);\n      fullStats.uint8(0x43);\n      fullStats.uint32LE(GroupUpdateFlag.STATUS | GroupUpdateFlag.LEVEL);\n      fullStats.uint16LE(0x01);\n      fullStats.uint16LE(80);\n      ws.inject(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, fullStats.finish());\n\n      const events = await received;\n      expect(events.map((event) => event.type)).toEqual([\n        \"command_result\",\n        \"invite_received\",\n        \"leader_changed\",\n        \"group_list\",\n        \"group_destroyed\",\n        \"kicked\",\n        \"invite_declined\",\n        \"member_stats\",\n        \"member_stats\",\n      ]);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group_list resolves self as leader when leader GUID matches\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<GroupEvent>((resolve) => {\n        handle.onGroupEvent(resolve);\n      });\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x00);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x42);\n      list.uint32LE(0x00);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n\n      const event = await received;\n      expect(event.type).toBe(\"group_list\");\n      if (event.type === \"group_list\") {\n        expect(event.leader).toBe(\"Testchar\");\n      }\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"setLeader reports missing party member\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage(resolve);\n      });\n\n      handle.setLeader(\"Ghostplayer\");\n      const message = await received;\n      expect(message.type).toBe(ChatType.SYSTEM);\n      expect(message.message).toBe('\"Ghostplayer\" is not in your party.');\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"stubbed opcode notifies via onMessage\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage((msg) => {\n          if (msg.message.includes(\"not yet implemented\")) resolve(msg);\n        });\n      });\n\n      ws.inject(GameOpcode.SMSG_CHAT_SERVER_MESSAGE, new Uint8Array(0));\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toContain(\"Server broadcast message\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group command methods run after login\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const groupListReady = new Promise<void>((resolve) => {\n        handle.onGroupEvent((event) => {\n          if (event.type === \"group_list\") resolve();\n        });\n      });\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n      await groupListReady;\n\n      handle.invite(\"Voidtrix\");\n      handle.uninvite(\"Voidtrix\");\n      handle.leaveGroup();\n      handle.acceptInvite();\n      handle.declineInvite();\n      handle.setLeader(\"Voidtrix\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  describe(\"entity handling\", () => {\n    function writePackedGuid(w: PacketWriter, guid: bigint) {\n      const low = Number(guid & 0xffffffffn);\n      const high = Number((guid >> 32n) & 0xffffffffn);\n      let mask = 0;\n      const bytes: number[] = [];\n      for (let i = 0; i < 4; i++) {\n        const b = (low >> (i * 8)) & 0xff;\n        if (b !== 0) {\n          mask |= 1 << i;\n          bytes.push(b);\n        }\n      }\n      for (let i = 0; i < 4; i++) {\n        const b = (high >> (i * 8)) & 0xff;\n        if (b !== 0) {\n          mask |= 1 << (i + 4);\n          bytes.push(b);\n        }\n      }\n      w.uint8(mask);\n      for (const b of bytes) w.uint8(b);\n    }\n\n    function writeLivingMovementBlock(\n      w: PacketWriter,\n      x: number,\n      y: number,\n      z: number,\n      orientation: number,\n    ) {\n      w.uint16LE(UpdateFlag.LIVING);\n      w.uint32LE(0);\n      w.uint16LE(0);\n      w.uint32LE(0);\n      w.floatLE(x);\n      w.floatLE(y);\n      w.floatLE(z);\n      w.floatLE(orientation);\n      w.floatLE(0);\n      for (let i = 0; i < 9; i++) w.floatLE(0);\n    }\n\n    function writeHasPositionMovementBlock(\n      w: PacketWriter,\n      x: number,\n      y: number,\n      z: number,\n      orientation: number,\n    ) {\n      w.uint16LE(UpdateFlag.HAS_POSITION);\n      w.floatLE(x);\n      w.floatLE(y);\n      w.floatLE(z);\n      w.floatLE(orientation);\n    }\n\n    function writeUpdateMask(w: PacketWriter, fields: Map<number, number>) {\n      let maxBit = 0;\n      for (const bit of fields.keys()) {\n        if (bit > maxBit) maxBit = bit;\n      }\n      const blockCount =\n        maxBit === 0 && fields.size === 0 ? 0 : Math.floor(maxBit / 32) + 1;\n      w.uint8(blockCount);\n      const masks = new Array<number>(blockCount).fill(0);\n      for (const bit of fields.keys()) {\n        masks[Math.floor(bit / 32)]! |= 1 << (bit % 32);\n      }\n      for (const m of masks) w.uint32LE(m);\n      for (let block = 0; block < blockCount; block++) {\n        for (let bit = 0; bit < 32; bit++) {\n          const index = block * 32 + bit;\n          if (fields.has(index)) {\n            w.uint32LE(fields.get(index)!);\n          }\n        }\n      }\n    }\n\n    function buildCreateUnitPacket(\n      guid: bigint,\n      entry: number,\n      health: number,\n      maxHealth: number,\n    ): Uint8Array {\n      const w = new PacketWriter();\n      w.uint32LE(1);\n      w.uint8(3);\n      writePackedGuid(w, guid);\n      w.uint8(3);\n      writeLivingMovementBlock(w, 100, 200, 300, 1.5);\n      const fields = new Map<number, number>([\n        [OBJECT_FIELDS.ENTRY.offset, entry],\n        [UNIT_FIELDS.HEALTH.offset, health],\n        [UNIT_FIELDS.MAXHEALTH.offset, maxHealth],\n      ]);\n      writeUpdateMask(w, fields);\n      return w.finish();\n    }\n\n    function waitForEntityEvents(\n      handle: Pick<WorldHandle, \"onEntityEvent\">,\n      count: number,\n    ): Promise<EntityEvent[]> {\n      const events: EntityEvent[] = [];\n      return new Promise((resolve) => {\n        handle.onEntityEvent((event) => {\n          events.push(event);\n          if (events.length === count) resolve(events);\n        });\n      });\n    }\n\n    test(\"entity create and creature query response\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const events = waitForEntityEvents(handle, 2);\n\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(100n, 1234, 500, 1000),\n        );\n\n        const creatureResp = new PacketWriter();\n        creatureResp.uint32LE(1234);\n        creatureResp.cString(\"Young Wolf\");\n        ws.inject(\n          GameOpcode.SMSG_CREATURE_QUERY_RESPONSE,\n          creatureResp.finish(),\n        );\n\n        const [appear, nameUpdate] = await events;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.guid).toBe(100n);\n          expect(appear!.entity.objectType).toBe(3);\n        }\n        expect(nameUpdate!.type).toBe(\"update\");\n        if (nameUpdate!.type === \"update\") {\n          expect(nameUpdate!.changed).toContain(\"name\");\n          expect(nameUpdate!.entity.name).toBe(\"Young Wolf\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"entity values update\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(200n, 5000, 100, 200),\n        );\n        await appearReady;\n\n        const updateReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(0);\n        writePackedGuid(w, 200n);\n        writeUpdateMask(w, new Map([[UNIT_FIELDS.HEALTH.offset, 50]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [update] = await updateReady;\n        expect(update!.type).toBe(\"update\");\n        if (update!.type === \"update\") {\n          expect(update!.changed).toContain(\"health\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"entity movement\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(300n, 6000, 100, 200),\n        );\n        await appearReady;\n\n        const moveReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(1);\n        writePackedGuid(w, 300n);\n        writeHasPositionMovementBlock(w, 10.5, 20.5, 30.5, 1.25);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [move] = await moveReady;\n        expect(move!.type).toBe(\"update\");\n        if (move!.type === \"update\") {\n          expect(move!.changed).toContain(\"position\");\n          expect(move!.entity.position!.x).toBeCloseTo(10.5);\n          expect(move!.entity.position!.y).toBeCloseTo(20.5);\n          expect(move!.entity.position!.z).toBeCloseTo(30.5);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"out of range removes entities\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear1 = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(400n, 7000, 100, 200),\n        );\n        await appear1;\n\n        const appear2 = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(401n, 7001, 100, 200),\n        );\n        await appear2;\n\n        expect(handle.getNearbyEntities().length).toBe(2);\n\n        const disappearReady = waitForEntityEvents(handle, 2);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(4);\n        w.uint32LE(2);\n        writePackedGuid(w, 400n);\n        writePackedGuid(w, 401n);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const events = await disappearReady;\n        expect(events[0]!.type).toBe(\"disappear\");\n        expect(events[1]!.type).toBe(\"disappear\");\n        expect(handle.getNearbyEntities().length).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_DESTROY_OBJECT removes entity\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(500n, 8000, 100, 200),\n        );\n        await appearReady;\n\n        const disappearReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint64LE(500n);\n        w.uint8(0);\n        ws.inject(GameOpcode.SMSG_DESTROY_OBJECT, w.finish());\n\n        const [disappear] = await disappearReady;\n        expect(disappear!.type).toBe(\"disappear\");\n        if (disappear!.type === \"disappear\") {\n          expect(disappear!.guid).toBe(500n);\n        }\n        expect(handle.getNearbyEntities().length).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"game object query response\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 600n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 50, 60, 70, 0.5);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 9999]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await appearReady;\n\n        const updateReady = waitForEntityEvents(handle, 2);\n\n        const goResp = new PacketWriter();\n        goResp.uint32LE(9999);\n        goResp.uint32LE(19);\n        goResp.uint32LE(0);\n        goResp.cString(\"Mailbox\");\n        ws.inject(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, goResp.finish());\n\n        const events = await updateReady;\n        const nameEvent = events.find(\n          (e) => e.type === \"update\" && e.changed.includes(\"name\"),\n        );\n        const typeEvent = events.find(\n          (e) => e.type === \"update\" && e.changed.includes(\"gameObjectType\"),\n        );\n        expect(nameEvent).toBeDefined();\n        expect(typeEvent).toBeDefined();\n        if (nameEvent?.type === \"update\") {\n          expect(nameEvent.entity.name).toBe(\"Mailbox\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"player name backfill via CMSG_NAME_QUERY\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const events = waitForEntityEvents(handle, 2);\n\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(3);\n        writePackedGuid(createW, 0x42n);\n        createW.uint8(4);\n        writeLivingMovementBlock(createW, 10, 20, 30, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 0]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n\n        const [appear, nameUpdate] = await events;\n        expect(appear!.type).toBe(\"appear\");\n        expect(nameUpdate!.type).toBe(\"update\");\n        if (nameUpdate!.type === \"update\") {\n          expect(nameUpdate!.entity.name).toBe(FIXTURE_CHARACTER);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"compressed update object\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n\n        const payload = buildCreateUnitPacket(700n, 3333, 250, 500);\n        const compressed = deflateSync(payload, { level: 6 });\n        const envelope = new PacketWriter();\n        envelope.uint32LE(payload.byteLength);\n        envelope.rawBytes(new Uint8Array(compressed));\n        ws.inject(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, envelope.finish());\n\n        const [appear] = await appearReady;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.guid).toBe(700n);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"cached creature name lookup\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const firstAppear = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(800n, 5555, 100, 200),\n        );\n        await firstAppear;\n\n        const nameReady = waitForEntityEvents(handle, 1);\n        const creatureResp = new PacketWriter();\n        creatureResp.uint32LE(5555);\n        creatureResp.cString(\"Stormwind Guard\");\n        ws.inject(\n          GameOpcode.SMSG_CREATURE_QUERY_RESPONSE,\n          creatureResp.finish(),\n        );\n        await nameReady;\n\n        const secondAppear = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(801n, 5555, 100, 200),\n        );\n\n        const [appear] = await secondAppear;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.name).toBe(\"Stormwind Guard\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"gameobject values update\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear = waitForEntityEvents(handle, 1);\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 500n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 1, 2, 3, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 100]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await appear;\n\n        const update = waitForEntityEvents(handle, 1);\n        const valW = new PacketWriter();\n        valW.uint32LE(1);\n        valW.uint8(0);\n        writePackedGuid(valW, 500n);\n        writeUpdateMask(valW, new Map([[GAMEOBJECT_FIELDS.FLAGS.offset, 42]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, valW.finish());\n        const [evt] = await update;\n        expect(evt!.type).toBe(\"update\");\n\n        const nearW = new PacketWriter();\n        nearW.uint32LE(1);\n        nearW.uint8(5);\n        nearW.uint32LE(1);\n        writePackedGuid(nearW, 500n);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, nearW.finish());\n        await Bun.sleep(1);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"compressed size mismatch triggers packet error\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const gotError = new Promise<Error>((resolve) => {\n          handle.onPacketError((_op, err) => resolve(err));\n        });\n\n        const payload = buildCreateUnitPacket(300n, 1, 50, 50);\n        const compressed = deflateSync(payload);\n        const w = new PacketWriter();\n        w.uint32LE(payload.byteLength + 999);\n        w.rawBytes(new Uint8Array(compressed));\n        ws.inject(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, w.finish());\n\n        const err = await gotError;\n        expect(err.message).toContain(\"size mismatch\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"corpse entity create uses base entity\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear = waitForEntityEvents(handle, 1);\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(2);\n        writePackedGuid(w, 999n);\n        w.uint8(7);\n        writeHasPositionMovementBlock(w, 10, 20, 30, 0);\n        writeUpdateMask(w, new Map([[OBJECT_FIELDS.ENTRY.offset, 42]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [evt] = await appear;\n        expect(evt!.type).toBe(\"appear\");\n        if (evt!.type === \"appear\") {\n          expect(evt!.entity.objectType).toBe(7);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"cached game object name lookup\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const firstAppear = waitForEntityEvents(handle, 1);\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 900n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 1, 2, 3, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 7777]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await firstAppear;\n\n        const nameReady = waitForEntityEvents(handle, 2);\n        const goResp = new PacketWriter();\n        goResp.uint32LE(7777);\n        goResp.uint32LE(19);\n        goResp.uint32LE(0);\n        goResp.cString(\"Forge\");\n        ws.inject(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, goResp.finish());\n        await nameReady;\n\n        const secondAppear = waitForEntityEvents(handle, 1);\n        const create2 = new PacketWriter();\n        create2.uint32LE(1);\n        create2.uint8(2);\n        writePackedGuid(create2, 901n);\n        create2.uint8(5);\n        writeHasPositionMovementBlock(create2, 4, 5, 6, 0);\n        writeUpdateMask(create2, new Map([[OBJECT_FIELDS.ENTRY.offset, 7777]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, create2.finish());\n\n        const [appear] = await secondAppear;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.name).toBe(\"Forge\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n  });\n\n  describe(\"friend list\", () => {\n    function buildContactList(\n      entries: {\n        guid: bigint;\n        flags: number;\n        note: string;\n        status?: number;\n        area?: number;\n        level?: number;\n        playerClass?: number;\n      }[],\n    ): Uint8Array {\n      const w = new PacketWriter();\n      w.uint32LE(7);\n      w.uint32LE(entries.length);\n      for (const e of entries) {\n        w.uint64LE(e.guid);\n        w.uint32LE(e.flags);\n        w.cString(e.note);\n        if (e.flags & 0x01) {\n          const status = e.status ?? 0;\n          w.uint8(status);\n          if (status !== 0) {\n            w.uint32LE(e.area ?? 0);\n            w.uint32LE(e.level ?? 0);\n            w.uint32LE(e.playerClass ?? 0);\n          }\n        }\n      }\n      return w.finish();\n    }\n\n    function buildFriendStatus(opts: {\n      result: number;\n      guid: bigint;\n      note?: string;\n      status?: number;\n      area?: number;\n      level?: number;\n      playerClass?: number;\n    }): Uint8Array {\n      const w = new PacketWriter();\n      w.uint8(opts.result);\n      w.uint64LE(opts.guid);\n      if (opts.result === 0x06 || opts.result === 0x07) {\n        w.cString(opts.note ?? \"\");\n      }\n      if (opts.result === 0x06 || opts.result === 0x02) {\n        w.uint8(opts.status ?? 1);\n        w.uint32LE(opts.area ?? 0);\n        w.uint32LE(opts.level ?? 0);\n        w.uint32LE(opts.playerClass ?? 0);\n      }\n      return w.finish();\n    }\n\n    function buildNameQueryResponse(guidLow: number, name: string): Uint8Array {\n      const w = new PacketWriter();\n      const mask = guidLow === 0 ? 0 : guidLow <= 0xff ? 0x01 : 0x03;\n      w.uint8(mask);\n      if (mask & 0x01) w.uint8(guidLow & 0xff);\n      if (mask & 0x02) w.uint8((guidLow >> 8) & 0xff);\n      w.uint8(0);\n      w.cString(name);\n      w.cString(\"\");\n      w.uint32LE(1);\n      w.uint32LE(0);\n      w.uint32LE(1);\n      return w.finish();\n    }\n\n    test(\"SMSG_CONTACT_LIST with online friend\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"best buddy\",\n              status: 1,\n              area: 1519,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-list\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0x99n);\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(1519);\n        expect(friends[0]!.level).toBe(80);\n        expect(friends[0]!.playerClass).toBe(1);\n        expect(friends[0]!.note).toBe(\"best buddy\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_CONTACT_LIST filters out ignored entries\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 70,\n              playerClass: 2,\n            },\n            {\n              guid: 0xaan,\n              flags: 0x02,\n              note: \"ignored person\",\n            },\n          ]),\n        );\n\n        await eventReady;\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0x99n);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_CONTACT_LIST triggers name queries\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n\n        await eventReady;\n        await Bun.sleep(1);\n\n        const nameQueries = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_NAME_QUERY,\n        );\n        const match = nameQueries.find((p) => {\n          const r = new PacketReader(p.body);\n          return r.uint32LE() === 0x99;\n        });\n        expect(match).toBeDefined();\n\n        ws.inject(\n          GameOpcode.SMSG_NAME_QUERY_RESPONSE,\n          buildNameQueryResponse(0x99, \"Arthas\"),\n        );\n        await Bun.sleep(1);\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.name).toBe(\"Arthas\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ADDED_ONLINE\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x06,\n            guid: 0xbbn,\n            note: \"new friend\",\n            status: 1,\n            area: 1537,\n            level: 55,\n            playerClass: 4,\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-added\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0xbbn);\n        expect(friends[0]!.note).toBe(\"new friend\");\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(1537);\n        expect(friends[0]!.level).toBe(55);\n        expect(friends[0]!.playerClass).toBe(4);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ONLINE updates existing friend\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xccn,\n              flags: 0x01,\n              note: \"\",\n              status: 0,\n            },\n          ]),\n        );\n        await listReady;\n\n        const onlineReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x02,\n            guid: 0xccn,\n            status: 1,\n            area: 400,\n            level: 60,\n            playerClass: 8,\n          }),\n        );\n\n        const event = await onlineReady;\n        expect(event.type).toBe(\"friend-online\");\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(400);\n        expect(friends[0]!.level).toBe(60);\n        expect(friends[0]!.playerClass).toBe(8);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS OFFLINE clears status\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xddn,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 100,\n              level: 70,\n              playerClass: 5,\n            },\n          ]),\n        );\n        await listReady;\n\n        const offlineReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x03,\n            guid: 0xddn,\n          }),\n        );\n\n        const event = await offlineReady;\n        expect(event.type).toBe(\"friend-offline\");\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.status).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS REMOVED deletes from store\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xeen,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n        await listReady;\n\n        const removedReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x05,\n            guid: 0xeen,\n          }),\n        );\n\n        const event = await removedReady;\n        expect(event.type).toBe(\"friend-removed\");\n\n        expect(handle.getFriends()).toHaveLength(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ADDED_OFFLINE adds with zero status\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x07,\n            guid: 0xabn,\n            note: \"offline pal\",\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-added\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0xabn);\n        expect(friends[0]!.note).toBe(\"offline pal\");\n        expect(friends[0]!.status).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS error fires friend-error event\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x04,\n            guid: 0x00n,\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-error\");\n        if (event.type === \"friend-error\") {\n          expect(event.result).toBe(0x04);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"addFriend sends CMSG_ADD_FRIEND\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        handle.addFriend(\"Arthas\");\n        await Bun.sleep(1);\n\n        const addPackets = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_ADD_FRIEND,\n        );\n        expect(addPackets).toHaveLength(1);\n        const r = new PacketReader(addPackets[0]!.body);\n        expect(r.cString()).toBe(\"Arthas\");\n        expect(r.cString()).toBe(\"\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"removeFriend sends CMSG_DEL_FRIEND\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xffn,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n        await listReady;\n\n        ws.inject(\n          GameOpcode.SMSG_NAME_QUERY_RESPONSE,\n          buildNameQueryResponse(0xff, \"Arthas\"),\n        );\n        await Bun.sleep(1);\n\n        handle.removeFriend(\"Arthas\");\n        await Bun.sleep(1);\n\n        const delPackets = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_DEL_FRIEND,\n        );\n        expect(delPackets).toHaveLength(1);\n        const r = new PacketReader(delPackets[0]!.body);\n        expect(r.uint64LE()).toBe(0xffn);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"removeFriend for unknown name triggers system message\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const received = new Promise<ChatMessage>((resolve) => {\n          handle.onMessage(resolve);\n        });\n\n        handle.removeFriend(\"Nobody\");\n\n        const msg = await received;\n        expect(msg.type).toBe(ChatType.SYSTEM);\n        expect(msg.message).toBe('\"Nobody\" is not on your friends list.');\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n  });\n});\n","structuredPatch":[{"oldStart":767,"oldLines":6,"newStart":767,"newLines":25,"lines":["     }","   });"," ","+  test(\"sendEmote sends message and receives echo\", async () => {","+    const ws = await startMockWorldServer();","+    try {","+      const handle = await worldSession(","+        { ...base, host: \"127.0.0.1\", port: ws.port },","+        fakeAuth(ws.port),","+      );","+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));","+      handle.sendEmote(\"test emote\");","+      const msg = await received;","+      expect(msg.type).toBe(ChatType.EMOTE);","+      expect(msg.message).toBe(\"test emote\");","+      handle.close();","+      await handle.closed;","+    } finally {","+      ws.stop();","+    }","+  });","+","   test(\"sendChannel sends message and receives echo\", async () => {","     const ws = await startMockWorldServer();","     try {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5997711d-4103-4a99-aed8-fcaf06399c10"}
{"parentUuid":"2e4d1409-2ac1-48ff-b123-413b09334998","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SfPUxDPmr2XB5PksXzSgko","type":"message","role":"assistant","content":[{"type":"text","text":"Now I also need to check if there's a test for emote message formatting and the `sendInCurrentMode` for emote. Let me check if there's a test for `sendInCurrentMode` covering emote, and check the `chat.test.ts` for emote."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":380,"cache_read_input_tokens":92751,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":380},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMemzkyNA8W4mYReA9b","type":"assistant","uuid":"8b4c59bd-fd69-4d3c-a0f1-f735740bdb8a","timestamp":"2026-02-28T23:45:16.902Z"}
{"parentUuid":"8b4c59bd-fd69-4d3c-a0f1-f735740bdb8a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SfPUxDPmr2XB5PksXzSgko","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MHbdgDPHbCVzdpT6Fu88JA","name":"Grep","input":{"pattern":"sendInCurrentMode|lastChatMode.*emote|emote.*mode","path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":380,"cache_read_input_tokens":92751,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":380},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMemzkyNA8W4mYReA9b","type":"assistant","uuid":"b81dafe7-d651-4968-afcd-da9790dd5a8a","timestamp":"2026-02-28T23:45:18.407Z"}
{"parentUuid":"b81dafe7-d651-4968-afcd-da9790dd5a8a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MHbdgDPHbCVzdpT6Fu88JA","type":"tool_result","content":"1047-    }\n1048-  });\n1049-\n1050:  test(\"sendInCurrentMode dispatches based on last mode\", async () => {\n1051-    const ws = await startMockWorldServer();\n1052-    try {\n1053-      const handle = await worldSession(\n--\n1055-        fakeAuth(ws.port),\n1056-      );\n1057-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1058:      handle.sendInCurrentMode(\"hello via say\");\n1059-      const msg = await received;\n1060-      expect(msg.type).toBe(ChatType.SAY);\n1061-      expect(msg.message).toBe(\"hello via say\");\n--\n1066-    }\n1067-  });\n1068-\n1069:  test(\"sendInCurrentMode dispatches whisper after mode change\", async () => {\n1070-    const ws = await startMockWorldServer();\n1071-    try {\n1072-      const handle = await worldSession(\n--\n1075-      );\n1076-      handle.setLastChatMode({ type: \"whisper\", target: \"Someone\" });\n1077-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1078:      handle.sendInCurrentMode(\"whisper test\");\n1079-      const msg = await received;\n1080-      expect(msg.message).toBe(\"whisper test\");\n1081-      expect(handle.getLastChatMode()).toEqual({\n--\n1089-    }\n1090-  });\n1091-\n1092:  test(\"sendInCurrentMode dispatches yell\", async () => {\n1093-    const ws = await startMockWorldServer();\n1094-    try {\n1095-      const handle = await worldSession(\n--\n1098-      );\n1099-      handle.setLastChatMode({ type: \"yell\" });\n1100-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1101:      handle.sendInCurrentMode(\"yell test\");\n1102-      const msg = await received;\n1103-      expect(msg.type).toBe(ChatType.YELL);\n1104-      expect(msg.message).toBe(\"yell test\");\n--\n1109-    }\n1110-  });\n1111-\n1112:  test(\"sendInCurrentMode dispatches guild\", async () => {\n1113-    const ws = await startMockWorldServer();\n1114-    try {\n1115-      const handle = await worldSession(\n--\n1118-      );\n1119-      handle.setLastChatMode({ type: \"guild\" });\n1120-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1121:      handle.sendInCurrentMode(\"guild test\");\n1122-      const msg = await received;\n1123-      expect(msg.type).toBe(ChatType.GUILD);\n1124-      expect(msg.message).toBe(\"guild test\");\n--\n1129-    }\n1130-  });\n1131-\n1132:  test(\"sendInCurrentMode dispatches party\", async () => {\n1133-    const ws = await startMockWorldServer();\n1134-    try {\n1135-      const handle = await worldSession(\n--\n1138-      );\n1139-      handle.setLastChatMode({ type: \"party\" });\n1140-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1141:      handle.sendInCurrentMode(\"party test\");\n1142-      const msg = await received;\n1143-      expect(msg.type).toBe(ChatType.PARTY);\n1144-      expect(msg.message).toBe(\"party test\");\n--\n1149-    }\n1150-  });\n1151-\n1152:  test(\"sendInCurrentMode dispatches raid\", async () => {\n1153-    const ws = await startMockWorldServer();\n1154-    try {\n1155-      const handle = await worldSession(\n--\n1158-      );\n1159-      handle.setLastChatMode({ type: \"raid\" });\n1160-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1161:      handle.sendInCurrentMode(\"raid test\");\n1162-      const msg = await received;\n1163-      expect(msg.type).toBe(ChatType.RAID);\n1164-      expect(msg.message).toBe(\"raid test\");\n--\n1169-    }\n1170-  });\n1171-\n1172:  test(\"sendInCurrentMode dispatches channel\", async () => {\n1173-    const ws = await startMockWorldServer();\n1174-    try {\n1175-      const handle = await worldSession(\n--\n1178-      );\n1179-      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n1180-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1181:      handle.sendInCurrentMode(\"channel test\");\n1182-      const msg = await received;\n1183-      expect(msg.type).toBe(ChatType.CHANNEL);\n1184-      expect(msg.message).toBe(\"channel test\");"}]},"uuid":"bdb7d365-ddd7-4621-9fad-28a4c7ed7388","timestamp":"2026-02-28T23:45:18.486Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1047-    }\n1048-  });\n1049-\n1050:  test(\"sendInCurrentMode dispatches based on last mode\", async () => {\n1051-    const ws = await startMockWorldServer();\n1052-    try {\n1053-      const handle = await worldSession(\n--\n1055-        fakeAuth(ws.port),\n1056-      );\n1057-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1058:      handle.sendInCurrentMode(\"hello via say\");\n1059-      const msg = await received;\n1060-      expect(msg.type).toBe(ChatType.SAY);\n1061-      expect(msg.message).toBe(\"hello via say\");\n--\n1066-    }\n1067-  });\n1068-\n1069:  test(\"sendInCurrentMode dispatches whisper after mode change\", async () => {\n1070-    const ws = await startMockWorldServer();\n1071-    try {\n1072-      const handle = await worldSession(\n--\n1075-      );\n1076-      handle.setLastChatMode({ type: \"whisper\", target: \"Someone\" });\n1077-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1078:      handle.sendInCurrentMode(\"whisper test\");\n1079-      const msg = await received;\n1080-      expect(msg.message).toBe(\"whisper test\");\n1081-      expect(handle.getLastChatMode()).toEqual({\n--\n1089-    }\n1090-  });\n1091-\n1092:  test(\"sendInCurrentMode dispatches yell\", async () => {\n1093-    const ws = await startMockWorldServer();\n1094-    try {\n1095-      const handle = await worldSession(\n--\n1098-      );\n1099-      handle.setLastChatMode({ type: \"yell\" });\n1100-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1101:      handle.sendInCurrentMode(\"yell test\");\n1102-      const msg = await received;\n1103-      expect(msg.type).toBe(ChatType.YELL);\n1104-      expect(msg.message).toBe(\"yell test\");\n--\n1109-    }\n1110-  });\n1111-\n1112:  test(\"sendInCurrentMode dispatches guild\", async () => {\n1113-    const ws = await startMockWorldServer();\n1114-    try {\n1115-      const handle = await worldSession(\n--\n1118-      );\n1119-      handle.setLastChatMode({ type: \"guild\" });\n1120-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1121:      handle.sendInCurrentMode(\"guild test\");\n1122-      const msg = await received;\n1123-      expect(msg.type).toBe(ChatType.GUILD);\n1124-      expect(msg.message).toBe(\"guild test\");\n--\n1129-    }\n1130-  });\n1131-\n1132:  test(\"sendInCurrentMode dispatches party\", async () => {\n1133-    const ws = await startMockWorldServer();\n1134-    try {\n1135-      const handle = await worldSession(\n--\n1138-      );\n1139-      handle.setLastChatMode({ type: \"party\" });\n1140-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1141:      handle.sendInCurrentMode(\"party test\");\n1142-      const msg = await received;\n1143-      expect(msg.type).toBe(ChatType.PARTY);\n1144-      expect(msg.message).toBe(\"party test\");\n--\n1149-    }\n1150-  });\n1151-\n1152:  test(\"sendInCurrentMode dispatches raid\", async () => {\n1153-    const ws = await startMockWorldServer();\n1154-    try {\n1155-      const handle = await worldSession(\n--\n1158-      );\n1159-      handle.setLastChatMode({ type: \"raid\" });\n1160-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1161:      handle.sendInCurrentMode(\"raid test\");\n1162-      const msg = await received;\n1163-      expect(msg.type).toBe(ChatType.RAID);\n1164-      expect(msg.message).toBe(\"raid test\");\n--\n1169-    }\n1170-  });\n1171-\n1172:  test(\"sendInCurrentMode dispatches channel\", async () => {\n1173-    const ws = await startMockWorldServer();\n1174-    try {\n1175-      const handle = await worldSession(\n--\n1178-      );\n1179-      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n1180-      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n1181:      handle.sendInCurrentMode(\"channel test\");\n1182-      const msg = await received;\n1183-      expect(msg.type).toBe(ChatType.CHANNEL);\n1184-      expect(msg.message).toBe(\"channel test\");","numLines":111},"sourceToolAssistantUUID":"b81dafe7-d651-4968-afcd-da9790dd5a8a"}
{"parentUuid":"bdb7d365-ddd7-4621-9fad-28a4c7ed7388","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01SfPUxDPmr2XB5PksXzSgko","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DSqFFJJm7zraEubFgE9h16","name":"Grep","input":{"pattern":"emote|EMOTE","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":380,"cache_read_input_tokens":92751,"output_tokens":319,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":380,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMemzkyNA8W4mYReA9b","type":"assistant","uuid":"98ea3de9-c536-4614-b105-0ce3f97ee902","timestamp":"2026-02-28T23:45:19.400Z"}
{"parentUuid":"98ea3de9-c536-4614-b105-0ce3f97ee902","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DSqFFJJm7zraEubFgE9h16","type":"tool_result","content":"291-        feature: \"Player status\",\n292-      });\n293-    });\n294:    test(\"/e sends emote\", () => {\n295-      expect(parseCommand(\"/e waves\")).toEqual({\n296:        type: \"emote\",\n297-        message: \"waves\",\n298-      });\n299-    });\n300:    test(\"/emote sends emote\", () => {\n301:      expect(parseCommand(\"/emote waves\")).toEqual({\n302:        type: \"emote\",\n303-        message: \"waves\",\n304-      });\n305-    });\n--\n452-    await done;\n453-  });\n454-\n455:  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n456-    const handle = createMockHandle();\n457-    const input = new PassThrough();\n458-"}]},"uuid":"129d90ef-b906-4b3f-85d8-4518eed65b20","timestamp":"2026-02-28T23:45:19.481Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"291-        feature: \"Player status\",\n292-      });\n293-    });\n294:    test(\"/e sends emote\", () => {\n295-      expect(parseCommand(\"/e waves\")).toEqual({\n296:        type: \"emote\",\n297-        message: \"waves\",\n298-      });\n299-    });\n300:    test(\"/emote sends emote\", () => {\n301:      expect(parseCommand(\"/emote waves\")).toEqual({\n302:        type: \"emote\",\n303-        message: \"waves\",\n304-      });\n305-    });\n--\n452-    await done;\n453-  });\n454-\n455:  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n456-    const handle = createMockHandle();\n457-    const input = new PassThrough();\n458-","numLines":23},"sourceToolAssistantUUID":"98ea3de9-c536-4614-b105-0ce3f97ee902"}
{"parentUuid":"129d90ef-b906-4b3f-85d8-4518eed65b20","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_017ZNADiD2sNeP1WndSG1MmM","type":"message","role":"assistant","content":[{"type":"text","text":"I need to add a `sendInCurrentMode` dispatches emote test. Let me find the right insertion point."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1904,"cache_read_input_tokens":93131,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMfH1GJrj5nXpAZGCDp","type":"assistant","uuid":"4a37ae52-462d-4c3d-9e19-9484aef0db2c","timestamp":"2026-02-28T23:45:24.582Z"}
{"parentUuid":"4a37ae52-462d-4c3d-9e19-9484aef0db2c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_017ZNADiD2sNeP1WndSG1MmM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019D1vx1VyVdYaizUqLwKQW5","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","offset":1168,"limit":30},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1904,"cache_read_input_tokens":93131,"output_tokens":134,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1904,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMfH1GJrj5nXpAZGCDp","type":"assistant","uuid":"669fc6fa-2791-4a07-960f-46ba436a3fe8","timestamp":"2026-02-28T23:45:25.902Z"}
{"parentUuid":"669fc6fa-2791-4a07-960f-46ba436a3fe8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019D1vx1VyVdYaizUqLwKQW5","type":"tool_result","content":"  1168→      ws.stop();\n  1169→    }\n  1170→  });\n  1171→\n  1172→  test(\"sendInCurrentMode dispatches channel\", async () => {\n  1173→    const ws = await startMockWorldServer();\n  1174→    try {\n  1175→      const handle = await worldSession(\n  1176→        { ...base, host: \"127.0.0.1\", port: ws.port },\n  1177→        fakeAuth(ws.port),\n  1178→      );\n  1179→      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n  1180→      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n  1181→      handle.sendInCurrentMode(\"channel test\");\n  1182→      const msg = await received;\n  1183→      expect(msg.type).toBe(ChatType.CHANNEL);\n  1184→      expect(msg.message).toBe(\"channel test\");\n  1185→      handle.close();\n  1186→      await handle.closed;\n  1187→    } finally {\n  1188→      ws.stop();\n  1189→    }\n  1190→  });\n  1191→\n  1192→  test(\"handler error in drainWorldPackets calls onPacketError\", async () => {\n  1193→    const ws = await startMockWorldServer();\n  1194→    try {\n  1195→      const handle = await worldSession(\n  1196→        { ...base, host: \"127.0.0.1\", port: ws.port },\n  1197→        fakeAuth(ws.port),"}]},"uuid":"c810983a-da32-4765-beb9-d19ff8829069","timestamp":"2026-02-28T23:45:25.904Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","content":"      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches channel\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"channel test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.CHANNEL);\n      expect(msg.message).toBe(\"channel test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"handler error in drainWorldPackets calls onPacketError\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),","numLines":30,"startLine":1168,"totalLines":2678}},"sourceToolAssistantUUID":"669fc6fa-2791-4a07-960f-46ba436a3fe8"}
{"parentUuid":"c810983a-da32-4765-beb9-d19ff8829069","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01H4bttChRVXSqw2zDCrc49v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F5MPcvZ8xYZ3nqVV2QdyaZ","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","old_string":"  test(\"sendInCurrentMode dispatches channel\", async () => {","new_string":"  test(\"sendInCurrentMode dispatches emote\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"emote\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"emote test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.EMOTE);\n      expect(msg.message).toBe(\"emote test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches channel\", async () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":784,"cache_read_input_tokens":95035,"output_tokens":359,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":784,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMfkax2DCYXEemvyH8y","type":"assistant","uuid":"15e279a8-a518-4628-9b68-87b20a93e779","timestamp":"2026-02-28T23:45:33.344Z"}
{"parentUuid":"15e279a8-a518-4628-9b68-87b20a93e779","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F5MPcvZ8xYZ3nqVV2QdyaZ","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/wow/client.test.ts has been updated successfully."}]},"uuid":"5709139f-344c-4f4a-9067-bf3e8da7b876","timestamp":"2026-02-28T23:45:33.363Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/wow/client.test.ts","oldString":"  test(\"sendInCurrentMode dispatches channel\", async () => {","newString":"  test(\"sendInCurrentMode dispatches emote\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"emote\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"emote test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.EMOTE);\n      expect(msg.message).toBe(\"emote test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches channel\", async () => {","originalFile":"import { test, expect, describe, beforeAll, afterAll } from \"bun:test\";\nimport { deflateSync } from \"node:zlib\";\nimport {\n  authHandshake,\n  authWithRetry,\n  worldSession,\n  ReconnectRequiredError,\n  type ChatMessage,\n  type GroupEvent,\n  type WorldHandle,\n  type FriendEvent,\n} from \"wow/client\";\nimport type { AuthResult } from \"wow/client\";\nimport { startMockAuthServer } from \"test/mock-auth-server\";\nimport { startMockWorldServer } from \"test/mock-world-server\";\nimport { PacketWriter, PacketReader } from \"wow/protocol/packet\";\nimport {\n  AuthOpcode,\n  GameOpcode,\n  ChatType,\n  ChannelNotify,\n  PartyOperation,\n  PartyResult,\n  GroupUpdateFlag,\n} from \"wow/protocol/opcodes\";\nimport { bigIntToLeBytes } from \"wow/crypto/srp\";\nimport type { EntityEvent } from \"wow/entity-store\";\nimport {\n  UpdateFlag,\n  OBJECT_FIELDS,\n  UNIT_FIELDS,\n  GAMEOBJECT_FIELDS,\n} from \"wow/protocol/entity-fields\";\nimport {\n  FIXTURE_ACCOUNT,\n  FIXTURE_PASSWORD,\n  FIXTURE_CHARACTER,\n  clientPrivateKey,\n  clientSeed,\n  sessionKey,\n  salt,\n  g,\n  N,\n  B_LE,\n  M2_bytes,\n  reconnectChallengeData,\n} from \"test/fixtures\";\n\nconst base = {\n  account: FIXTURE_ACCOUNT,\n  password: FIXTURE_PASSWORD,\n  character: FIXTURE_CHARACTER,\n  srpPrivateKey: clientPrivateKey,\n  clientSeed,\n};\n\nasync function waitForEchoProbe(\n  handle: Pick<WorldHandle, \"onMessage\" | \"sendSay\">,\n): Promise<void> {\n  const received = new Promise<ChatMessage>((resolve) => {\n    handle.onMessage(resolve);\n  });\n  handle.sendSay(\"probe\");\n  await received;\n}\n\nfunction waitForGroupEvents(\n  handle: Pick<WorldHandle, \"onGroupEvent\">,\n  count: number,\n): Promise<GroupEvent[]> {\n  const events: GroupEvent[] = [];\n  return new Promise((resolve) => {\n    handle.onGroupEvent((event) => {\n      events.push(event);\n      if (events.length === count) resolve(events);\n    });\n  });\n}\n\nfunction buildChallengeResponse(): Uint8Array {\n  const w = new PacketWriter();\n  w.uint8(AuthOpcode.LOGON_CHALLENGE);\n  w.uint8(0x00);\n  w.uint8(0x00);\n  w.rawBytes(B_LE);\n  w.uint8(1);\n  w.uint8(Number(g));\n  w.uint8(32);\n  w.rawBytes(bigIntToLeBytes(N, 32));\n  w.rawBytes(salt);\n  w.rawBytes(new Uint8Array(16));\n  w.uint8(0x00);\n  return w.finish();\n}\n\nfunction buildSuccessProofResponse(): Uint8Array {\n  const w = new PacketWriter();\n  w.uint8(AuthOpcode.LOGON_PROOF);\n  w.uint8(0x00);\n  w.rawBytes(M2_bytes);\n  w.uint32LE(0x00800000);\n  w.uint32LE(0);\n  w.uint16LE(0);\n  return w.finish();\n}\n\ndescribe(\"mock integration\", () => {\n  let authServer: { port: number; stop(): void };\n  let worldServer: { port: number; stop(): void };\n\n  beforeAll(async () => {\n    worldServer = await startMockWorldServer();\n    authServer = await startMockAuthServer({\n      realmAddress: `127.0.0.1:${worldServer.port}`,\n    });\n  });\n\n  afterAll(() => {\n    authServer?.stop();\n    worldServer?.stop();\n  });\n\n  test(\"authHandshake completes SRP and returns session key\", async () => {\n    const auth = await authHandshake({\n      ...base,\n      host: \"127.0.0.1\",\n      port: authServer.port,\n    });\n\n    expect(auth.sessionKey).toEqual(sessionKey);\n    expect(auth.realmHost).toBe(\"127.0.0.1\");\n    expect(auth.realmPort).toBe(worldServer.port);\n    expect(auth.realmId).toBe(1);\n  });\n\n  test(\"full login flow: auth → world → character select → login\", async () => {\n    const auth = await authHandshake({\n      ...base,\n      host: \"127.0.0.1\",\n      port: authServer.port,\n    });\n    const handle = await worldSession(\n      { ...base, host: \"127.0.0.1\", port: worldServer.port },\n      auth,\n    );\n\n    handle.close();\n    await handle.closed;\n  });\n});\n\ndescribe(\"auth error paths\", () => {\n  test(\"rejects when challenge status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          socket.write(new Uint8Array([0x00, 0x00, 0x05]));\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"Auth challenge failed: status 0x5\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when proof status is non-zero\", async () => {\n    const server = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          account: \"WRONG\",\n          srpPrivateKey:\n            0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefn,\n          host: \"127.0.0.1\",\n          port: server.port,\n        }),\n      ).rejects.toThrow(\"Auth proof failed: status 0x5\");\n    } finally {\n      server.stop();\n    }\n  });\n\n  test(\"rejects when server M2 does not match\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(buildChallengeResponse());\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.LOGON_PROOF);\n            w.uint8(0x00);\n            w.rawBytes(new Uint8Array(20));\n            w.uint32LE(0x00800000);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"Server M2 mismatch\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"handles fragmented challenge response\", async () => {\n    const challengeData = buildChallengeResponse();\n    const splitAt = 50;\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(challengeData.slice(0, splitAt));\n            setTimeout(() => socket.write(challengeData.slice(splitAt)), 0);\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            socket.write(buildSuccessProofResponse());\n          } else if (opcode === AuthOpcode.REALM_LIST) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.REALM_LIST);\n            w.uint16LE(8);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"No realms available\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when no realms are available\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            socket.write(buildChallengeResponse());\n          } else if (opcode === AuthOpcode.LOGON_PROOF) {\n            socket.write(buildSuccessProofResponse());\n          } else if (opcode === AuthOpcode.REALM_LIST) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.REALM_LIST);\n            w.uint16LE(8);\n            w.uint32LE(0);\n            w.uint16LE(0);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: server.port }),\n      ).rejects.toThrow(\"No realms available\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"reconnect challenge succeeds with cached session key\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      const auth = await authHandshake({\n        ...base,\n        host: \"127.0.0.1\",\n        port: authServer.port,\n        cachedSessionKey: sessionKey,\n      });\n\n      expect(auth.sessionKey).toEqual(sessionKey);\n      expect(auth.realmHost).toBe(\"127.0.0.1\");\n      expect(auth.realmPort).toBe(1234);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"rejects when reconnect challenge status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          const w = new PacketWriter();\n          w.uint8(AuthOpcode.RECONNECT_CHALLENGE);\n          w.uint8(0x04);\n          socket.write(w.finish());\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          host: \"127.0.0.1\",\n          port: server.port,\n          cachedSessionKey: sessionKey,\n        }),\n      ).rejects.toThrow(\"Reconnect challenge failed: status 0x4\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"rejects when reconnect proof status is non-zero\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket, data) {\n          const opcode = new Uint8Array(data)[0];\n          if (opcode === AuthOpcode.LOGON_CHALLENGE) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.RECONNECT_CHALLENGE);\n            w.uint8(0x00);\n            w.rawBytes(reconnectChallengeData);\n            w.rawBytes(new Uint8Array(16));\n            socket.write(w.finish());\n          } else if (opcode === AuthOpcode.RECONNECT_PROOF) {\n            const w = new PacketWriter();\n            w.uint8(AuthOpcode.RECONNECT_PROOF);\n            w.uint8(0x0b);\n            socket.write(w.finish());\n          }\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({\n          ...base,\n          host: \"127.0.0.1\",\n          port: server.port,\n          cachedSessionKey: sessionKey,\n        }),\n      ).rejects.toThrow(\"Reconnect proof failed: status 0xb\");\n    } finally {\n      server.stop(true);\n    }\n  });\n\n  test(\"reconnect challenge without cached key throws ReconnectRequiredError\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      await expect(\n        authHandshake({ ...base, host: \"127.0.0.1\", port: authServer.port }),\n      ).rejects.toThrow(ReconnectRequiredError);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry succeeds on first attempt with cached key\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      const auth = await authWithRetry(\n        {\n          ...base,\n          host: \"127.0.0.1\",\n          port: authServer.port,\n          cachedSessionKey: sessionKey,\n        },\n        { maxAttempts: 3, baseDelayMs: 1 },\n      );\n\n      expect(auth.sessionKey).toEqual(sessionKey);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry gives up after maxAttempts\", async () => {\n    const authServer = await startMockAuthServer({\n      realmAddress: \"127.0.0.1:1234\",\n      reconnect: {\n        challengeData: reconnectChallengeData,\n        sessionKey,\n      },\n    });\n\n    try {\n      await expect(\n        authWithRetry(\n          { ...base, host: \"127.0.0.1\", port: authServer.port },\n          { maxAttempts: 2, baseDelayMs: 1 },\n        ),\n      ).rejects.toThrow(ReconnectRequiredError);\n    } finally {\n      authServer.stop();\n    }\n  });\n\n  test(\"authWithRetry propagates non-reconnect errors immediately\", async () => {\n    const server = Bun.listen({\n      hostname: \"127.0.0.1\",\n      port: 0,\n      socket: {\n        data(socket) {\n          socket.write(new Uint8Array([0x00, 0x00, 0x05]));\n        },\n        open() {},\n        close() {},\n        error() {},\n      },\n    });\n\n    try {\n      await expect(\n        authWithRetry(\n          { ...base, host: \"127.0.0.1\", port: server.port },\n          { maxAttempts: 3, baseDelayMs: 1 },\n        ),\n      ).rejects.toThrow(\"Auth challenge failed: status 0x5\");\n    } finally {\n      server.stop(true);\n    }\n  });\n});\n\ndescribe(\"world error paths\", () => {\n  function fakeAuth(port: number): AuthResult {\n    return {\n      sessionKey,\n      realmHost: \"127.0.0.1\",\n      realmPort: port,\n      realmId: 1,\n    };\n  }\n\n  test(\"handles SMSG_TIME_SYNC_REQ\", async () => {\n    const ws = await startMockWorldServer({ sendTimeSyncAfterLogin: true });\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      await waitForEchoProbe(handle);\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects when world auth status is not 0x0c\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x01 });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: status 0x1\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects with named message for system error (0x0d)\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x0d });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: system error\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects with named message for account in use (0x15)\", async () => {\n    const ws = await startMockWorldServer({ authStatus: 0x15 });\n    try {\n      await expect(\n        worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow(\"World auth failed: account in use\");\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"rejects when character is not found\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      await expect(\n        worldSession(\n          {\n            ...base,\n            character: \"Nonexistent\",\n            host: \"127.0.0.1\",\n            port: ws.port,\n          },\n          fakeAuth(ws.port),\n        ),\n      ).rejects.toThrow('Character \"Nonexistent\" not found');\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"ping interval fires and server handles CMSG_PING\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port, pingIntervalMs: 1 },\n        fakeAuth(ws.port),\n      );\n      await Bun.sleep(2);\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendWhisper with empty target does not poison sticky mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.sendWhisper(\"\", \"\");\n      expect(handle.getLastChatMode()).toEqual({ type: \"say\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendWhisper sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const messageReceived = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage(resolve);\n      });\n\n      handle.sendWhisper(\"Someone\", \"test whisper\");\n      const msg = await messageReceived;\n\n      expect(msg.message).toBe(\"test whisper\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"channel tracking populates from SMSG_CHANNEL_NOTIFY\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      await waitForEchoProbe(handle);\n\n      expect(handle.getChannel(1)).toBe(\"General\");\n      expect(handle.getChannel(2)).toBe(\"Trade\");\n      expect(handle.getChannel(3)).toBeUndefined();\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"who returns results from mock server\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const results = await handle.who({});\n      expect(results.length).toBe(1);\n      expect(results[0]!.name).toBe(FIXTURE_CHARACTER);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendSay sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"test say\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SAY);\n      expect(msg.message).toBe(\"test say\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendYell sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendYell(\"test yell\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.YELL);\n      expect(msg.message).toBe(\"test yell\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendGuild sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendGuild(\"test guild\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.GUILD);\n      expect(msg.message).toBe(\"test guild\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendParty sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendParty(\"test party\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.PARTY);\n      expect(msg.message).toBe(\"test party\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendRaid sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendRaid(\"test raid\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.RAID);\n      expect(msg.message).toBe(\"test raid\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendEmote sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendEmote(\"test emote\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.EMOTE);\n      expect(msg.message).toBe(\"test emote\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendChannel sends message and receives echo\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendChannel(\"General\", \"test channel\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.CHANNEL);\n      expect(msg.message).toBe(\"test channel\");\n      expect(msg.channel).toBe(\"General\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"cached sender name skips name query on second message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const first = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"first\");\n      await first;\n\n      const second = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendSay(\"second\");\n      const msg = await second;\n      expect(msg.sender).toBe(FIXTURE_CHARACTER);\n      expect(msg.message).toBe(\"second\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"multiple pending messages for same guid\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const messages: ChatMessage[] = [];\n      const gotTwo = new Promise<void>((resolve) => {\n        handle.onMessage((msg) => {\n          messages.push(msg);\n          if (messages.length === 2) resolve();\n        });\n      });\n\n      handle.sendSay(\"msg1\");\n      handle.sendSay(\"msg2\");\n      await gotTwo;\n\n      expect(messages[0]!.message).toBe(\"msg1\");\n      expect(messages[1]!.message).toBe(\"msg2\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"zero-guid system message delivers with empty sender\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint8(ChatType.SYSTEM);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      w.uint32LE(0);\n      const msgBytes = new TextEncoder().encode(\"Server shutting down\");\n      w.uint32LE(msgBytes.byteLength);\n      w.rawBytes(msgBytes);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_MESSAGE_CHAT, w.finish());\n\n      const msg = await received;\n      expect(msg.sender).toBe(\"\");\n      expect(msg.message).toBe(\"Server shutting down\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"GM chat message delivers with sender name from packet\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint8(ChatType.SAY);\n      w.uint32LE(0);\n      w.uint32LE(0x42);\n      w.uint32LE(0x00);\n      w.uint32LE(0);\n      const nameBytes = new TextEncoder().encode(\"GameMaster\");\n      w.uint32LE(nameBytes.byteLength);\n      w.rawBytes(nameBytes);\n      w.uint32LE(0x42);\n      w.uint32LE(0x00);\n      const msgBytes = new TextEncoder().encode(\"hello from gm\");\n      w.uint32LE(msgBytes.byteLength);\n      w.rawBytes(msgBytes);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_GM_MESSAGECHAT, w.finish());\n\n      const msg = await received;\n      expect(msg.sender).toBe(\"GameMaster\");\n      expect(msg.message).toBe(\"hello from gm\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"player not found delivers system message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.cString(\"Ghostplayer\");\n      ws.inject(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, w.finish());\n\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toBe(\n        'No player named \"Ghostplayer\" is currently playing.',\n      );\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"SMSG_MOTD delivers each line as a system message\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n\n      const w = new PacketWriter();\n      w.uint32LE(2);\n      w.cString(\"Welcome to the server!\");\n      w.cString(\"Enjoy your stay.\");\n      ws.inject(GameOpcode.SMSG_MOTD, w.finish());\n\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toBe(\"Welcome to the server!\\nEnjoy your stay.\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"channel left removes from channel list\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      await waitForEchoProbe(handle);\n      expect(handle.getChannel(1)).toBe(\"General\");\n\n      const w = new PacketWriter();\n      w.uint8(ChannelNotify.YOU_LEFT);\n      w.cString(\"General\");\n      w.uint32LE(0);\n      w.uint8(0);\n      ws.inject(GameOpcode.SMSG_CHANNEL_NOTIFY, w.finish());\n\n      await waitForEchoProbe(handle);\n      expect(handle.getChannel(1)).toBe(\"Trade\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"getLastChatMode defaults to say\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      expect(handle.getLastChatMode()).toEqual({ type: \"say\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"setLastChatMode updates mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"guild\" });\n      expect(handle.getLastChatMode()).toEqual({ type: \"guild\" });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches based on last mode\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"hello via say\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SAY);\n      expect(msg.message).toBe(\"hello via say\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches whisper after mode change\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"whisper\", target: \"Someone\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"whisper test\");\n      const msg = await received;\n      expect(msg.message).toBe(\"whisper test\");\n      expect(handle.getLastChatMode()).toEqual({\n        type: \"whisper\",\n        target: \"Someone\",\n      });\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches yell\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"yell\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"yell test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.YELL);\n      expect(msg.message).toBe(\"yell test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches guild\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"guild\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"guild test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.GUILD);\n      expect(msg.message).toBe(\"guild test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches party\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"party\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"party test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.PARTY);\n      expect(msg.message).toBe(\"party test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches raid\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"raid\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"raid test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.RAID);\n      expect(msg.message).toBe(\"raid test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"sendInCurrentMode dispatches channel\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n      handle.setLastChatMode({ type: \"channel\", channel: \"General\" });\n      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n      handle.sendInCurrentMode(\"channel test\");\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.CHANNEL);\n      expect(msg.message).toBe(\"channel test\");\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"handler error in drainWorldPackets calls onPacketError\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const errors: { opcode: number; message: string }[] = [];\n      handle.onPacketError((opcode, err) => {\n        errors.push({ opcode, message: err.message });\n      });\n\n      ws.inject(GameOpcode.SMSG_TIME_SYNC_REQ, new Uint8Array(0));\n      await waitForEchoProbe(handle);\n\n      expect(errors.length).toBeGreaterThan(0);\n      expect(errors[0]!.opcode).toBe(GameOpcode.SMSG_TIME_SYNC_REQ);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group opcodes emit expected group events\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = waitForGroupEvents(handle, 9);\n\n      const result = new PacketWriter();\n      result.uint32LE(PartyOperation.INVITE);\n      result.cString(\"Voidtrix\");\n      result.uint32LE(PartyResult.SUCCESS);\n      result.uint32LE(0);\n      ws.inject(GameOpcode.SMSG_PARTY_COMMAND_RESULT, result.finish());\n\n      const invite = new PacketWriter();\n      invite.uint8(1);\n      invite.cString(\"Leader\");\n      invite.uint32LE(0);\n      invite.uint8(0);\n      invite.uint32LE(0);\n      ws.inject(GameOpcode.SMSG_GROUP_INVITE, invite.finish());\n\n      const leader = new PacketWriter();\n      leader.cString(\"Newleader\");\n      ws.inject(GameOpcode.SMSG_GROUP_SET_LEADER, leader.finish());\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n\n      ws.inject(GameOpcode.SMSG_GROUP_DESTROYED, new Uint8Array(0));\n      ws.inject(GameOpcode.SMSG_GROUP_UNINVITE, new Uint8Array(0));\n\n      const decline = new PacketWriter();\n      decline.cString(\"Decliner\");\n      ws.inject(GameOpcode.SMSG_GROUP_DECLINE, decline.finish());\n\n      const stats = new PacketWriter();\n      stats.uint8(0x01);\n      stats.uint8(0x42);\n      stats.uint32LE(GroupUpdateFlag.STATUS | GroupUpdateFlag.CUR_HP);\n      stats.uint16LE(0x01);\n      stats.uint32LE(12000);\n      ws.inject(GameOpcode.SMSG_PARTY_MEMBER_STATS, stats.finish());\n\n      const fullStats = new PacketWriter();\n      fullStats.uint8(0);\n      fullStats.uint8(0x01);\n      fullStats.uint8(0x43);\n      fullStats.uint32LE(GroupUpdateFlag.STATUS | GroupUpdateFlag.LEVEL);\n      fullStats.uint16LE(0x01);\n      fullStats.uint16LE(80);\n      ws.inject(GameOpcode.SMSG_PARTY_MEMBER_STATS_FULL, fullStats.finish());\n\n      const events = await received;\n      expect(events.map((event) => event.type)).toEqual([\n        \"command_result\",\n        \"invite_received\",\n        \"leader_changed\",\n        \"group_list\",\n        \"group_destroyed\",\n        \"kicked\",\n        \"invite_declined\",\n        \"member_stats\",\n        \"member_stats\",\n      ]);\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group_list resolves self as leader when leader GUID matches\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<GroupEvent>((resolve) => {\n        handle.onGroupEvent(resolve);\n      });\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x00);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x42);\n      list.uint32LE(0x00);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n\n      const event = await received;\n      expect(event.type).toBe(\"group_list\");\n      if (event.type === \"group_list\") {\n        expect(event.leader).toBe(\"Testchar\");\n      }\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"setLeader reports missing party member\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage(resolve);\n      });\n\n      handle.setLeader(\"Ghostplayer\");\n      const message = await received;\n      expect(message.type).toBe(ChatType.SYSTEM);\n      expect(message.message).toBe('\"Ghostplayer\" is not in your party.');\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"stubbed opcode notifies via onMessage\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const received = new Promise<ChatMessage>((resolve) => {\n        handle.onMessage((msg) => {\n          if (msg.message.includes(\"not yet implemented\")) resolve(msg);\n        });\n      });\n\n      ws.inject(GameOpcode.SMSG_CHAT_SERVER_MESSAGE, new Uint8Array(0));\n      const msg = await received;\n      expect(msg.type).toBe(ChatType.SYSTEM);\n      expect(msg.message).toContain(\"Server broadcast message\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  test(\"group command methods run after login\", async () => {\n    const ws = await startMockWorldServer();\n    try {\n      const handle = await worldSession(\n        { ...base, host: \"127.0.0.1\", port: ws.port },\n        fakeAuth(ws.port),\n      );\n\n      const groupListReady = new Promise<void>((resolve) => {\n        handle.onGroupEvent((event) => {\n          if (event.type === \"group_list\") resolve();\n        });\n      });\n\n      const list = new PacketWriter();\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0);\n      list.uint32LE(0);\n      list.uint32LE(1);\n      list.uint32LE(1);\n      list.cString(\"Voidtrix\");\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      list.uint8(1);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint8(0);\n      list.uint32LE(0x10);\n      list.uint32LE(0x20);\n      ws.inject(GameOpcode.SMSG_GROUP_LIST, list.finish());\n      await groupListReady;\n\n      handle.invite(\"Voidtrix\");\n      handle.uninvite(\"Voidtrix\");\n      handle.leaveGroup();\n      handle.acceptInvite();\n      handle.declineInvite();\n      handle.setLeader(\"Voidtrix\");\n\n      handle.close();\n      await handle.closed;\n    } finally {\n      ws.stop();\n    }\n  });\n\n  describe(\"entity handling\", () => {\n    function writePackedGuid(w: PacketWriter, guid: bigint) {\n      const low = Number(guid & 0xffffffffn);\n      const high = Number((guid >> 32n) & 0xffffffffn);\n      let mask = 0;\n      const bytes: number[] = [];\n      for (let i = 0; i < 4; i++) {\n        const b = (low >> (i * 8)) & 0xff;\n        if (b !== 0) {\n          mask |= 1 << i;\n          bytes.push(b);\n        }\n      }\n      for (let i = 0; i < 4; i++) {\n        const b = (high >> (i * 8)) & 0xff;\n        if (b !== 0) {\n          mask |= 1 << (i + 4);\n          bytes.push(b);\n        }\n      }\n      w.uint8(mask);\n      for (const b of bytes) w.uint8(b);\n    }\n\n    function writeLivingMovementBlock(\n      w: PacketWriter,\n      x: number,\n      y: number,\n      z: number,\n      orientation: number,\n    ) {\n      w.uint16LE(UpdateFlag.LIVING);\n      w.uint32LE(0);\n      w.uint16LE(0);\n      w.uint32LE(0);\n      w.floatLE(x);\n      w.floatLE(y);\n      w.floatLE(z);\n      w.floatLE(orientation);\n      w.floatLE(0);\n      for (let i = 0; i < 9; i++) w.floatLE(0);\n    }\n\n    function writeHasPositionMovementBlock(\n      w: PacketWriter,\n      x: number,\n      y: number,\n      z: number,\n      orientation: number,\n    ) {\n      w.uint16LE(UpdateFlag.HAS_POSITION);\n      w.floatLE(x);\n      w.floatLE(y);\n      w.floatLE(z);\n      w.floatLE(orientation);\n    }\n\n    function writeUpdateMask(w: PacketWriter, fields: Map<number, number>) {\n      let maxBit = 0;\n      for (const bit of fields.keys()) {\n        if (bit > maxBit) maxBit = bit;\n      }\n      const blockCount =\n        maxBit === 0 && fields.size === 0 ? 0 : Math.floor(maxBit / 32) + 1;\n      w.uint8(blockCount);\n      const masks = new Array<number>(blockCount).fill(0);\n      for (const bit of fields.keys()) {\n        masks[Math.floor(bit / 32)]! |= 1 << (bit % 32);\n      }\n      for (const m of masks) w.uint32LE(m);\n      for (let block = 0; block < blockCount; block++) {\n        for (let bit = 0; bit < 32; bit++) {\n          const index = block * 32 + bit;\n          if (fields.has(index)) {\n            w.uint32LE(fields.get(index)!);\n          }\n        }\n      }\n    }\n\n    function buildCreateUnitPacket(\n      guid: bigint,\n      entry: number,\n      health: number,\n      maxHealth: number,\n    ): Uint8Array {\n      const w = new PacketWriter();\n      w.uint32LE(1);\n      w.uint8(3);\n      writePackedGuid(w, guid);\n      w.uint8(3);\n      writeLivingMovementBlock(w, 100, 200, 300, 1.5);\n      const fields = new Map<number, number>([\n        [OBJECT_FIELDS.ENTRY.offset, entry],\n        [UNIT_FIELDS.HEALTH.offset, health],\n        [UNIT_FIELDS.MAXHEALTH.offset, maxHealth],\n      ]);\n      writeUpdateMask(w, fields);\n      return w.finish();\n    }\n\n    function waitForEntityEvents(\n      handle: Pick<WorldHandle, \"onEntityEvent\">,\n      count: number,\n    ): Promise<EntityEvent[]> {\n      const events: EntityEvent[] = [];\n      return new Promise((resolve) => {\n        handle.onEntityEvent((event) => {\n          events.push(event);\n          if (events.length === count) resolve(events);\n        });\n      });\n    }\n\n    test(\"entity create and creature query response\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const events = waitForEntityEvents(handle, 2);\n\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(100n, 1234, 500, 1000),\n        );\n\n        const creatureResp = new PacketWriter();\n        creatureResp.uint32LE(1234);\n        creatureResp.cString(\"Young Wolf\");\n        ws.inject(\n          GameOpcode.SMSG_CREATURE_QUERY_RESPONSE,\n          creatureResp.finish(),\n        );\n\n        const [appear, nameUpdate] = await events;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.guid).toBe(100n);\n          expect(appear!.entity.objectType).toBe(3);\n        }\n        expect(nameUpdate!.type).toBe(\"update\");\n        if (nameUpdate!.type === \"update\") {\n          expect(nameUpdate!.changed).toContain(\"name\");\n          expect(nameUpdate!.entity.name).toBe(\"Young Wolf\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"entity values update\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(200n, 5000, 100, 200),\n        );\n        await appearReady;\n\n        const updateReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(0);\n        writePackedGuid(w, 200n);\n        writeUpdateMask(w, new Map([[UNIT_FIELDS.HEALTH.offset, 50]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [update] = await updateReady;\n        expect(update!.type).toBe(\"update\");\n        if (update!.type === \"update\") {\n          expect(update!.changed).toContain(\"health\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"entity movement\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(300n, 6000, 100, 200),\n        );\n        await appearReady;\n\n        const moveReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(1);\n        writePackedGuid(w, 300n);\n        writeHasPositionMovementBlock(w, 10.5, 20.5, 30.5, 1.25);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [move] = await moveReady;\n        expect(move!.type).toBe(\"update\");\n        if (move!.type === \"update\") {\n          expect(move!.changed).toContain(\"position\");\n          expect(move!.entity.position!.x).toBeCloseTo(10.5);\n          expect(move!.entity.position!.y).toBeCloseTo(20.5);\n          expect(move!.entity.position!.z).toBeCloseTo(30.5);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"out of range removes entities\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear1 = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(400n, 7000, 100, 200),\n        );\n        await appear1;\n\n        const appear2 = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(401n, 7001, 100, 200),\n        );\n        await appear2;\n\n        expect(handle.getNearbyEntities().length).toBe(2);\n\n        const disappearReady = waitForEntityEvents(handle, 2);\n\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(4);\n        w.uint32LE(2);\n        writePackedGuid(w, 400n);\n        writePackedGuid(w, 401n);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const events = await disappearReady;\n        expect(events[0]!.type).toBe(\"disappear\");\n        expect(events[1]!.type).toBe(\"disappear\");\n        expect(handle.getNearbyEntities().length).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_DESTROY_OBJECT removes entity\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(500n, 8000, 100, 200),\n        );\n        await appearReady;\n\n        const disappearReady = waitForEntityEvents(handle, 1);\n\n        const w = new PacketWriter();\n        w.uint64LE(500n);\n        w.uint8(0);\n        ws.inject(GameOpcode.SMSG_DESTROY_OBJECT, w.finish());\n\n        const [disappear] = await disappearReady;\n        expect(disappear!.type).toBe(\"disappear\");\n        if (disappear!.type === \"disappear\") {\n          expect(disappear!.guid).toBe(500n);\n        }\n        expect(handle.getNearbyEntities().length).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"game object query response\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 600n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 50, 60, 70, 0.5);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 9999]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await appearReady;\n\n        const updateReady = waitForEntityEvents(handle, 2);\n\n        const goResp = new PacketWriter();\n        goResp.uint32LE(9999);\n        goResp.uint32LE(19);\n        goResp.uint32LE(0);\n        goResp.cString(\"Mailbox\");\n        ws.inject(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, goResp.finish());\n\n        const events = await updateReady;\n        const nameEvent = events.find(\n          (e) => e.type === \"update\" && e.changed.includes(\"name\"),\n        );\n        const typeEvent = events.find(\n          (e) => e.type === \"update\" && e.changed.includes(\"gameObjectType\"),\n        );\n        expect(nameEvent).toBeDefined();\n        expect(typeEvent).toBeDefined();\n        if (nameEvent?.type === \"update\") {\n          expect(nameEvent.entity.name).toBe(\"Mailbox\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"player name backfill via CMSG_NAME_QUERY\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const events = waitForEntityEvents(handle, 2);\n\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(3);\n        writePackedGuid(createW, 0x42n);\n        createW.uint8(4);\n        writeLivingMovementBlock(createW, 10, 20, 30, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 0]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n\n        const [appear, nameUpdate] = await events;\n        expect(appear!.type).toBe(\"appear\");\n        expect(nameUpdate!.type).toBe(\"update\");\n        if (nameUpdate!.type === \"update\") {\n          expect(nameUpdate!.entity.name).toBe(FIXTURE_CHARACTER);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"compressed update object\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appearReady = waitForEntityEvents(handle, 1);\n\n        const payload = buildCreateUnitPacket(700n, 3333, 250, 500);\n        const compressed = deflateSync(payload, { level: 6 });\n        const envelope = new PacketWriter();\n        envelope.uint32LE(payload.byteLength);\n        envelope.rawBytes(new Uint8Array(compressed));\n        ws.inject(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, envelope.finish());\n\n        const [appear] = await appearReady;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.guid).toBe(700n);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"cached creature name lookup\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const firstAppear = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(800n, 5555, 100, 200),\n        );\n        await firstAppear;\n\n        const nameReady = waitForEntityEvents(handle, 1);\n        const creatureResp = new PacketWriter();\n        creatureResp.uint32LE(5555);\n        creatureResp.cString(\"Stormwind Guard\");\n        ws.inject(\n          GameOpcode.SMSG_CREATURE_QUERY_RESPONSE,\n          creatureResp.finish(),\n        );\n        await nameReady;\n\n        const secondAppear = waitForEntityEvents(handle, 1);\n        ws.inject(\n          GameOpcode.SMSG_UPDATE_OBJECT,\n          buildCreateUnitPacket(801n, 5555, 100, 200),\n        );\n\n        const [appear] = await secondAppear;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.name).toBe(\"Stormwind Guard\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"gameobject values update\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear = waitForEntityEvents(handle, 1);\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 500n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 1, 2, 3, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 100]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await appear;\n\n        const update = waitForEntityEvents(handle, 1);\n        const valW = new PacketWriter();\n        valW.uint32LE(1);\n        valW.uint8(0);\n        writePackedGuid(valW, 500n);\n        writeUpdateMask(valW, new Map([[GAMEOBJECT_FIELDS.FLAGS.offset, 42]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, valW.finish());\n        const [evt] = await update;\n        expect(evt!.type).toBe(\"update\");\n\n        const nearW = new PacketWriter();\n        nearW.uint32LE(1);\n        nearW.uint8(5);\n        nearW.uint32LE(1);\n        writePackedGuid(nearW, 500n);\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, nearW.finish());\n        await Bun.sleep(1);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"compressed size mismatch triggers packet error\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const gotError = new Promise<Error>((resolve) => {\n          handle.onPacketError((_op, err) => resolve(err));\n        });\n\n        const payload = buildCreateUnitPacket(300n, 1, 50, 50);\n        const compressed = deflateSync(payload);\n        const w = new PacketWriter();\n        w.uint32LE(payload.byteLength + 999);\n        w.rawBytes(new Uint8Array(compressed));\n        ws.inject(GameOpcode.SMSG_COMPRESSED_UPDATE_OBJECT, w.finish());\n\n        const err = await gotError;\n        expect(err.message).toContain(\"size mismatch\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"corpse entity create uses base entity\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const appear = waitForEntityEvents(handle, 1);\n        const w = new PacketWriter();\n        w.uint32LE(1);\n        w.uint8(2);\n        writePackedGuid(w, 999n);\n        w.uint8(7);\n        writeHasPositionMovementBlock(w, 10, 20, 30, 0);\n        writeUpdateMask(w, new Map([[OBJECT_FIELDS.ENTRY.offset, 42]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, w.finish());\n\n        const [evt] = await appear;\n        expect(evt!.type).toBe(\"appear\");\n        if (evt!.type === \"appear\") {\n          expect(evt!.entity.objectType).toBe(7);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"cached game object name lookup\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const firstAppear = waitForEntityEvents(handle, 1);\n        const createW = new PacketWriter();\n        createW.uint32LE(1);\n        createW.uint8(2);\n        writePackedGuid(createW, 900n);\n        createW.uint8(5);\n        writeHasPositionMovementBlock(createW, 1, 2, 3, 0);\n        writeUpdateMask(createW, new Map([[OBJECT_FIELDS.ENTRY.offset, 7777]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, createW.finish());\n        await firstAppear;\n\n        const nameReady = waitForEntityEvents(handle, 2);\n        const goResp = new PacketWriter();\n        goResp.uint32LE(7777);\n        goResp.uint32LE(19);\n        goResp.uint32LE(0);\n        goResp.cString(\"Forge\");\n        ws.inject(GameOpcode.SMSG_GAMEOBJECT_QUERY_RESPONSE, goResp.finish());\n        await nameReady;\n\n        const secondAppear = waitForEntityEvents(handle, 1);\n        const create2 = new PacketWriter();\n        create2.uint32LE(1);\n        create2.uint8(2);\n        writePackedGuid(create2, 901n);\n        create2.uint8(5);\n        writeHasPositionMovementBlock(create2, 4, 5, 6, 0);\n        writeUpdateMask(create2, new Map([[OBJECT_FIELDS.ENTRY.offset, 7777]]));\n        ws.inject(GameOpcode.SMSG_UPDATE_OBJECT, create2.finish());\n\n        const [appear] = await secondAppear;\n        expect(appear!.type).toBe(\"appear\");\n        if (appear!.type === \"appear\") {\n          expect(appear!.entity.name).toBe(\"Forge\");\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n  });\n\n  describe(\"friend list\", () => {\n    function buildContactList(\n      entries: {\n        guid: bigint;\n        flags: number;\n        note: string;\n        status?: number;\n        area?: number;\n        level?: number;\n        playerClass?: number;\n      }[],\n    ): Uint8Array {\n      const w = new PacketWriter();\n      w.uint32LE(7);\n      w.uint32LE(entries.length);\n      for (const e of entries) {\n        w.uint64LE(e.guid);\n        w.uint32LE(e.flags);\n        w.cString(e.note);\n        if (e.flags & 0x01) {\n          const status = e.status ?? 0;\n          w.uint8(status);\n          if (status !== 0) {\n            w.uint32LE(e.area ?? 0);\n            w.uint32LE(e.level ?? 0);\n            w.uint32LE(e.playerClass ?? 0);\n          }\n        }\n      }\n      return w.finish();\n    }\n\n    function buildFriendStatus(opts: {\n      result: number;\n      guid: bigint;\n      note?: string;\n      status?: number;\n      area?: number;\n      level?: number;\n      playerClass?: number;\n    }): Uint8Array {\n      const w = new PacketWriter();\n      w.uint8(opts.result);\n      w.uint64LE(opts.guid);\n      if (opts.result === 0x06 || opts.result === 0x07) {\n        w.cString(opts.note ?? \"\");\n      }\n      if (opts.result === 0x06 || opts.result === 0x02) {\n        w.uint8(opts.status ?? 1);\n        w.uint32LE(opts.area ?? 0);\n        w.uint32LE(opts.level ?? 0);\n        w.uint32LE(opts.playerClass ?? 0);\n      }\n      return w.finish();\n    }\n\n    function buildNameQueryResponse(guidLow: number, name: string): Uint8Array {\n      const w = new PacketWriter();\n      const mask = guidLow === 0 ? 0 : guidLow <= 0xff ? 0x01 : 0x03;\n      w.uint8(mask);\n      if (mask & 0x01) w.uint8(guidLow & 0xff);\n      if (mask & 0x02) w.uint8((guidLow >> 8) & 0xff);\n      w.uint8(0);\n      w.cString(name);\n      w.cString(\"\");\n      w.uint32LE(1);\n      w.uint32LE(0);\n      w.uint32LE(1);\n      return w.finish();\n    }\n\n    test(\"SMSG_CONTACT_LIST with online friend\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"best buddy\",\n              status: 1,\n              area: 1519,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-list\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0x99n);\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(1519);\n        expect(friends[0]!.level).toBe(80);\n        expect(friends[0]!.playerClass).toBe(1);\n        expect(friends[0]!.note).toBe(\"best buddy\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_CONTACT_LIST filters out ignored entries\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 70,\n              playerClass: 2,\n            },\n            {\n              guid: 0xaan,\n              flags: 0x02,\n              note: \"ignored person\",\n            },\n          ]),\n        );\n\n        await eventReady;\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0x99n);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_CONTACT_LIST triggers name queries\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0x99n,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n\n        await eventReady;\n        await Bun.sleep(1);\n\n        const nameQueries = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_NAME_QUERY,\n        );\n        const match = nameQueries.find((p) => {\n          const r = new PacketReader(p.body);\n          return r.uint32LE() === 0x99;\n        });\n        expect(match).toBeDefined();\n\n        ws.inject(\n          GameOpcode.SMSG_NAME_QUERY_RESPONSE,\n          buildNameQueryResponse(0x99, \"Arthas\"),\n        );\n        await Bun.sleep(1);\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.name).toBe(\"Arthas\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ADDED_ONLINE\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x06,\n            guid: 0xbbn,\n            note: \"new friend\",\n            status: 1,\n            area: 1537,\n            level: 55,\n            playerClass: 4,\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-added\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0xbbn);\n        expect(friends[0]!.note).toBe(\"new friend\");\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(1537);\n        expect(friends[0]!.level).toBe(55);\n        expect(friends[0]!.playerClass).toBe(4);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ONLINE updates existing friend\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xccn,\n              flags: 0x01,\n              note: \"\",\n              status: 0,\n            },\n          ]),\n        );\n        await listReady;\n\n        const onlineReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x02,\n            guid: 0xccn,\n            status: 1,\n            area: 400,\n            level: 60,\n            playerClass: 8,\n          }),\n        );\n\n        const event = await onlineReady;\n        expect(event.type).toBe(\"friend-online\");\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.status).toBe(1);\n        expect(friends[0]!.area).toBe(400);\n        expect(friends[0]!.level).toBe(60);\n        expect(friends[0]!.playerClass).toBe(8);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS OFFLINE clears status\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xddn,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 100,\n              level: 70,\n              playerClass: 5,\n            },\n          ]),\n        );\n        await listReady;\n\n        const offlineReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x03,\n            guid: 0xddn,\n          }),\n        );\n\n        const event = await offlineReady;\n        expect(event.type).toBe(\"friend-offline\");\n\n        const friends = handle.getFriends();\n        expect(friends[0]!.status).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS REMOVED deletes from store\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xeen,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n        await listReady;\n\n        const removedReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x05,\n            guid: 0xeen,\n          }),\n        );\n\n        const event = await removedReady;\n        expect(event.type).toBe(\"friend-removed\");\n\n        expect(handle.getFriends()).toHaveLength(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS ADDED_OFFLINE adds with zero status\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x07,\n            guid: 0xabn,\n            note: \"offline pal\",\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-added\");\n\n        const friends = handle.getFriends();\n        expect(friends).toHaveLength(1);\n        expect(friends[0]!.guid).toBe(0xabn);\n        expect(friends[0]!.note).toBe(\"offline pal\");\n        expect(friends[0]!.status).toBe(0);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"SMSG_FRIEND_STATUS error fires friend-error event\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const eventReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_FRIEND_STATUS,\n          buildFriendStatus({\n            result: 0x04,\n            guid: 0x00n,\n          }),\n        );\n\n        const event = await eventReady;\n        expect(event.type).toBe(\"friend-error\");\n        if (event.type === \"friend-error\") {\n          expect(event.result).toBe(0x04);\n        }\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"addFriend sends CMSG_ADD_FRIEND\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        handle.addFriend(\"Arthas\");\n        await Bun.sleep(1);\n\n        const addPackets = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_ADD_FRIEND,\n        );\n        expect(addPackets).toHaveLength(1);\n        const r = new PacketReader(addPackets[0]!.body);\n        expect(r.cString()).toBe(\"Arthas\");\n        expect(r.cString()).toBe(\"\");\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"removeFriend sends CMSG_DEL_FRIEND\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const listReady = new Promise<FriendEvent>((resolve) => {\n          handle.onFriendEvent(resolve);\n        });\n\n        ws.inject(\n          GameOpcode.SMSG_CONTACT_LIST,\n          buildContactList([\n            {\n              guid: 0xffn,\n              flags: 0x01,\n              note: \"\",\n              status: 1,\n              area: 10,\n              level: 80,\n              playerClass: 1,\n            },\n          ]),\n        );\n        await listReady;\n\n        ws.inject(\n          GameOpcode.SMSG_NAME_QUERY_RESPONSE,\n          buildNameQueryResponse(0xff, \"Arthas\"),\n        );\n        await Bun.sleep(1);\n\n        handle.removeFriend(\"Arthas\");\n        await Bun.sleep(1);\n\n        const delPackets = ws.captured.filter(\n          (p) => p.opcode === GameOpcode.CMSG_DEL_FRIEND,\n        );\n        expect(delPackets).toHaveLength(1);\n        const r = new PacketReader(delPackets[0]!.body);\n        expect(r.uint64LE()).toBe(0xffn);\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n\n    test(\"removeFriend for unknown name triggers system message\", async () => {\n      const ws = await startMockWorldServer();\n      try {\n        const handle = await worldSession(\n          { ...base, host: \"127.0.0.1\", port: ws.port },\n          fakeAuth(ws.port),\n        );\n\n        const received = new Promise<ChatMessage>((resolve) => {\n          handle.onMessage(resolve);\n        });\n\n        handle.removeFriend(\"Nobody\");\n\n        const msg = await received;\n        expect(msg.type).toBe(ChatType.SYSTEM);\n        expect(msg.message).toBe('\"Nobody\" is not on your friends list.');\n\n        handle.close();\n        await handle.closed;\n      } finally {\n        ws.stop();\n      }\n    });\n  });\n});\n","structuredPatch":[{"oldStart":1169,"oldLines":6,"newStart":1169,"newLines":26,"lines":["     }","   });"," ","+  test(\"sendInCurrentMode dispatches emote\", async () => {","+    const ws = await startMockWorldServer();","+    try {","+      const handle = await worldSession(","+        { ...base, host: \"127.0.0.1\", port: ws.port },","+        fakeAuth(ws.port),","+      );","+      handle.setLastChatMode({ type: \"emote\" });","+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));","+      handle.sendInCurrentMode(\"emote test\");","+      const msg = await received;","+      expect(msg.type).toBe(ChatType.EMOTE);","+      expect(msg.message).toBe(\"emote test\");","+      handle.close();","+      await handle.closed;","+    } finally {","+      ws.stop();","+    }","+  });","+","   test(\"sendInCurrentMode dispatches channel\", async () => {","     const ws = await startMockWorldServer();","     try {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"15e279a8-a518-4628-9b68-87b20a93e779"}
{"parentUuid":"5709139f-344c-4f4a-9067-bf3e8da7b876","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FaCjqdjV5v26MPEGNCewiW","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check there's a test for `formatMessage` with emote type, and the `onChatMessage` for emote in `commands.test.ts`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":398,"cache_read_input_tokens":95819,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":398},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMgKmjayrBDma8Do1iV","type":"assistant","uuid":"c2349e22-428a-4fe5-9d7f-f7a3a649b9c2","timestamp":"2026-02-28T23:45:38.207Z"}
{"parentUuid":"c2349e22-428a-4fe5-9d7f-f7a3a649b9c2","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FaCjqdjV5v26MPEGNCewiW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QjjVeEwgYFCf2dpeSeo1Bi","name":"Grep","input":{"pattern":"emote.*format|format.*emote","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":398,"cache_read_input_tokens":95819,"output_tokens":174,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":398,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMgKmjayrBDma8Do1iV","type":"assistant","uuid":"2e0b836d-e56a-43b0-9616-2c064296fde5","timestamp":"2026-02-28T23:45:39.711Z"}
{"parentUuid":"2e0b836d-e56a-43b0-9616-2c064296fde5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QjjVeEwgYFCf2dpeSeo1Bi","type":"tool_result","content":"No matches found"}]},"uuid":"e4f3e04a-48dd-4b00-be0e-0ea54ea428c3","timestamp":"2026-02-28T23:45:39.790Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"2e0b836d-e56a-43b0-9616-2c064296fde5"}
{"parentUuid":"e4f3e04a-48dd-4b00-be0e-0ea54ea428c3","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_015QAD9GCXXPvCBwJBSWZrW4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RdQ1kqbixGPWLxFsP8YJ1J","name":"Grep","input":{"pattern":"formatMessage.*EMOTE|EMOTE.*format","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":189,"cache_read_input_tokens":96217,"output_tokens":138,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":189,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMgmptwvSmVbS528JSn","type":"assistant","uuid":"3355a8bd-a209-4109-bff5-dfd0d693e674","timestamp":"2026-02-28T23:45:43.538Z"}
{"parentUuid":"3355a8bd-a209-4109-bff5-dfd0d693e674","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RdQ1kqbixGPWLxFsP8YJ1J","type":"tool_result","content":"No matches found"}]},"uuid":"88873ec8-a971-452f-a2d3-d92d3ca1453b","timestamp":"2026-02-28T23:45:43.619Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"3355a8bd-a209-4109-bff5-dfd0d693e674"}
{"parentUuid":"88873ec8-a971-452f-a2d3-d92d3ca1453b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01JRyKKf5S16pgjnsgnjX83v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KrEUp5YJTReHqdkGEzv1Dw","name":"Grep","input":{"pattern":"formats.*say|say.*message|ChatType.SAY","path":"/home/openclaw/code/tuicraft/src/ui/tui.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":153,"cache_read_input_tokens":96406,"output_tokens":139,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":153,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMh4AQaMV2Rds1Ci9fb","type":"assistant","uuid":"f2771acc-c2b8-4e1f-87c2-37fa2f632a8b","timestamp":"2026-02-28T23:45:46.859Z"}
{"parentUuid":"f2771acc-c2b8-4e1f-87c2-37fa2f632a8b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KrEUp5YJTReHqdkGEzv1Dw","type":"tool_result","content":"34-  test(\"bare text becomes chat\", () => {\n35-    expect(parseCommand(\"hello\")).toEqual({ type: \"chat\", message: \"hello\" });\n36-  });\n37-\n38-  test(\"/s sends say\", () => {\n39:    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42-  test(\"/say sends say\", () => {\n43-    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n--\n335-    };\n336-    expect(formatMessage(msg)).toBe(\"[General] Al: hey\");\n337-  });\n338-\n339-  test(\"generic say\", () => {\n340:    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n341-    expect(formatMessage(msg)).toBe(\"[say] Alice: hi\");\n342-  });\n343-\n344-  test(\"unknown type\", () => {\n345-    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n346-    expect(formatMessage(msg)).toBe(\"[type 99] Bob: wat\");\n347-  });\n348-\n349-  test(\"strips color codes from message\", () => {\n350-    const msg = {\n351:      type: ChatType.SAY,\n352-      sender: \"Alice\",\n353-      message: \"|cff1eff00|Hitem:1234|h[Cool Sword]|h|r equipped\",\n354-    };\n355-    expect(formatMessage(msg)).toBe(\"[say] Alice: [Cool Sword] equipped\");\n356-  });\n357-});\n358-\n359-describe(\"formatMessageJson\", () => {\n360-  test(\"json say\", () => {\n361:    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n362-    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n363-      type: \"SAY\",\n364-      sender: \"Alice\",\n365-      message: \"hi\",\n366-    });\n--\n608-    const done = startTui(handle, false, {\n609-      input,\n610-      write: (s) => void output.push(s),\n611-    });\n612-    handle.triggerMessage({\n613:      type: ChatType.SAY,\n614-      sender: \"Alice\",\n615-      message: \"hi\",\n616-    });\n617-\n618-    expect(output.join(\"\")).toContain(\"[say] Alice: hi\");\n--\n688-      .mockImplementation(() => true);\n689-\n690-    try {\n691-      const done = startTui(handle, false, { input });\n692-      handle.triggerMessage({\n693:        type: ChatType.SAY,\n694-        sender: \"Al\",\n695-        message: \"hi\",\n696-      });\n697-\n698-      expect(spy).toHaveBeenCalled();\n--\n751-      const done = startTui(handle, true, {\n752-        input,\n753-        write: (s) => void output.push(s),\n754-      });\n755-      handle.triggerMessage({\n756:        type: ChatType.SAY,\n757-        sender: \"Alice\",\n758-        message: \"hi\",\n759-      });\n760-\n761-      expect(output.join(\"\")).toContain(\"\\r\\x1b[K[say] Alice: hi\\n\");"}]},"uuid":"91e9cc77-072f-4697-b33f-443238294226","timestamp":"2026-02-28T23:45:46.938Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"34-  test(\"bare text becomes chat\", () => {\n35-    expect(parseCommand(\"hello\")).toEqual({ type: \"chat\", message: \"hello\" });\n36-  });\n37-\n38-  test(\"/s sends say\", () => {\n39:    expect(parseCommand(\"/s hello\")).toEqual({ type: \"say\", message: \"hello\" });\n40-  });\n41-\n42-  test(\"/say sends say\", () => {\n43-    expect(parseCommand(\"/say hello there\")).toEqual({\n44-      type: \"say\",\n--\n335-    };\n336-    expect(formatMessage(msg)).toBe(\"[General] Al: hey\");\n337-  });\n338-\n339-  test(\"generic say\", () => {\n340:    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n341-    expect(formatMessage(msg)).toBe(\"[say] Alice: hi\");\n342-  });\n343-\n344-  test(\"unknown type\", () => {\n345-    const msg = { type: 99, sender: \"Bob\", message: \"wat\" };\n346-    expect(formatMessage(msg)).toBe(\"[type 99] Bob: wat\");\n347-  });\n348-\n349-  test(\"strips color codes from message\", () => {\n350-    const msg = {\n351:      type: ChatType.SAY,\n352-      sender: \"Alice\",\n353-      message: \"|cff1eff00|Hitem:1234|h[Cool Sword]|h|r equipped\",\n354-    };\n355-    expect(formatMessage(msg)).toBe(\"[say] Alice: [Cool Sword] equipped\");\n356-  });\n357-});\n358-\n359-describe(\"formatMessageJson\", () => {\n360-  test(\"json say\", () => {\n361:    const msg = { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" };\n362-    expect(JSON.parse(formatMessageJson(msg))).toEqual({\n363-      type: \"SAY\",\n364-      sender: \"Alice\",\n365-      message: \"hi\",\n366-    });\n--\n608-    const done = startTui(handle, false, {\n609-      input,\n610-      write: (s) => void output.push(s),\n611-    });\n612-    handle.triggerMessage({\n613:      type: ChatType.SAY,\n614-      sender: \"Alice\",\n615-      message: \"hi\",\n616-    });\n617-\n618-    expect(output.join(\"\")).toContain(\"[say] Alice: hi\");\n--\n688-      .mockImplementation(() => true);\n689-\n690-    try {\n691-      const done = startTui(handle, false, { input });\n692-      handle.triggerMessage({\n693:        type: ChatType.SAY,\n694-        sender: \"Al\",\n695-        message: \"hi\",\n696-      });\n697-\n698-      expect(spy).toHaveBeenCalled();\n--\n751-      const done = startTui(handle, true, {\n752-        input,\n753-        write: (s) => void output.push(s),\n754-      });\n755-      handle.triggerMessage({\n756:        type: ChatType.SAY,\n757-        sender: \"Alice\",\n758-        message: \"hi\",\n759-      });\n760-\n761-      expect(output.join(\"\")).toContain(\"\\r\\x1b[K[say] Alice: hi\\n\");","numLines":80},"sourceToolAssistantUUID":"f2771acc-c2b8-4e1f-87c2-37fa2f632a8b"}
{"parentUuid":"91e9cc77-072f-4697-b33f-443238294226","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01EpxC1pXVpATCtBt32KoffB","type":"message","role":"assistant","content":[{"type":"text","text":"Good — `formatMessage` is already covered for emote via the generic path at line 180 (`[${label}] ${sender}: ${message}`). There's a `generic say` test, and emote would fall through the same path. The format labels are already set. No need for a separate test there since the generic path covers it.\n\nNow let me also check the IPC integration test section to see if I should add an emote test there."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1019,"cache_read_input_tokens":96559,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1019},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMhJNvSCyiHMt5SnJUG","type":"assistant","uuid":"9194e607-6776-4c6d-b15d-fd637359d0ee","timestamp":"2026-02-28T23:45:52.149Z"}
{"parentUuid":"9194e607-6776-4c6d-b15d-fd637359d0ee","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01EpxC1pXVpATCtBt32KoffB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KQEdcszcZYfGJZWVrYpwce","name":"Grep","input":{"pattern":"SAY returns OK|WHISPER returns|GUILD returns","path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","output_mode":"content","-C":8},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1019,"cache_read_input_tokens":96559,"output_tokens":237,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1019,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMhJNvSCyiHMt5SnJUG","type":"assistant","uuid":"c153fd85-1c1a-4eba-a480-52b5e50ba3bd","timestamp":"2026-02-28T23:45:53.457Z"}
{"parentUuid":"c153fd85-1c1a-4eba-a480-52b5e50ba3bd","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KQEdcszcZYfGJZWVrYpwce","type":"tool_result","content":"1681-  });\n1682-\n1683-  test(\"STATUS returns CONNECTED\", async () => {\n1684-    startTestServer();\n1685-    const lines = await sendToSocket(\"STATUS\", sockPath);\n1686-    expect(lines).toEqual([\"CONNECTED\"]);\n1687-  });\n1688-\n1689:  test(\"SAY returns OK and calls handle\", async () => {\n1690-    startTestServer();\n1691-    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n1692-    expect(lines).toEqual([\"OK\"]);\n1693-    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n1694-  });\n1695-\n1696:  test(\"WHISPER returns OK\", async () => {\n1697-    startTestServer();\n1698-    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n1699-    expect(lines).toEqual([\"OK\"]);\n1700-    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n1701-  });\n1702-\n1703-  test(\"READ returns buffered events\", async () => {\n1704-    startTestServer();"}]},"uuid":"27c68d45-dce8-423e-8c2a-914b82c9bd4a","timestamp":"2026-02-28T23:45:53.535Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1681-  });\n1682-\n1683-  test(\"STATUS returns CONNECTED\", async () => {\n1684-    startTestServer();\n1685-    const lines = await sendToSocket(\"STATUS\", sockPath);\n1686-    expect(lines).toEqual([\"CONNECTED\"]);\n1687-  });\n1688-\n1689:  test(\"SAY returns OK and calls handle\", async () => {\n1690-    startTestServer();\n1691-    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n1692-    expect(lines).toEqual([\"OK\"]);\n1693-    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n1694-  });\n1695-\n1696:  test(\"WHISPER returns OK\", async () => {\n1697-    startTestServer();\n1698-    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n1699-    expect(lines).toEqual([\"OK\"]);\n1700-    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n1701-  });\n1702-\n1703-  test(\"READ returns buffered events\", async () => {\n1704-    startTestServer();","numLines":24},"sourceToolAssistantUUID":"c153fd85-1c1a-4eba-a480-52b5e50ba3bd"}
{"parentUuid":"27c68d45-dce8-423e-8c2a-914b82c9bd4a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FxC9spEGQU4vjo4f6MUpBW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016SdWXp1NJHMU9KWYWP8H7A","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","old_string":"  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {","new_string":"  test(\"EMOTE returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":560,"cache_read_input_tokens":97578,"output_tokens":402,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":560,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMhnZ5ECgbyQoCLzrAh","type":"assistant","uuid":"029795f6-9fd5-43cf-aebc-0caadcc08ce5","timestamp":"2026-02-28T23:46:01.234Z"}
{"parentUuid":"029795f6-9fd5-43cf-aebc-0caadcc08ce5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016SdWXp1NJHMU9KWYWP8H7A","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.test.ts has been updated successfully."}]},"uuid":"363355da-2fe7-43aa-aab3-e43153c73be3","timestamp":"2026-02-28T23:46:01.256Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","oldString":"  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {","newString":"  test(\"EMOTE returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {","originalFile":"import { test, expect, describe, jest, afterEach } from \"bun:test\";\nimport { unlink } from \"node:fs/promises\";\nimport {\n  parseIpcCommand,\n  dispatchCommand,\n  onChatMessage,\n  onGroupEvent,\n  onEntityEvent,\n  onFriendEvent,\n  writeLines,\n  type EventEntry,\n} from \"daemon/commands\";\nimport { startDaemonServer } from \"daemon/server\";\nimport { sendToSocket } from \"cli/ipc\";\nimport { RingBuffer } from \"lib/ring-buffer\";\nimport { ChatType } from \"wow/protocol/opcodes\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  UnitEntity,\n  GameObjectEntity,\n  BaseEntity,\n} from \"wow/entity-store\";\nimport { SessionLog } from \"lib/session-log\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction createMockSocket(): {\n  write: ReturnType<typeof jest.fn>;\n  end: ReturnType<typeof jest.fn>;\n  written(): string;\n} {\n  const chunks: string[] = [];\n  return {\n    write: jest.fn((data: string | Uint8Array) => {\n      chunks.push(\n        typeof data === \"string\" ? data : Buffer.from(data).toString(),\n      );\n      return (typeof data === \"string\" ? data : Buffer.from(data).toString())\n        .length;\n    }),\n    end: jest.fn(),\n    written() {\n      return chunks.join(\"\");\n    },\n  };\n}\n\ndescribe(\"parseIpcCommand\", () => {\n  test(\"SAY\", () => {\n    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n      type: \"say\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });\n\n  test(\"READ_WAIT\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 3000\")).toEqual({\n      type: \"read_wait\",\n      ms: 3000,\n    });\n  });\n\n  test(\"STOP\", () => {\n    expect(parseIpcCommand(\"STOP\")).toEqual({ type: \"stop\" });\n  });\n\n  test(\"STATUS\", () => {\n    expect(parseIpcCommand(\"STATUS\")).toEqual({ type: \"status\" });\n  });\n\n  test(\"WHO without filter\", () => {\n    expect(parseIpcCommand(\"WHO\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"WHO with filter\", () => {\n    expect(parseIpcCommand(\"WHO mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"READ_JSON\", () => {\n    expect(parseIpcCommand(\"READ_JSON\")).toEqual({ type: \"read_json\" });\n  });\n\n  test(\"READ_WAIT_JSON\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 2000\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 2000,\n    });\n  });\n\n  test(\"WHO_JSON without filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON\")).toEqual({ type: \"who_json\" });\n  });\n\n  test(\"WHO_JSON with filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON mage\")).toEqual({\n      type: \"who_json\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"INVITE\", () => {\n    expect(parseIpcCommand(\"INVITE Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"KICK\", () => {\n    expect(parseIpcCommand(\"KICK Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"LEAVE\", () => {\n    expect(parseIpcCommand(\"LEAVE\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"LEADER\", () => {\n    expect(parseIpcCommand(\"LEADER Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"ACCEPT\", () => {\n    expect(parseIpcCommand(\"ACCEPT\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"DECLINE\", () => {\n    expect(parseIpcCommand(\"DECLINE\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"NEARBY\", () => {\n    expect(parseIpcCommand(\"NEARBY\")).toEqual({ type: \"nearby\" });\n  });\n\n  test(\"NEARBY_JSON\", () => {\n    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n  });\n\n  test(\"slash /accept maps to accept\", () => {\n    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"slash /say maps to say\", () => {\n    expect(parseIpcCommand(\"/say hello\")).toEqual({\n      type: \"say\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"slash /whisper maps to whisper\", () => {\n    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"slash /emote maps to emote\", () => {\n    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n      type: \"emote\",\n      message: \"waves\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {\n    expect(parseIpcCommand(\"/who mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"slash /who maps to who without filter\", () => {\n    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"slash /invite maps to invite\", () => {\n    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /kick maps to kick\", () => {\n    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /leave maps to leave\", () => {\n    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"slash /friends maps to friends\", () => {\n    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"slash /ignore maps to unimplemented\", () => {\n    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n      type: \"unimplemented\",\n      feature: \"Ignore list\",\n    });\n  });\n\n  test(\"unknown slash command maps to say with full input\", () => {\n    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"slash command unsupported by daemon falls back to say\", () => {\n    expect(parseIpcCommand(\"/r hello\")).toEqual({\n      type: \"say\",\n      message: \"/r hello\",\n    });\n  });\n\n  test(\"INVITE with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"INVITE\")).toBeUndefined();\n  });\n\n  test(\"KICK with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"KICK\")).toBeUndefined();\n  });\n\n  test(\"LEADER with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"LEADER\")).toBeUndefined();\n  });\n\n  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n\n  test(\"unrecognized verb becomes chat\", () => {\n    expect(parseIpcCommand(\"DANCE\")).toEqual({\n      type: \"chat\",\n      message: \"DANCE\",\n    });\n  });\n\n  test(\"unrecognized text becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello world\")).toEqual({\n      type: \"chat\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"single word becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello\")).toEqual({\n      type: \"chat\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"empty string returns undefined\", () => {\n    expect(parseIpcCommand(\"\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with non-numeric argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT abc\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with negative value returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT -100\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 120000\")).toEqual({\n      type: \"read_wait\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"READ_WAIT_JSON with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT_JSON clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 999999\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"FRIENDS\", () => {\n    expect(parseIpcCommand(\"FRIENDS\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"FRIENDS_JSON\", () => {\n    expect(parseIpcCommand(\"FRIENDS_JSON\")).toEqual({ type: \"friends_json\" });\n  });\n\n  test(\"ADD_FRIEND\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"ADD_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"DEL_FRIEND\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"DEL_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"slash /friend add maps to add_friend\", () => {\n    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"slash /friend remove maps to del_friend\", () => {\n    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n});\n\ndescribe(\"dispatchCommand\", () => {\n  test(\"say calls sendSay and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"say\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"yell calls sendYell and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"yell\", message: \"HEY\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"party\", message: \"pull\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"emote calls sendEmote and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"emote\", message: \"waves hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"[say] Alice: hi\\n[say] Bob: hey\\n\\n\");\n  });\n\n  test(\"read on empty buffer writes just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"read_wait delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n      expect(events.drain()).toEqual([\n        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n      ]);\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"status writes CONNECTED\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"status\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n  });\n\n  test(\"stop calls cleanup and returns true\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"stop\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(true);\n    expect(cleanup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who passes filter and formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    expect(socket.written()).toContain(\"[who] 1 results: Test (80)\");\n  });\n\n  test(\"who without filter passes empty object\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"who\" }, handle, events, socket, cleanup);\n\n    expect(handle.who).toHaveBeenCalledWith({});\n  });\n\n  test(\"read_json drains ring buffer json\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({\n      text: \"[say] Alice: hi\",\n      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n    });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"read_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\n      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n    );\n  });\n\n  test(\"read_wait_json delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait_json returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"old\":true}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"new\":true}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"new\":true}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"invite calls handle.invite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"invite\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"kick calls handle.uninvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"kick\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leave calls handle.leaveGroup and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"leave\" }, handle, events, socket, cleanup);\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leader calls handle.setLeader and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"leader\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"accept calls handle.acceptInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"accept\" }, handle, events, socket, cleanup);\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"decline calls handle.declineInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"decline\" }, handle, events, socket, cleanup);\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who_json returns JSON formatted results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who_json\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"WHO\");\n    expect(parsed.count).toBe(1);\n    expect(parsed.results[0].name).toBe(\"Test\");\n  });\n\n  test(\"nearby returns formatted entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.5, y: 4.6, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 19,\n      bytes1: 0,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n      testGo,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Thrall (NPC, level 80) HP 5000/5000 at 1.23, 4.56, 7.89\",\n    );\n    expect(output).toContain(\"Mailbox (GameObject) at 1.50, 4.60, 7.89\");\n  });\n\n  test(\"nearby_json returns JSONL entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.guid).toBe(\"0x1\");\n    expect(parsed.type).toBe(\"unit\");\n    expect(parsed.name).toBe(\"Thrall\");\n    expect(parsed.level).toBe(80);\n    expect(parsed.health).toBe(5000);\n    expect(parsed.maxHealth).toBe(5000);\n    expect(parsed.x).toBe(1.23);\n    expect(parsed.y).toBe(4.56);\n    expect(parsed.z).toBe(7.89);\n  });\n\n  test(\"nearby with no entities returns just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"nearby formats player entity\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 10n,\n      objectType: ObjectType.PLAYER,\n      name: \"Arthas\",\n      level: 55,\n      health: 3000,\n      maxHealth: 4000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 0, x: 10.0, y: 20.0, z: 30.0, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Arthas (Player, level 55) HP 3000/4000 at 10.00, 20.00, 30.00\",\n    );\n  });\n\n  test(\"nearby formats unknown entity type\", async () => {\n    const handle = createMockHandle();\n    const testCorpse: BaseEntity = {\n      guid: 0xabn,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\"Entity 0xab (type 7)\");\n  });\n\n  test(\"nearby_json formats player and gameobject types\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.PLAYER,\n      name: \"Jaina\",\n      level: 70,\n      health: 8000,\n      maxHealth: 8000,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Chest\",\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 3,\n      bytes1: 0,\n    };\n    const testCorpse: BaseEntity = {\n      guid: 3n,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n      testGo,\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    expect(lines).toHaveLength(3);\n    const player = JSON.parse(lines[0]!);\n    const go = JSON.parse(lines[1]!);\n    const corpse = JSON.parse(lines[2]!);\n    expect(player.type).toBe(\"player\");\n    expect(player.level).toBe(70);\n    expect(player.health).toBe(8000);\n    expect(go.type).toBe(\"gameobject\");\n    expect(go.gameObjectType).toBe(3);\n    expect(corpse.type).toBe(\"object\");\n  });\n\n  test(\"friends calls getFriends and writes friend list\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"friends\" }, handle, events, socket, cleanup);\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(socket.written()).toContain(\"No friends on your list\");\n  });\n\n  test(\"friends_json calls getFriends and writes JSON\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"friends_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"FRIENDS\");\n    expect(parsed.count).toBe(0);\n  });\n\n  test(\"add_friend calls handle.addFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"add_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"del_friend calls handle.removeFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"del_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"unimplemented writes UNIMPLEMENTED response\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"unimplemented\", feature: \"Friends list\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(socket.written()).toBe(\"UNIMPLEMENTED Friends list\\n\\n\");\n  });\n\n  test(\"chat sends via sendInCurrentMode and responds with mode\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"say\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"chat\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n  });\n\n  test(\"chat mode label includes whisper target\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"whisper\",\n      target: \"Xiara\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"follow me\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK WHISPER Xiara\\n\\n\");\n  });\n\n  test(\"chat mode label includes channel name\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"channel\",\n      channel: \"General\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"hello general\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK CHANNEL General\\n\\n\");\n  });\n});\n\ndescribe(\"writeLines\", () => {\n  test(\"writes each line with newline then blank terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, [\"line1\", \"line2\"]);\n    expect(socket.written()).toBe(\"line1\\nline2\\n\\n\");\n  });\n\n  test(\"empty array writes just terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, []);\n    expect(socket.written()).toBe(\"\\n\");\n  });\n});\n\ndescribe(\"onChatMessage\", () => {\n  test(\"pushes formatted message to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"appends JSON to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"swallows session log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onGroupEvent\", () => {\n  test(\"pushes group_list with undefined text to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"group_list\",\n        members: [{ name: \"Alice\", guidLow: 1, guidHigh: 0, online: true }],\n        leader: \"Alice\",\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toBeUndefined();\n    expect(JSON.parse(drained[0]!.json)).toMatchObject({ type: \"GROUP_LIST\" });\n  });\n\n  test(\"pushes member_stats to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent(\n      { type: \"member_stats\", guidLow: 42, hp: 100, maxHp: 200 },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith(\n      expect.objectContaining({ type: \"PARTY_MEMBER_STATS\", guidLow: 42 }),\n    );\n  });\n\n  test(\"swallows group event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n\n  test(\"pushes displayable events with text\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"invite_received\", from: \"Bob\" }, events, log);\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[group] Bob invites you to a group\");\n  });\n\n  test(\"serializes command_result event details\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"command_result\",\n        operation: 1,\n        target: \"Voidtrix\",\n        result: 0,\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"GROUP_COMMAND_RESULT\",\n      operation: 1,\n      target: \"Voidtrix\",\n      result: 0,\n    });\n  });\n\n  test(\"serializes leader/group lifecycle events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"leader_changed\", name: \"Alice\" }, events, log);\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    onGroupEvent({ type: \"kicked\" }, events, log);\n    onGroupEvent({ type: \"invite_declined\", name: \"Bob\" }, events, log);\n\n    const drained = events.drain().map((entry) => JSON.parse(entry.json));\n    expect(drained).toEqual([\n      { type: \"GROUP_LEADER_CHANGED\", name: \"Alice\" },\n      { type: \"GROUP_DESTROYED\" },\n      { type: \"GROUP_KICKED\" },\n      { type: \"GROUP_INVITE_DECLINED\", name: \"Bob\" },\n    ]);\n  });\n});\n\ndescribe(\"onEntityEvent\", () => {\n  test(\"pushes appear event to ring buffer with text and json\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"appear\", entity }, events, log);\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Test NPC\");\n    expect(drained[0]!.text).toContain(\"appeared\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_APPEAR\");\n    expect(json.name).toBe(\"Test NPC\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes disappear event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Gone NPC\");\n    expect(drained[0]!.text).toContain(\"left range\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_DISAPPEAR\");\n  });\n\n  test(\"skips update events with no obj\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"update\", entity, changed: [\"health\"] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"swallows entity event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onFriendEvent\", () => {\n  test(\"pushes friend-online event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      {\n        type: \"friend-online\",\n        friend: {\n          guid: 1n,\n          name: \"Arthas\",\n          note: \"\",\n          status: FriendStatus.ONLINE,\n          area: 0,\n          level: 80,\n          playerClass: 6,\n        },\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"online\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ONLINE\");\n    expect(json.name).toBe(\"Arthas\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes friend-offline event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Arthas\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"offline\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_OFFLINE\");\n  });\n\n  test(\"skips friend-list events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent({ type: \"friend-list\", friends: [] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"pushes friend-error event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-error\", result: 0x04, name: \"Nobody\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"player not found\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ERROR\");\n    expect(json.result).toBe(0x04);\n  });\n\n  test(\"swallows friend event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Gone\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"IPC round-trip\", () => {\n  let sockCounter = 0;\n  let sockPath: string;\n  let handle: ReturnType<typeof createMockHandle>;\n  let result: ReturnType<typeof startDaemonServer>;\n  let exitSpy: ReturnType<typeof jest.fn>;\n\n  function startTestServer(opts?: { onActivity?: () => void }) {\n    sockPath = `./tmp/test-daemon-${++sockCounter}-${Date.now()}.sock`;\n    handle = createMockHandle();\n    const log = new SessionLog(`./tmp/test-daemon-${sockCounter}.jsonl`);\n    exitSpy = jest\n      .spyOn(process, \"exit\")\n      .mockImplementation(() => undefined as never);\n    result = startDaemonServer({ handle, sock: sockPath, log, ...opts });\n  }\n\n  afterEach(async () => {\n    exitSpy?.mockRestore();\n    result?.cleanup();\n  });\n\n  test(\"STATUS returns CONNECTED\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STATUS\", sockPath);\n    expect(lines).toEqual([\"CONNECTED\"]);\n  });\n\n  test(\"SAY returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {\n    startTestServer();\n    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n  });\n\n  test(\"bare text sends via sticky mode\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"hello world\", sockPath);\n    expect(lines[0]).toMatch(/^OK /);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"empty command returns ERR\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"\", sockPath);\n    expect(lines).toEqual([\"ERR unknown command\"]);\n  });\n\n  test(\"sendToSocket rejects on missing socket\", async () => {\n    await expect(\n      sendToSocket(\"STATUS\", \"./tmp/nonexistent.sock\"),\n    ).rejects.toThrow();\n  });\n\n  test(\"onActivity fires on each IPC command\", async () => {\n    const activity = jest.fn();\n    startTestServer({ onActivity: activity });\n    await sendToSocket(\"STATUS\", sockPath);\n    await sendToSocket(\"STATUS\", sockPath);\n    expect(activity).toHaveBeenCalledTimes(2);\n  });\n\n  test(\"cleanup closes handle and stops server\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalled();\n    await expect(sendToSocket(\"STATUS\", sockPath)).rejects.toThrow();\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    startTestServer();\n    result.cleanup();\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"cleanup ignores missing socket file\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    await unlink(sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP triggers process.exit\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STOP\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    await Bun.sleep(0);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"buffers split command chunks before parsing\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-split-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-split-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STA\"));\n      capturedData!(socket, Buffer.from(\"TUS\\n\"));\n      await Promise.resolve();\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"processes multiple commands from a single chunk\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-multi-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-multi-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STATUS\\nSTATUS\\n\"));\n      await Bun.sleep(0);\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\nCONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"onMessage wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\"]);\n  });\n\n  test(\"onGroupEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerGroupEvent({ type: \"group_destroyed\" });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[group] Group has been disbanded\"]);\n  });\n\n  test(\"onFriendEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        level: 80,\n        playerClass: 1,\n        area: 0,\n        status: 0,\n        note: \"\",\n      },\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Arthas\");\n  });\n\n  test(\"onEntityEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Test NPC\");\n  });\n\n  test(\"onEntityEvent wiring round-trip via READ_JSON\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ_JSON\", sockPath);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.type).toBe(\"ENTITY_APPEAR\");\n    expect(parsed.name).toBe(\"Test NPC\");\n  });\n\n  test(\"NEARBY round-trip returns formatted entities\", async () => {\n    startTestServer();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const lines = await sendToSocket(\"NEARBY\", sockPath);\n    expect(lines[0]).toContain(\"Thrall\");\n    expect(lines[0]).toContain(\"level 80\");\n  });\n\n  test(\"dispatch error returns ERR internal\", async () => {\n    startTestServer();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"db fail\"),\n    );\n    const lines = await sendToSocket(\"WHO\", sockPath);\n    expect(lines).toEqual([\"ERR internal\"]);\n  });\n});\n","structuredPatch":[{"oldStart":1693,"oldLines":6,"newStart":1693,"newLines":13,"lines":["     expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");","   });"," ","+  test(\"EMOTE returns OK and calls handle\", async () => {","+    startTestServer();","+    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);","+    expect(lines).toEqual([\"OK\"]);","+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");","+  });","+","   test(\"WHISPER returns OK\", async () => {","     startTestServer();","     const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"029795f6-9fd5-43cf-aebc-0caadcc08ce5"}
{"parentUuid":"363355da-2fe7-43aa-aab3-e43153c73be3","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Utba8jWHztHx3vgMBLKZFV","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check if `onChatMessage` for emote needs a test in the commands.test.ts."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":441,"cache_read_input_tokens":98138,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":441},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMiNfRNSSnSevCXQwwU","type":"assistant","uuid":"0de75f5a-826c-44e4-9800-b931efc6d0cb","timestamp":"2026-02-28T23:46:05.127Z"}
{"parentUuid":"0de75f5a-826c-44e4-9800-b931efc6d0cb","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Utba8jWHztHx3vgMBLKZFV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JdhjTuhXYkLDvuYbc3rekA","name":"Grep","input":{"pattern":"onChatMessage.*SAY|onChatMessage.*emote|onChatMessage.*test","path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":441,"cache_read_input_tokens":98138,"output_tokens":174,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":441,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMiNfRNSSnSevCXQwwU","type":"assistant","uuid":"dc37a232-6394-4c83-8e72-39b694113033","timestamp":"2026-02-28T23:46:06.189Z"}
{"parentUuid":"dc37a232-6394-4c83-8e72-39b694113033","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JdhjTuhXYkLDvuYbc3rekA","type":"tool_result","content":"No matches found"}]},"uuid":"8bc6cba2-bcf3-49f1-991b-53e195783ae7","timestamp":"2026-02-28T23:46:06.275Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"dc37a232-6394-4c83-8e72-39b694113033"}
{"parentUuid":"8bc6cba2-bcf3-49f1-991b-53e195783ae7","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Xvbtkd7LpR7h6xJMjdrk11","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AkJGMFpzaEivcEbCpfnZRK","name":"Grep","input":{"pattern":"onChatMessage","path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","output_mode":"content","-C":5},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":414,"cache_read_input_tokens":98579,"output_tokens":129,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":414,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMij2XXp4seECACMPdn","type":"assistant","uuid":"7efa6641-7ea8-4dc4-8ffc-072819cae911","timestamp":"2026-02-28T23:46:09.628Z"}
{"parentUuid":"7efa6641-7ea8-4dc4-8ffc-072819cae911","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AkJGMFpzaEivcEbCpfnZRK","type":"tool_result","content":"1-import { test, expect, describe, jest, afterEach } from \"bun:test\";\n2-import { unlink } from \"node:fs/promises\";\n3-import {\n4-  parseIpcCommand,\n5-  dispatchCommand,\n6:  onChatMessage,\n7-  onGroupEvent,\n8-  onEntityEvent,\n9-  onFriendEvent,\n10-  writeLines,\n11-  type EventEntry,\n--\n1286-    writeLines(socket, []);\n1287-    expect(socket.written()).toBe(\"\\n\");\n1288-  });\n1289-});\n1290-\n1291:describe(\"onChatMessage\", () => {\n1292-  test(\"pushes formatted message to ring buffer\", () => {\n1293-    const events = new RingBuffer<EventEntry>(10);\n1294-    const log: SessionLog = {\n1295-      append: jest.fn(() => Promise.resolve()),\n1296-    } as unknown as SessionLog;\n1297-\n1298:    onChatMessage(\n1299-      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n1300-      events,\n1301-      log,\n1302-    );\n1303-\n--\n1313-  test(\"appends JSON to session log\", () => {\n1314-    const events = new RingBuffer<EventEntry>(10);\n1315-    const append = jest.fn(() => Promise.resolve());\n1316-    const log: SessionLog = { append } as unknown as SessionLog;\n1317-\n1318:    onChatMessage(\n1319-      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n1320-      events,\n1321-      log,\n1322-    );\n1323-\n--\n1331-  test(\"swallows session log append errors\", async () => {\n1332-    const events = new RingBuffer<EventEntry>(10);\n1333-    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n1334-    const log: SessionLog = { append } as unknown as SessionLog;\n1335-\n1336:    onChatMessage(\n1337-      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n1338-      events,\n1339-      log,\n1340-    );\n1341-    await Promise.resolve();"}]},"uuid":"bbd0426b-ffdd-41d0-a305-bc42ae0aec78","timestamp":"2026-02-28T23:46:09.708Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1-import { test, expect, describe, jest, afterEach } from \"bun:test\";\n2-import { unlink } from \"node:fs/promises\";\n3-import {\n4-  parseIpcCommand,\n5-  dispatchCommand,\n6:  onChatMessage,\n7-  onGroupEvent,\n8-  onEntityEvent,\n9-  onFriendEvent,\n10-  writeLines,\n11-  type EventEntry,\n--\n1286-    writeLines(socket, []);\n1287-    expect(socket.written()).toBe(\"\\n\");\n1288-  });\n1289-});\n1290-\n1291:describe(\"onChatMessage\", () => {\n1292-  test(\"pushes formatted message to ring buffer\", () => {\n1293-    const events = new RingBuffer<EventEntry>(10);\n1294-    const log: SessionLog = {\n1295-      append: jest.fn(() => Promise.resolve()),\n1296-    } as unknown as SessionLog;\n1297-\n1298:    onChatMessage(\n1299-      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n1300-      events,\n1301-      log,\n1302-    );\n1303-\n--\n1313-  test(\"appends JSON to session log\", () => {\n1314-    const events = new RingBuffer<EventEntry>(10);\n1315-    const append = jest.fn(() => Promise.resolve());\n1316-    const log: SessionLog = { append } as unknown as SessionLog;\n1317-\n1318:    onChatMessage(\n1319-      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n1320-      events,\n1321-      log,\n1322-    );\n1323-\n--\n1331-  test(\"swallows session log append errors\", async () => {\n1332-    const events = new RingBuffer<EventEntry>(10);\n1333-    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n1334-    const log: SessionLog = { append } as unknown as SessionLog;\n1335-\n1336:    onChatMessage(\n1337-      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n1338-      events,\n1339-      log,\n1340-    );\n1341-    await Promise.resolve();","numLines":54},"sourceToolAssistantUUID":"7efa6641-7ea8-4dc4-8ffc-072819cae911"}
{"parentUuid":"bbd0426b-ffdd-41d0-a305-bc42ae0aec78","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01XBvNutbZF5fj9WzGqjSRa7","type":"message","role":"assistant","content":[{"type":"text","text":"The `onChatMessage` is already generic (works for any chat type), so no additional test needed there. Tests are complete. Now let me run the tests."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":743,"cache_read_input_tokens":98993,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":743},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMiyip14H3zgFzjT1M5","type":"assistant","uuid":"6e505297-e8d3-4f76-9782-a8997c841574","timestamp":"2026-02-28T23:46:14.130Z"}
{"parentUuid":"6e505297-e8d3-4f76-9782-a8997c841574","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01XBvNutbZF5fj9WzGqjSRa7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qqeb8Rso7CCgXXr6sERLpD","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"in_progress","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":743,"cache_read_input_tokens":98993,"output_tokens":347,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":743,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMiyip14H3zgFzjT1M5","type":"assistant","uuid":"92d13374-f298-42cb-9f1b-ffd74e951a50","timestamp":"2026-02-28T23:46:17.016Z"}
{"parentUuid":"92d13374-f298-42cb-9f1b-ffd74e951a50","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qqeb8Rso7CCgXXr6sERLpD","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"e56ffead-3c99-481c-80d7-906a25d7b7b4","timestamp":"2026-02-28T23:46:17.017Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"in_progress","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"pending","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"in_progress","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"92d13374-f298-42cb-9f1b-ffd74e951a50"}
{"parentUuid":"e56ffead-3c99-481c-80d7-906a25d7b7b4","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Vcw6ooqfPMoFi26KsMTRZZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YXipFDPUafMq4FYi7pdLpX","name":"Bash","input":{"command":"mise typecheck 2>&1","description":"Run TypeScript type checking","timeout":30000},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":389,"cache_read_input_tokens":99736,"output_tokens":110,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":389,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMjX8gpEGCiJfjRBjGM","type":"assistant","uuid":"54099bb2-3565-4784-8e9e-b24f7bab7cc9","timestamp":"2026-02-28T23:46:20.369Z"}
{"parentUuid":"54099bb2-3565-4784-8e9e-b24f7bab7cc9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YXipFDPUafMq4FYi7pdLpX","type":"tool_result","content":"[typecheck] $ bun run typecheck\n$ tsc --noEmit","is_error":false}]},"uuid":"1f402658-9e7e-4868-bf49-d1d48dbd8d79","timestamp":"2026-02-28T23:46:21.525Z","toolUseResult":{"stdout":"[typecheck] $ bun run typecheck\n$ tsc --noEmit","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"54099bb2-3565-4784-8e9e-b24f7bab7cc9"}
{"parentUuid":"1f402658-9e7e-4868-bf49-d1d48dbd8d79","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01EFQGxV4APYX5N3deLQb7mg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kmf5KxxGstUEic7NsLYdwS","name":"Bash","input":{"command":"mise test 2>&1","description":"Run all tests","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":126,"cache_read_input_tokens":100125,"output_tokens":94,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":126,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMjrEtRXyUPUPq2ZYqe","type":"assistant","uuid":"7300346e-f2de-4286-a6a6-9de886155249","timestamp":"2026-02-28T23:46:25.003Z"}
{"parentUuid":"7300346e-f2de-4286-a6a6-9de886155249","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\n[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\nsrc/daemon/commands.test.ts:\n297 |       [\"EMOTE waves\", \"Text emotes\"],\n298 |     ] as const;\n299 | \n300 |     for (const [input, feature] of cases) {\n301 |       test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n302 |         expect(parseIpcCommand(input)).toEqual({\n                                             ^\nerror: expect(received).toEqual(expected)\n\n  {\n-   \"feature\": \"Text emotes\",\n-   \"type\": \"unimplemented\",\n+   \"message\": \"waves\",\n+   \"type\": \"emote\",\n  }\n\n- Expected  - 2\n+ Received  + 2\n\n      at <anonymous> (/home/openclaw/code/tuicraft/src/daemon/commands.test.ts:302:40)\n(fail) parseIpcCommand > unimplemented IPC commands > EMOTE returns unimplemented\n\n 825 pass\n 1 fail\n 2150 expect() calls\nRan 826 tests across 33 files. [472.00ms]\n[test] ERROR task failed\n\n[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\nsrc/daemon/commands.test.ts:\n297 |       [\"EMOTE waves\", \"Text emotes\"],\n298 |     ] as const;\n299 | \n300 |     for (const [input, feature] of cases) {\n301 |       test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n302 |         expect(parseIpcCommand(input)).toEqual({\n                                             ^\nerror: expect(received).toEqual(expected)\n\n  {\n-   \"feature\": \"Text emotes\",\n-   \"type\": \"unimplemented\",\n+   \"message\": \"waves\",\n+   \"type\": \"emote\",\n  }\n\n- Expected  - 2\n+ Received  + 2\n\n      at <anonymous> (/home/openclaw/code/tuicraft/src/daemon/commands.test.ts:302:40)\n(fail) parseIpcCommand > unimplemented IPC commands > EMOTE returns unimplemented\n\n 825 pass\n 1 fail\n 2150 expect() calls\nRan 826 tests across 33 files. [472.00ms]\n[test] ERROR task failed","is_error":true,"tool_use_id":"toolu_01Kmf5KxxGstUEic7NsLYdwS"}]},"uuid":"36a17837-f868-485f-a0c8-20382ad96f38","timestamp":"2026-02-28T23:46:25.510Z","toolUseResult":"Error: Exit code 1\n[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\nsrc/daemon/commands.test.ts:\n297 |       [\"EMOTE waves\", \"Text emotes\"],\n298 |     ] as const;\n299 | \n300 |     for (const [input, feature] of cases) {\n301 |       test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n302 |         expect(parseIpcCommand(input)).toEqual({\n                                             ^\nerror: expect(received).toEqual(expected)\n\n  {\n-   \"feature\": \"Text emotes\",\n-   \"type\": \"unimplemented\",\n+   \"message\": \"waves\",\n+   \"type\": \"emote\",\n  }\n\n- Expected  - 2\n+ Received  + 2\n\n      at <anonymous> (/home/openclaw/code/tuicraft/src/daemon/commands.test.ts:302:40)\n(fail) parseIpcCommand > unimplemented IPC commands > EMOTE returns unimplemented\n\n 825 pass\n 1 fail\n 2150 expect() calls\nRan 826 tests across 33 files. [472.00ms]\n[test] ERROR task failed\n\n[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\nsrc/daemon/commands.test.ts:\n297 |       [\"EMOTE waves\", \"Text emotes\"],\n298 |     ] as const;\n299 | \n300 |     for (const [input, feature] of cases) {\n301 |       test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n302 |         expect(parseIpcCommand(input)).toEqual({\n                                             ^\nerror: expect(received).toEqual(expected)\n\n  {\n-   \"feature\": \"Text emotes\",\n-   \"type\": \"unimplemented\",\n+   \"message\": \"waves\",\n+   \"type\": \"emote\",\n  }\n\n- Expected  - 2\n+ Received  + 2\n\n      at <anonymous> (/home/openclaw/code/tuicraft/src/daemon/commands.test.ts:302:40)\n(fail) parseIpcCommand > unimplemented IPC commands > EMOTE returns unimplemented\n\n 825 pass\n 1 fail\n 2150 expect() calls\nRan 826 tests across 33 files. [472.00ms]\n[test] ERROR task failed","sourceToolAssistantUUID":"7300346e-f2de-4286-a6a6-9de886155249"}
{"parentUuid":"36a17837-f868-485f-a0c8-20382ad96f38","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01PmLk6wEWYQpYDpp1Ma2aTK","type":"message","role":"assistant","content":[{"type":"text","text":"There's still an old test for EMOTE in the unimplemented IPC commands list. Let me fix that."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":734,"cache_read_input_tokens":100251,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":734},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMk9GpVRLrCD1z5kpqB","type":"assistant","uuid":"4f1215ac-6449-47e8-a5ab-b68f9bc52951","timestamp":"2026-02-28T23:46:28.903Z"}
{"parentUuid":"4f1215ac-6449-47e8-a5ab-b68f9bc52951","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01PmLk6wEWYQpYDpp1Ma2aTK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Biz2k37BVx3yZ6Hkck8DMo","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","offset":285,"limit":25},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":734,"cache_read_input_tokens":100251,"output_tokens":134,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":734,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMk9GpVRLrCD1z5kpqB","type":"assistant","uuid":"1376db3a-dd42-4c23-8f36-17163f793164","timestamp":"2026-02-28T23:46:29.724Z"}
{"parentUuid":"1376db3a-dd42-4c23-8f36-17163f793164","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Biz2k37BVx3yZ6Hkck8DMo","type":"tool_result","content":"   285→  describe(\"unimplemented IPC commands\", () => {\n   286→    const cases = [\n   287→      [\"IGNORE Foo\", \"Ignore list\"],\n   288→      [\"JOIN Trade\", \"Channel join/leave\"],\n   289→      [\"GINVITE Foo\", \"Guild management\"],\n   290→      [\"GKICK Foo\", \"Guild management\"],\n   291→      [\"GLEAVE\", \"Guild management\"],\n   292→      [\"GPROMOTE Foo\", \"Guild management\"],\n   293→      [\"MAIL\", \"Mail\"],\n   294→      [\"ROLL\", \"Random roll\"],\n   295→      [\"DND\", \"Player status\"],\n   296→      [\"AFK\", \"Player status\"],\n   297→      [\"EMOTE waves\", \"Text emotes\"],\n   298→    ] as const;\n   299→\n   300→    for (const [input, feature] of cases) {\n   301→      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n   302→        expect(parseIpcCommand(input)).toEqual({\n   303→          type: \"unimplemented\",\n   304→          feature,\n   305→        });\n   306→      });\n   307→    }\n   308→  });\n   309→"}]},"uuid":"25da8a6f-c052-4d24-85e0-363c5223083a","timestamp":"2026-02-28T23:46:29.726Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","content":"  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n","numLines":25,"startLine":285,"totalLines":2000}},"sourceToolAssistantUUID":"1376db3a-dd42-4c23-8f36-17163f793164"}
{"parentUuid":"25da8a6f-c052-4d24-85e0-363c5223083a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01PicKzx74MfR5FEverXiTqY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017U3n7MFyjmatmVFDbdeNLN","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","old_string":"      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;","new_string":"      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n    ] as const;"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":455,"cache_read_input_tokens":100985,"output_tokens":189,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":455,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMkTPzBSoNCr7NLT16b","type":"assistant","uuid":"37c1efc6-0bc4-4c4c-864f-c7e3d30bcdd5","timestamp":"2026-02-28T23:46:33.844Z"}
{"parentUuid":"37c1efc6-0bc4-4c4c-864f-c7e3d30bcdd5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017U3n7MFyjmatmVFDbdeNLN","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/daemon/commands.test.ts has been updated successfully."}]},"uuid":"7be4abe0-1714-42bb-a11b-d36bfcc90a91","timestamp":"2026-02-28T23:46:33.863Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/daemon/commands.test.ts","oldString":"      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;","newString":"      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n    ] as const;","originalFile":"import { test, expect, describe, jest, afterEach } from \"bun:test\";\nimport { unlink } from \"node:fs/promises\";\nimport {\n  parseIpcCommand,\n  dispatchCommand,\n  onChatMessage,\n  onGroupEvent,\n  onEntityEvent,\n  onFriendEvent,\n  writeLines,\n  type EventEntry,\n} from \"daemon/commands\";\nimport { startDaemonServer } from \"daemon/server\";\nimport { sendToSocket } from \"cli/ipc\";\nimport { RingBuffer } from \"lib/ring-buffer\";\nimport { ChatType } from \"wow/protocol/opcodes\";\nimport { FriendStatus } from \"wow/protocol/social\";\nimport { ObjectType } from \"wow/protocol/entity-fields\";\nimport type {\n  UnitEntity,\n  GameObjectEntity,\n  BaseEntity,\n} from \"wow/entity-store\";\nimport { SessionLog } from \"lib/session-log\";\nimport { createMockHandle } from \"test/mock-handle\";\n\nfunction createMockSocket(): {\n  write: ReturnType<typeof jest.fn>;\n  end: ReturnType<typeof jest.fn>;\n  written(): string;\n} {\n  const chunks: string[] = [];\n  return {\n    write: jest.fn((data: string | Uint8Array) => {\n      chunks.push(\n        typeof data === \"string\" ? data : Buffer.from(data).toString(),\n      );\n      return (typeof data === \"string\" ? data : Buffer.from(data).toString())\n        .length;\n    }),\n    end: jest.fn(),\n    written() {\n      return chunks.join(\"\");\n    },\n  };\n}\n\ndescribe(\"parseIpcCommand\", () => {\n  test(\"SAY\", () => {\n    expect(parseIpcCommand(\"SAY hello world\")).toEqual({\n      type: \"say\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"YELL\", () => {\n    expect(parseIpcCommand(\"YELL hey everyone\")).toEqual({\n      type: \"yell\",\n      message: \"hey everyone\",\n    });\n  });\n\n  test(\"GUILD\", () => {\n    expect(parseIpcCommand(\"GUILD inv pls\")).toEqual({\n      type: \"guild\",\n      message: \"inv pls\",\n    });\n  });\n\n  test(\"PARTY\", () => {\n    expect(parseIpcCommand(\"PARTY pull now\")).toEqual({\n      type: \"party\",\n      message: \"pull now\",\n    });\n  });\n\n  test(\"EMOTE\", () => {\n    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n      type: \"emote\",\n      message: \"waves hello\",\n    });\n  });\n\n  test(\"WHISPER\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"follow me\",\n    });\n  });\n\n  test(\"WHISPER without message\", () => {\n    expect(parseIpcCommand(\"WHISPER Xiara\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"\",\n    });\n  });\n\n  test(\"READ\", () => {\n    expect(parseIpcCommand(\"READ\")).toEqual({ type: \"read\" });\n  });\n\n  test(\"READ_WAIT\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 3000\")).toEqual({\n      type: \"read_wait\",\n      ms: 3000,\n    });\n  });\n\n  test(\"STOP\", () => {\n    expect(parseIpcCommand(\"STOP\")).toEqual({ type: \"stop\" });\n  });\n\n  test(\"STATUS\", () => {\n    expect(parseIpcCommand(\"STATUS\")).toEqual({ type: \"status\" });\n  });\n\n  test(\"WHO without filter\", () => {\n    expect(parseIpcCommand(\"WHO\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"WHO with filter\", () => {\n    expect(parseIpcCommand(\"WHO mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"READ_JSON\", () => {\n    expect(parseIpcCommand(\"READ_JSON\")).toEqual({ type: \"read_json\" });\n  });\n\n  test(\"READ_WAIT_JSON\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 2000\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 2000,\n    });\n  });\n\n  test(\"WHO_JSON without filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON\")).toEqual({ type: \"who_json\" });\n  });\n\n  test(\"WHO_JSON with filter\", () => {\n    expect(parseIpcCommand(\"WHO_JSON mage\")).toEqual({\n      type: \"who_json\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"INVITE\", () => {\n    expect(parseIpcCommand(\"INVITE Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"KICK\", () => {\n    expect(parseIpcCommand(\"KICK Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"LEAVE\", () => {\n    expect(parseIpcCommand(\"LEAVE\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"LEADER\", () => {\n    expect(parseIpcCommand(\"LEADER Voidtrix\")).toEqual({\n      type: \"leader\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"ACCEPT\", () => {\n    expect(parseIpcCommand(\"ACCEPT\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"DECLINE\", () => {\n    expect(parseIpcCommand(\"DECLINE\")).toEqual({ type: \"decline\" });\n  });\n\n  test(\"NEARBY\", () => {\n    expect(parseIpcCommand(\"NEARBY\")).toEqual({ type: \"nearby\" });\n  });\n\n  test(\"NEARBY_JSON\", () => {\n    expect(parseIpcCommand(\"NEARBY_JSON\")).toEqual({ type: \"nearby_json\" });\n  });\n\n  test(\"slash /accept maps to accept\", () => {\n    expect(parseIpcCommand(\"/accept\")).toEqual({ type: \"accept\" });\n  });\n\n  test(\"slash /say maps to say\", () => {\n    expect(parseIpcCommand(\"/say hello\")).toEqual({\n      type: \"say\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"slash /whisper maps to whisper\", () => {\n    expect(parseIpcCommand(\"/whisper Xiara hi\")).toEqual({\n      type: \"whisper\",\n      target: \"Xiara\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"slash /emote maps to emote\", () => {\n    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n      type: \"emote\",\n      message: \"waves\",\n    });\n  });\n\n  test(\"slash /who maps to who with filter\", () => {\n    expect(parseIpcCommand(\"/who mage\")).toEqual({\n      type: \"who\",\n      filter: \"mage\",\n    });\n  });\n\n  test(\"slash /who maps to who without filter\", () => {\n    expect(parseIpcCommand(\"/who\")).toEqual({ type: \"who\" });\n  });\n\n  test(\"slash /invite maps to invite\", () => {\n    expect(parseIpcCommand(\"/invite Voidtrix\")).toEqual({\n      type: \"invite\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /kick maps to kick\", () => {\n    expect(parseIpcCommand(\"/kick Voidtrix\")).toEqual({\n      type: \"kick\",\n      target: \"Voidtrix\",\n    });\n  });\n\n  test(\"slash /leave maps to leave\", () => {\n    expect(parseIpcCommand(\"/leave\")).toEqual({ type: \"leave\" });\n  });\n\n  test(\"slash /friends maps to friends\", () => {\n    expect(parseIpcCommand(\"/friends\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"slash /ignore maps to unimplemented\", () => {\n    expect(parseIpcCommand(\"/ignore someone\")).toEqual({\n      type: \"unimplemented\",\n      feature: \"Ignore list\",\n    });\n  });\n\n  test(\"unknown slash command maps to say with full input\", () => {\n    expect(parseIpcCommand(\"/dance hello\")).toEqual({\n      type: \"say\",\n      message: \"/dance hello\",\n    });\n  });\n\n  test(\"slash command unsupported by daemon falls back to say\", () => {\n    expect(parseIpcCommand(\"/r hello\")).toEqual({\n      type: \"say\",\n      message: \"/r hello\",\n    });\n  });\n\n  test(\"INVITE with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"INVITE\")).toBeUndefined();\n  });\n\n  test(\"KICK with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"KICK\")).toBeUndefined();\n  });\n\n  test(\"LEADER with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"LEADER\")).toBeUndefined();\n  });\n\n  describe(\"unimplemented IPC commands\", () => {\n    const cases = [\n      [\"IGNORE Foo\", \"Ignore list\"],\n      [\"JOIN Trade\", \"Channel join/leave\"],\n      [\"GINVITE Foo\", \"Guild management\"],\n      [\"GKICK Foo\", \"Guild management\"],\n      [\"GLEAVE\", \"Guild management\"],\n      [\"GPROMOTE Foo\", \"Guild management\"],\n      [\"MAIL\", \"Mail\"],\n      [\"ROLL\", \"Random roll\"],\n      [\"DND\", \"Player status\"],\n      [\"AFK\", \"Player status\"],\n      [\"EMOTE waves\", \"Text emotes\"],\n    ] as const;\n\n    for (const [input, feature] of cases) {\n      test(`${input.split(\" \")[0]} returns unimplemented`, () => {\n        expect(parseIpcCommand(input)).toEqual({\n          type: \"unimplemented\",\n          feature,\n        });\n      });\n    }\n  });\n\n  test(\"unrecognized verb becomes chat\", () => {\n    expect(parseIpcCommand(\"DANCE\")).toEqual({\n      type: \"chat\",\n      message: \"DANCE\",\n    });\n  });\n\n  test(\"unrecognized text becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello world\")).toEqual({\n      type: \"chat\",\n      message: \"hello world\",\n    });\n  });\n\n  test(\"single word becomes chat command\", () => {\n    expect(parseIpcCommand(\"hello\")).toEqual({\n      type: \"chat\",\n      message: \"hello\",\n    });\n  });\n\n  test(\"empty string returns undefined\", () => {\n    expect(parseIpcCommand(\"\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with non-numeric argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT abc\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT with negative value returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT -100\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT 120000\")).toEqual({\n      type: \"read_wait\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"READ_WAIT_JSON with empty argument returns undefined\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON\")).toBeUndefined();\n  });\n\n  test(\"READ_WAIT_JSON clamps to 60000ms\", () => {\n    expect(parseIpcCommand(\"READ_WAIT_JSON 999999\")).toEqual({\n      type: \"read_wait_json\",\n      ms: 60_000,\n    });\n  });\n\n  test(\"FRIENDS\", () => {\n    expect(parseIpcCommand(\"FRIENDS\")).toEqual({ type: \"friends\" });\n  });\n\n  test(\"FRIENDS_JSON\", () => {\n    expect(parseIpcCommand(\"FRIENDS_JSON\")).toEqual({ type: \"friends_json\" });\n  });\n\n  test(\"ADD_FRIEND\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"ADD_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"ADD_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"DEL_FRIEND\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"DEL_FRIEND with no target returns undefined\", () => {\n    expect(parseIpcCommand(\"DEL_FRIEND\")).toBeUndefined();\n  });\n\n  test(\"slash /friend add maps to add_friend\", () => {\n    expect(parseIpcCommand(\"/friend add Arthas\")).toEqual({\n      type: \"add_friend\",\n      target: \"Arthas\",\n    });\n  });\n\n  test(\"slash /friend remove maps to del_friend\", () => {\n    expect(parseIpcCommand(\"/friend remove Arthas\")).toEqual({\n      type: \"del_friend\",\n      target: \"Arthas\",\n    });\n  });\n});\n\ndescribe(\"dispatchCommand\", () => {\n  test(\"say calls sendSay and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"say\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"yell calls sendYell and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"yell\", message: \"HEY\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendYell).toHaveBeenCalledWith(\"HEY\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"guild calls sendGuild and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"guild\", message: \"inv pls\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendGuild).toHaveBeenCalledWith(\"inv pls\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"party calls sendParty and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"party\", message: \"pull\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendParty).toHaveBeenCalledWith(\"pull\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"emote calls sendEmote and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"emote\", message: \"waves hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"whisper calls sendWhisper and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"whisper\", target: \"Xiara\", message: \"hey\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"read drains ring buffer text\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"[say] Alice: hi\\n[say] Bob: hey\\n\\n\");\n  });\n\n  test(\"read on empty buffer writes just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"read\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"read_wait delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] Alice: hi\\n\\n\");\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait\", ms: 1000 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(1000);\n      await promise;\n      expect(socket.written()).toBe(\"[say] New: during\\n\\n\");\n      expect(events.drain()).toEqual([\n        { text: \"[say] Old: before\", json: '{\"type\":\"SAY\"}' },\n        { text: \"[say] New: during\", json: '{\"type\":\"SAY\"}' },\n      ]);\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"status writes CONNECTED\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"status\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n  });\n\n  test(\"stop calls cleanup and returns true\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"stop\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(true);\n    expect(cleanup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who passes filter and formats results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    expect(socket.written()).toContain(\"[who] 1 results: Test (80)\");\n  });\n\n  test(\"who without filter passes empty object\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"who\" }, handle, events, socket, cleanup);\n\n    expect(handle.who).toHaveBeenCalledWith({});\n  });\n\n  test(\"read_json drains ring buffer json\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    events.push({\n      text: \"[say] Alice: hi\",\n      json: '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}',\n    });\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"read_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\n      '{\"type\":\"SAY\",\"sender\":\"Alice\",\"message\":\"hi\"}\\n\\n',\n    );\n  });\n\n  test(\"read_wait_json delays then returns window events\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      expect(socket.written()).toBe(\"\");\n      events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"type\":\"SAY\"}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"read_wait_json returns only events arriving during wait window\", async () => {\n    jest.useFakeTimers();\n    try {\n      const handle = createMockHandle();\n      const events = new RingBuffer<EventEntry>(10);\n      events.push({ text: \"[say] Old: before\", json: '{\"old\":true}' });\n      const socket = createMockSocket();\n      const cleanup = jest.fn();\n\n      const promise = dispatchCommand(\n        { type: \"read_wait_json\", ms: 500 },\n        handle,\n        events,\n        socket,\n        cleanup,\n      );\n\n      events.push({ text: \"[say] New: during\", json: '{\"new\":true}' });\n      jest.advanceTimersByTime(500);\n      await promise;\n      expect(socket.written()).toBe('{\"new\":true}\\n\\n');\n    } finally {\n      jest.useRealTimers();\n    }\n  });\n\n  test(\"invite calls handle.invite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"invite\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.invite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"kick calls handle.uninvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"kick\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.uninvite).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leave calls handle.leaveGroup and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"leave\" }, handle, events, socket, cleanup);\n\n    expect(handle.leaveGroup).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"leader calls handle.setLeader and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"leader\", target: \"Voidtrix\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.setLeader).toHaveBeenCalledWith(\"Voidtrix\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"accept calls handle.acceptInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"accept\" }, handle, events, socket, cleanup);\n\n    expect(handle.acceptInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"decline calls handle.declineInvite and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"decline\" }, handle, events, socket, cleanup);\n\n    expect(handle.declineInvite).toHaveBeenCalled();\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"who_json returns JSON formatted results\", async () => {\n    const handle = createMockHandle();\n    (handle.who as ReturnType<typeof jest.fn>).mockResolvedValue([\n      {\n        name: \"Test\",\n        guild: \"G\",\n        level: 80,\n        classId: 1,\n        race: 1,\n        gender: 0,\n        zone: 1,\n      },\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"who_json\", filter: \"mage\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.who).toHaveBeenCalledWith({ name: \"mage\" });\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"WHO\");\n    expect(parsed.count).toBe(1);\n    expect(parsed.results[0].name).toBe(\"Test\");\n  });\n\n  test(\"nearby returns formatted entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Mailbox\",\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.5, y: 4.6, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 19,\n      bytes1: 0,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n      testGo,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Thrall (NPC, level 80) HP 5000/5000 at 1.23, 4.56, 7.89\",\n    );\n    expect(output).toContain(\"Mailbox (GameObject) at 1.50, 4.60, 7.89\");\n  });\n\n  test(\"nearby_json returns JSONL entity list\", async () => {\n    const handle = createMockHandle();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.guid).toBe(\"0x1\");\n    expect(parsed.type).toBe(\"unit\");\n    expect(parsed.name).toBe(\"Thrall\");\n    expect(parsed.level).toBe(80);\n    expect(parsed.health).toBe(5000);\n    expect(parsed.maxHealth).toBe(5000);\n    expect(parsed.x).toBe(1.23);\n    expect(parsed.y).toBe(4.56);\n    expect(parsed.z).toBe(7.89);\n  });\n\n  test(\"nearby with no entities returns just terminator\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    expect(socket.written()).toBe(\"\\n\");\n  });\n\n  test(\"nearby formats player entity\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 10n,\n      objectType: ObjectType.PLAYER,\n      name: \"Arthas\",\n      level: 55,\n      health: 3000,\n      maxHealth: 4000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 0, x: 10.0, y: 20.0, z: 30.0, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\n      \"Arthas (Player, level 55) HP 3000/4000 at 10.00, 20.00, 30.00\",\n    );\n  });\n\n  test(\"nearby formats unknown entity type\", async () => {\n    const handle = createMockHandle();\n    const testCorpse: BaseEntity = {\n      guid: 0xabn,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"nearby\" }, handle, events, socket, cleanup);\n\n    const output = socket.written();\n    expect(output).toContain(\"Entity 0xab (type 7)\");\n  });\n\n  test(\"nearby_json formats player and gameobject types\", async () => {\n    const handle = createMockHandle();\n    const testPlayer: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.PLAYER,\n      name: \"Jaina\",\n      level: 70,\n      health: 8000,\n      maxHealth: 8000,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    const testGo: GameObjectEntity = {\n      guid: 2n,\n      objectType: ObjectType.GAMEOBJECT,\n      name: \"Chest\",\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      displayId: 0,\n      flags: 0,\n      gameObjectType: 3,\n      bytes1: 0,\n    };\n    const testCorpse: BaseEntity = {\n      guid: 3n,\n      objectType: ObjectType.CORPSE,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      name: undefined,\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testPlayer,\n      testGo,\n      testCorpse,\n    ]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"nearby_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    const lines = socket.written().trim().split(\"\\n\").filter(Boolean);\n    expect(lines).toHaveLength(3);\n    const player = JSON.parse(lines[0]!);\n    const go = JSON.parse(lines[1]!);\n    const corpse = JSON.parse(lines[2]!);\n    expect(player.type).toBe(\"player\");\n    expect(player.level).toBe(70);\n    expect(player.health).toBe(8000);\n    expect(go.type).toBe(\"gameobject\");\n    expect(go.gameObjectType).toBe(3);\n    expect(corpse.type).toBe(\"object\");\n  });\n\n  test(\"friends calls getFriends and writes friend list\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand({ type: \"friends\" }, handle, events, socket, cleanup);\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    expect(socket.written()).toContain(\"No friends on your list\");\n  });\n\n  test(\"friends_json calls getFriends and writes JSON\", async () => {\n    const handle = createMockHandle();\n    (handle.getFriends as ReturnType<typeof jest.fn>).mockReturnValue([]);\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"friends_json\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.getFriends).toHaveBeenCalled();\n    const parsed = JSON.parse(socket.written().replace(/\\n+$/, \"\"));\n    expect(parsed.type).toBe(\"FRIENDS\");\n    expect(parsed.count).toBe(0);\n  });\n\n  test(\"add_friend calls handle.addFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"add_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.addFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"del_friend calls handle.removeFriend and writes OK\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"del_friend\", target: \"Arthas\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(handle.removeFriend).toHaveBeenCalledWith(\"Arthas\");\n    expect(socket.written()).toBe(\"OK\\n\\n\");\n  });\n\n  test(\"unimplemented writes UNIMPLEMENTED response\", async () => {\n    const handle = createMockHandle();\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"unimplemented\", feature: \"Friends list\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(socket.written()).toBe(\"UNIMPLEMENTED Friends list\\n\\n\");\n  });\n\n  test(\"chat sends via sendInCurrentMode and responds with mode\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"say\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    const result = await dispatchCommand(\n      { type: \"chat\", message: \"hello\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(result).toBe(false);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello\");\n    expect(socket.written()).toBe(\"OK SAY\\n\\n\");\n  });\n\n  test(\"chat mode label includes whisper target\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"whisper\",\n      target: \"Xiara\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"follow me\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK WHISPER Xiara\\n\\n\");\n  });\n\n  test(\"chat mode label includes channel name\", async () => {\n    const handle = createMockHandle();\n    (handle.getLastChatMode as ReturnType<typeof jest.fn>).mockReturnValue({\n      type: \"channel\",\n      channel: \"General\",\n    });\n    const events = new RingBuffer<EventEntry>(10);\n    const socket = createMockSocket();\n    const cleanup = jest.fn();\n\n    await dispatchCommand(\n      { type: \"chat\", message: \"hello general\" },\n      handle,\n      events,\n      socket,\n      cleanup,\n    );\n\n    expect(socket.written()).toBe(\"OK CHANNEL General\\n\\n\");\n  });\n});\n\ndescribe(\"writeLines\", () => {\n  test(\"writes each line with newline then blank terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, [\"line1\", \"line2\"]);\n    expect(socket.written()).toBe(\"line1\\nline2\\n\\n\");\n  });\n\n  test(\"empty array writes just terminator\", () => {\n    const socket = createMockSocket();\n    writeLines(socket, []);\n    expect(socket.written()).toBe(\"\\n\");\n  });\n});\n\ndescribe(\"onChatMessage\", () => {\n  test(\"pushes formatted message to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.SAY, sender: \"Alice\", message: \"hi\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[say] Alice: hi\");\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"SAY\",\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n  });\n\n  test(\"appends JSON to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith({\n      type: \"WHISPER_FROM\",\n      sender: \"Eve\",\n      message: \"psst\",\n    });\n  });\n\n  test(\"swallows session log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onChatMessage(\n      { type: ChatType.WHISPER, sender: \"Eve\", message: \"psst\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onGroupEvent\", () => {\n  test(\"pushes group_list with undefined text to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"group_list\",\n        members: [{ name: \"Alice\", guidLow: 1, guidHigh: 0, online: true }],\n        leader: \"Alice\",\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toBeUndefined();\n    expect(JSON.parse(drained[0]!.json)).toMatchObject({ type: \"GROUP_LIST\" });\n  });\n\n  test(\"pushes member_stats to session log\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.resolve());\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent(\n      { type: \"member_stats\", guidLow: 42, hp: 100, maxHp: 200 },\n      events,\n      log,\n    );\n\n    expect(append).toHaveBeenCalledWith(\n      expect.objectContaining({ type: \"PARTY_MEMBER_STATS\", guidLow: 42 }),\n    );\n  });\n\n  test(\"swallows group event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n\n  test(\"pushes displayable events with text\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"invite_received\", from: \"Bob\" }, events, log);\n\n    const drained = events.drain();\n    expect(drained[0]!.text).toBe(\"[group] Bob invites you to a group\");\n  });\n\n  test(\"serializes command_result event details\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent(\n      {\n        type: \"command_result\",\n        operation: 1,\n        target: \"Voidtrix\",\n        result: 0,\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(JSON.parse(drained[0]!.json)).toEqual({\n      type: \"GROUP_COMMAND_RESULT\",\n      operation: 1,\n      target: \"Voidtrix\",\n      result: 0,\n    });\n  });\n\n  test(\"serializes leader/group lifecycle events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const log: SessionLog = {\n      append: jest.fn(() => Promise.resolve()),\n    } as unknown as SessionLog;\n\n    onGroupEvent({ type: \"leader_changed\", name: \"Alice\" }, events, log);\n    onGroupEvent({ type: \"group_destroyed\" }, events, log);\n    onGroupEvent({ type: \"kicked\" }, events, log);\n    onGroupEvent({ type: \"invite_declined\", name: \"Bob\" }, events, log);\n\n    const drained = events.drain().map((entry) => JSON.parse(entry.json));\n    expect(drained).toEqual([\n      { type: \"GROUP_LEADER_CHANGED\", name: \"Alice\" },\n      { type: \"GROUP_DESTROYED\" },\n      { type: \"GROUP_KICKED\" },\n      { type: \"GROUP_INVITE_DECLINED\", name: \"Bob\" },\n    ]);\n  });\n});\n\ndescribe(\"onEntityEvent\", () => {\n  test(\"pushes appear event to ring buffer with text and json\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"appear\", entity }, events, log);\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Test NPC\");\n    expect(drained[0]!.text).toContain(\"appeared\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_APPEAR\");\n    expect(json.name).toBe(\"Test NPC\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes disappear event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Gone NPC\");\n    expect(drained[0]!.text).toContain(\"left range\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"ENTITY_DISAPPEAR\");\n  });\n\n  test(\"skips update events with no obj\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const entity: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Test NPC\",\n      level: 10,\n      health: 100,\n      maxHealth: 100,\n      entry: 0,\n      scale: 1,\n      position: undefined,\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n    onEntityEvent({ type: \"update\", entity, changed: [\"health\"] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"swallows entity event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onEntityEvent(\n      { type: \"disappear\", guid: 1n, name: \"Gone NPC\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"onFriendEvent\", () => {\n  test(\"pushes friend-online event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      {\n        type: \"friend-online\",\n        friend: {\n          guid: 1n,\n          name: \"Arthas\",\n          note: \"\",\n          status: FriendStatus.ONLINE,\n          area: 0,\n          level: 80,\n          playerClass: 6,\n        },\n      },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"online\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ONLINE\");\n    expect(json.name).toBe(\"Arthas\");\n    expect(append).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"pushes friend-offline event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Arthas\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"Arthas\");\n    expect(drained[0]!.text).toContain(\"offline\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_OFFLINE\");\n  });\n\n  test(\"skips friend-list events\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent({ type: \"friend-list\", friends: [] }, events, log);\n\n    expect(events.drain()).toHaveLength(0);\n    expect(append).not.toHaveBeenCalled();\n  });\n\n  test(\"pushes friend-error event to ring buffer\", () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(async () => {});\n    const log = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-error\", result: 0x04, name: \"Nobody\" },\n      events,\n      log,\n    );\n\n    const drained = events.drain();\n    expect(drained).toHaveLength(1);\n    expect(drained[0]!.text).toContain(\"player not found\");\n    const json = JSON.parse(drained[0]!.json);\n    expect(json.type).toBe(\"FRIEND_ERROR\");\n    expect(json.result).toBe(0x04);\n  });\n\n  test(\"swallows friend event log append errors\", async () => {\n    const events = new RingBuffer<EventEntry>(10);\n    const append = jest.fn(() => Promise.reject(new Error(\"disk full\")));\n    const log: SessionLog = { append } as unknown as SessionLog;\n\n    onFriendEvent(\n      { type: \"friend-offline\", guid: 1n, name: \"Gone\" },\n      events,\n      log,\n    );\n    await Promise.resolve();\n\n    expect(append).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"IPC round-trip\", () => {\n  let sockCounter = 0;\n  let sockPath: string;\n  let handle: ReturnType<typeof createMockHandle>;\n  let result: ReturnType<typeof startDaemonServer>;\n  let exitSpy: ReturnType<typeof jest.fn>;\n\n  function startTestServer(opts?: { onActivity?: () => void }) {\n    sockPath = `./tmp/test-daemon-${++sockCounter}-${Date.now()}.sock`;\n    handle = createMockHandle();\n    const log = new SessionLog(`./tmp/test-daemon-${sockCounter}.jsonl`);\n    exitSpy = jest\n      .spyOn(process, \"exit\")\n      .mockImplementation(() => undefined as never);\n    result = startDaemonServer({ handle, sock: sockPath, log, ...opts });\n  }\n\n  afterEach(async () => {\n    exitSpy?.mockRestore();\n    result?.cleanup();\n  });\n\n  test(\"STATUS returns CONNECTED\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STATUS\", sockPath);\n    expect(lines).toEqual([\"CONNECTED\"]);\n  });\n\n  test(\"SAY returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"SAY hello world\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"EMOTE returns OK and calls handle\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n  });\n\n  test(\"WHISPER returns OK\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    expect(handle.sendWhisper).toHaveBeenCalledWith(\"Xiara\", \"hey\");\n  });\n\n  test(\"READ returns buffered events\", async () => {\n    startTestServer();\n    result.events.push({ text: \"[say] Alice: hi\", json: '{\"type\":\"SAY\"}' });\n    result.events.push({ text: \"[say] Bob: hey\", json: '{\"type\":\"SAY\"}' });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\", \"[say] Bob: hey\"]);\n  });\n\n  test(\"bare text sends via sticky mode\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"hello world\", sockPath);\n    expect(lines[0]).toMatch(/^OK /);\n    expect(handle.sendInCurrentMode).toHaveBeenCalledWith(\"hello world\");\n  });\n\n  test(\"empty command returns ERR\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"\", sockPath);\n    expect(lines).toEqual([\"ERR unknown command\"]);\n  });\n\n  test(\"sendToSocket rejects on missing socket\", async () => {\n    await expect(\n      sendToSocket(\"STATUS\", \"./tmp/nonexistent.sock\"),\n    ).rejects.toThrow();\n  });\n\n  test(\"onActivity fires on each IPC command\", async () => {\n    const activity = jest.fn();\n    startTestServer({ onActivity: activity });\n    await sendToSocket(\"STATUS\", sockPath);\n    await sendToSocket(\"STATUS\", sockPath);\n    expect(activity).toHaveBeenCalledTimes(2);\n  });\n\n  test(\"cleanup closes handle and stops server\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalled();\n    await expect(sendToSocket(\"STATUS\", sockPath)).rejects.toThrow();\n  });\n\n  test(\"cleanup is idempotent\", async () => {\n    startTestServer();\n    result.cleanup();\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"cleanup ignores missing socket file\", async () => {\n    startTestServer();\n    await sendToSocket(\"STATUS\", sockPath);\n    await unlink(sockPath);\n    result.cleanup();\n    expect(handle.close).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"STOP triggers process.exit\", async () => {\n    startTestServer();\n    const lines = await sendToSocket(\"STOP\", sockPath);\n    expect(lines).toEqual([\"OK\"]);\n    await Bun.sleep(0);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"buffers split command chunks before parsing\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-split-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-split-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STA\"));\n      capturedData!(socket, Buffer.from(\"TUS\\n\"));\n      await Promise.resolve();\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"processes multiple commands from a single chunk\", async () => {\n    const origListen = Bun.listen;\n    let capturedData:\n      | ((\n          socket: {\n            write(data: string | Uint8Array): number;\n            end(): void;\n          },\n          data: ArrayBuffer | ArrayBufferView,\n        ) => void | Promise<void>)\n      | undefined;\n    let stopFn: ReturnType<typeof jest.fn> | undefined;\n\n    Bun.listen = jest.fn((opts: { socket: { data: typeof capturedData } }) => {\n      capturedData = opts.socket.data;\n      stopFn = jest.fn();\n      return { stop: stopFn } as unknown as ReturnType<typeof Bun.listen>;\n    }) as unknown as typeof Bun.listen;\n\n    try {\n      const handle = createMockHandle();\n      const log = new SessionLog(`./tmp/test-daemon-multi-${Date.now()}.jsonl`);\n      const { cleanup } = startDaemonServer({\n        handle,\n        sock: `./tmp/test-daemon-multi-${Date.now()}.sock`,\n        log,\n      });\n      const socket = createMockSocket();\n\n      capturedData!(socket, Buffer.from(\"STATUS\\nSTATUS\\n\"));\n      await Bun.sleep(0);\n\n      expect(socket.written()).toBe(\"CONNECTED\\n\\nCONNECTED\\n\\n\");\n\n      cleanup();\n      expect(stopFn).toHaveBeenCalled();\n    } finally {\n      Bun.listen = origListen;\n    }\n  });\n\n  test(\"onMessage wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerMessage({\n      type: ChatType.SAY,\n      sender: \"Alice\",\n      message: \"hi\",\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[say] Alice: hi\"]);\n  });\n\n  test(\"onGroupEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerGroupEvent({ type: \"group_destroyed\" });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines).toEqual([\"[group] Group has been disbanded\"]);\n  });\n\n  test(\"onFriendEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerFriendEvent({\n      type: \"friend-online\",\n      friend: {\n        guid: 1n,\n        name: \"Arthas\",\n        level: 80,\n        playerClass: 1,\n        area: 0,\n        status: 0,\n        note: \"\",\n      },\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Arthas\");\n  });\n\n  test(\"onEntityEvent wiring pushes to ring buffer\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ\", sockPath);\n    expect(lines[0]).toContain(\"Test NPC\");\n  });\n\n  test(\"onEntityEvent wiring round-trip via READ_JSON\", async () => {\n    startTestServer();\n    handle.triggerEntityEvent({\n      type: \"appear\",\n      entity: {\n        guid: 1n,\n        objectType: ObjectType.UNIT,\n        name: \"Test NPC\",\n        level: 10,\n        health: 100,\n        maxHealth: 100,\n        entry: 0,\n        scale: 1,\n        position: undefined,\n        rawFields: new Map(),\n        factionTemplate: 0,\n        displayId: 0,\n        npcFlags: 0,\n        unitFlags: 0,\n        target: 0n,\n        race: 0,\n        class_: 0,\n        gender: 0,\n        power: [0, 0, 0, 0, 0, 0, 0],\n        maxPower: [0, 0, 0, 0, 0, 0, 0],\n      } satisfies UnitEntity,\n    });\n    const lines = await sendToSocket(\"READ_JSON\", sockPath);\n    const parsed = JSON.parse(lines[0]!);\n    expect(parsed.type).toBe(\"ENTITY_APPEAR\");\n    expect(parsed.name).toBe(\"Test NPC\");\n  });\n\n  test(\"NEARBY round-trip returns formatted entities\", async () => {\n    startTestServer();\n    const testUnit: UnitEntity = {\n      guid: 1n,\n      objectType: ObjectType.UNIT,\n      name: \"Thrall\",\n      level: 80,\n      health: 5000,\n      maxHealth: 5000,\n      entry: 0,\n      scale: 1,\n      position: { mapId: 1, x: 1.23, y: 4.56, z: 7.89, orientation: 0 },\n      rawFields: new Map(),\n      factionTemplate: 0,\n      displayId: 0,\n      npcFlags: 0,\n      unitFlags: 0,\n      target: 0n,\n      race: 0,\n      class_: 0,\n      gender: 0,\n      power: [0, 0, 0, 0, 0, 0, 0],\n      maxPower: [0, 0, 0, 0, 0, 0, 0],\n    };\n    (handle.getNearbyEntities as ReturnType<typeof jest.fn>).mockReturnValue([\n      testUnit,\n    ]);\n    const lines = await sendToSocket(\"NEARBY\", sockPath);\n    expect(lines[0]).toContain(\"Thrall\");\n    expect(lines[0]).toContain(\"level 80\");\n  });\n\n  test(\"dispatch error returns ERR internal\", async () => {\n    startTestServer();\n    (handle.who as ReturnType<typeof jest.fn>).mockRejectedValue(\n      new Error(\"db fail\"),\n    );\n    const lines = await sendToSocket(\"WHO\", sockPath);\n    expect(lines).toEqual([\"ERR internal\"]);\n  });\n});\n","structuredPatch":[{"oldStart":294,"oldLines":7,"newStart":294,"newLines":6,"lines":["       [\"ROLL\", \"Random roll\"],","       [\"DND\", \"Player status\"],","       [\"AFK\", \"Player status\"],","-      [\"EMOTE waves\", \"Text emotes\"],","     ] as const;"," ","     for (const [input, feature] of cases) {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"37c1efc6-0bc4-4c4c-864f-c7e3d30bcdd5"}
{"parentUuid":"7be4abe0-1714-42bb-a11b-d36bfcc90a91","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01NkmYzzo9nzpuN8cpnh1Psp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CPwT9RZNUpQS3aDZVphkYS","name":"Bash","input":{"command":"mise test 2>&1","description":"Run all tests","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":228,"cache_read_input_tokens":101440,"output_tokens":94,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":228,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMkn3eVUMRHwZ4nRtQU","type":"assistant","uuid":"0bf6e78a-a911-4602-9543-42da70ceb8ed","timestamp":"2026-02-28T23:46:37.390Z"}
{"parentUuid":"0bf6e78a-a911-4602-9543-42da70ceb8ed","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CPwT9RZNUpQS3aDZVphkYS","type":"tool_result","content":"[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\n 825 pass\n 0 fail\n 2149 expect() calls\nRan 825 tests across 33 files. [463.00ms]","is_error":false}]},"uuid":"16e0d644-5169-4c1e-bb9f-108b6d8b29c6","timestamp":"2026-02-28T23:46:37.893Z","toolUseResult":{"stdout":"[test] $ bun test\nbun test v1.3.9 (cf6cdbbb)\n\n 825 pass\n 0 fail\n 2149 expect() calls\nRan 825 tests across 33 files. [463.00ms]","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"0bf6e78a-a911-4602-9543-42da70ceb8ed"}
{"parentUuid":"16e0d644-5169-4c1e-bb9f-108b6d8b29c6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0136MqxDMbD4a9sXHmnirgcd","type":"message","role":"assistant","content":[{"type":"text","text":"All 825 tests pass. Now let me update the docs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":167,"cache_read_input_tokens":101668,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":167},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMm4MRttUQfRn9moQ9M","type":"assistant","uuid":"3a3e42a8-e730-49cd-ba62-8d25014378a9","timestamp":"2026-02-28T23:46:41.629Z"}
{"parentUuid":"3a3e42a8-e730-49cd-ba62-8d25014378a9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0136MqxDMbD4a9sXHmnirgcd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DNqbvshah3BwS9u2FvRZv2","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"in_progress","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":167,"cache_read_input_tokens":101668,"output_tokens":326,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":167,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMm4MRttUQfRn9moQ9M","type":"assistant","uuid":"b664714e-0872-4190-8bde-9309bde809e1","timestamp":"2026-02-28T23:46:45.959Z"}
{"parentUuid":"b664714e-0872-4190-8bde-9309bde809e1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DNqbvshah3BwS9u2FvRZv2","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"fb5366dd-1e1d-4fba-931c-ec4e3212c5ae","timestamp":"2026-02-28T23:46:45.961Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"in_progress","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"pending","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"in_progress","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"b664714e-0872-4190-8bde-9309bde809e1"}
{"parentUuid":"fb5366dd-1e1d-4fba-931c-ec4e3212c5ae","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01PgiBBpJYKJwpfW9JCaoA5K","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the four doc locations: `help.ts`, `manual.md`, `SKILL.md`, and `README.md`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":368,"cache_read_input_tokens":101835,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":368},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMmetZoNfthHVQirFHU","type":"assistant","uuid":"00561f41-643d-4923-85d7-3d159c2e8c56","timestamp":"2026-02-28T23:46:49.943Z"}
{"parentUuid":"00561f41-643d-4923-85d7-3d159c2e8c56","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01PgiBBpJYKJwpfW9JCaoA5K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Pa3SpAB84HxLJMtoFMKytv","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/cli/help.ts","old_string":"  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands","new_string":"  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":368,"cache_read_input_tokens":101835,"output_tokens":210,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":368,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMmetZoNfthHVQirFHU","type":"assistant","uuid":"dfa84b67-2bdb-462a-b471-42c58974f2ce","timestamp":"2026-02-28T23:46:51.967Z"}
{"parentUuid":"dfa84b67-2bdb-462a-b471-42c58974f2ce","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Pa3SpAB84HxLJMtoFMKytv","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/cli/help.ts has been updated successfully."}]},"uuid":"e3e4db3c-4623-4045-87e4-a2902f839bd6","timestamp":"2026-02-28T23:46:51.985Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/cli/help.ts","oldString":"  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands","newString":"  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands","originalFile":"export function helpText(): string {\n  return `tuicraft — WoW 3.3.5a chat client\n\nUSAGE\n  tuicraft                    Interactive TUI mode\n  tuicraft setup [flags]      Configure account credentials\n  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n  tuicraft send -w <name> \"m\" Whisper a player\n  tuicraft send -y \"message\"  Yell\n  tuicraft send -g \"message\"  Guild chat\n  tuicraft send -p \"message\"  Party chat\n  tuicraft who [filter]       Who query\n  tuicraft read [--wait N]    Read buffered events\n  tuicraft tail               Continuous event stream\n  tuicraft status             Show daemon status\n  tuicraft stop               Stop the daemon\n  tuicraft logs               Print session log\n  tuicraft skill              Print SKILL.md for AI agents\n  tuicraft version            Print version and exit\n  tuicraft help               Show this help\n\nFLAGS\n  -v, --version   Print version and exit\n  -h, --help      Show this help\n  --json          Output events as JSONL (for read, tail, chat, who)\n  --wait N        Wait N seconds for events (for read and send commands)\n  --daemon        Start as background daemon (internal)\n\nSETUP FLAGS\n  --account NAME  Account name (required)\n  --password PASS Password (required)\n  --character NAME Character name (required)\n  --host HOST     Auth server hostname (default: t1)\n  --port PORT     Auth server port (default: 3724)\n  --language ID   Chat language code (default: 1/Orcish)\n  --timeout_minutes N  Daemon idle timeout (default: 30)\n\nINTERACTIVE COMMANDS (TUI mode)\n  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n  /r              Reply to last whisper\n  /who [filter]   Who search\n  /invite <name>  Invite player to group\n  /kick <name>    Remove player from group\n  /leave          Leave the current group\n  /leader <name>  Transfer group leadership\n  /accept         Accept a group invitation\n  /decline        Decline a group invitation\n  /friends        Show your friends list\n  /friend add <n> Add a player to friends\n  /friend remove  Remove a player from friends\n  /tuicraft entities on|off  Toggle entity event display\n  /quit           Disconnect and exit\n\nDAEMON\n  The daemon starts automatically when needed and stays running\n  for 30 minutes of inactivity. It maintains the WoW connection\n  and buffers events for CLI clients.\n\nFILES\n  ~/.config/tuicraft/config.toml  Account config\n  $TMPDIR/tuicraft-<uid>/sock     Daemon socket\n  $TMPDIR/tuicraft-<uid>/pid     Daemon pidfile\n  ~/.local/state/tuicraft/session.log  Session log`;\n}\n","structuredPatch":[{"oldStart":36,"oldLines":7,"newStart":36,"newLines":7,"lines":["   --timeout_minutes N  Daemon idle timeout (default: 30)"," "," INTERACTIVE COMMANDS (TUI mode)","-  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands","+  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands","   /r              Reply to last whisper","   /who [filter]   Who search","   /invite <name>  Invite player to group"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"dfa84b67-2bdb-462a-b471-42c58974f2ce"}
{"parentUuid":"e3e4db3c-4623-4045-87e4-a2902f839bd6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Bemcqwvrmv4TgQBE8q6Y6S","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `README.md`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":247,"cache_read_input_tokens":102203,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":247},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMn6uVv3YuAkvu1V7Pb","type":"assistant","uuid":"f1a37ff5-911f-4be2-880f-c5bc51c3a334","timestamp":"2026-02-28T23:46:54.781Z"}
{"parentUuid":"f1a37ff5-911f-4be2-880f-c5bc51c3a334","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Bemcqwvrmv4TgQBE8q6Y6S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SHu7YeWecfDNFK7hQoxzAi","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/README.md","offset":130,"limit":20},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":247,"cache_read_input_tokens":102203,"output_tokens":109,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":247,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMn6uVv3YuAkvu1V7Pb","type":"assistant","uuid":"93a2dfbf-fb29-4185-b08e-eba051acd08d","timestamp":"2026-02-28T23:46:55.490Z"}
{"parentUuid":"93a2dfbf-fb29-4185-b08e-eba051acd08d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SHu7YeWecfDNFK7hQoxzAi","type":"tool_result","content":"   130→\n   131→### 💬 Chat\n   132→\n   133→| Feature                                 | Status |\n   134→| --------------------------------------- | ------ |\n   135→| Say, yell                               | ✅     |\n   136→| Whisper (`/w`, `/r`)                    | ✅     |\n   137→| Guild, officer                          | ✅     |\n   138→| Party, raid                             | ✅     |\n   139→| Channels (`/1`, `/2`, …)                | ✅     |\n   140→| MOTD                                    | ✅     |\n   141→| Server broadcast messages               | ❌     |\n   142→| Chat restricted / wrong faction notices | ❌     |\n   143→| Text emotes (`/e`, `/emote`)            | ❌     |\n   144→| DND / AFK status                        | ❌     |\n   145→\n   146→### 👥 Social\n   147→\n   148→| Feature                              | Status |\n   149→| ------------------------------------ | ------ |"}]},"uuid":"55ebe385-b63b-4ea1-963b-0e349ce8a09c","timestamp":"2026-02-28T23:46:55.492Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/README.md","content":"\n### 💬 Chat\n\n| Feature                                 | Status |\n| --------------------------------------- | ------ |\n| Say, yell                               | ✅     |\n| Whisper (`/w`, `/r`)                    | ✅     |\n| Guild, officer                          | ✅     |\n| Party, raid                             | ✅     |\n| Channels (`/1`, `/2`, …)                | ✅     |\n| MOTD                                    | ✅     |\n| Server broadcast messages               | ❌     |\n| Chat restricted / wrong faction notices | ❌     |\n| Text emotes (`/e`, `/emote`)            | ❌     |\n| DND / AFK status                        | ❌     |\n\n### 👥 Social\n\n| Feature                              | Status |\n| ------------------------------------ | ------ |","numLines":20,"startLine":130,"totalLines":246}},"sourceToolAssistantUUID":"93a2dfbf-fb29-4185-b08e-eba051acd08d"}
{"parentUuid":"55ebe385-b63b-4ea1-963b-0e349ce8a09c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01KRvw3hKxgyoKPWM1NUS9gE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TMaWDNzkjuz9jD7oo2KNMv","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/README.md","old_string":"| Text emotes (`/e`, `/emote`)            | ❌     |","new_string":"| Text emotes (`/e`, `/emote`)            | ✅     |"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":389,"cache_read_input_tokens":102450,"output_tokens":160,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":389,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMnMYovMhSSjtZPUtXG","type":"assistant","uuid":"ace3d297-f2dc-4f93-a7cd-4029563bda04","timestamp":"2026-02-28T23:47:00.633Z"}
{"parentUuid":"ace3d297-f2dc-4f93-a7cd-4029563bda04","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TMaWDNzkjuz9jD7oo2KNMv","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/README.md has been updated successfully."}]},"uuid":"ae7b763f-53e1-40ea-acee-2e34fda8c93d","timestamp":"2026-02-28T23:47:00.653Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/README.md","oldString":"| Text emotes (`/e`, `/emote`)            | ❌     |","newString":"| Text emotes (`/e`, `/emote`)            | ✅     |","originalFile":"# tuicraft\n\nChat in WoW 3.3.5a from your terminal. Targets AzerothCore private servers and\nis designed to be both human and LLM friendly.\n\n```sh\ncurl -fsSL tuicraft.vararu.org/install.sh | sh\n```\n\n## Features\n\n🔐 **Authentication** - Secure login, realm selection, and character select\n\n💬 **Chat** - Say, yell, whisper, guild, party, raid, and channel messages with\n`/r` reply support\n\n👥 **Party Management** - Invite, kick, leave, leader transfer, accept/decline\ninvitations, live group roster with member stats\n\n👫 **Friends List** - View online/offline friends, add/remove friends, real-time\nonline status notifications\n\n🔍 **Who Search** - Query online players with filters, human and JSON output\n\n🖥️ **Interactive TUI** - Full terminal UI with slash commands and channel\nswitching\n\n🤖 **CLI & Daemon** - Background daemon, pipe mode, and JSONL output for\nscripting\n\n📝 **Session Logging** - Persistent session log with `tuicraft logs` playback\n\n⚡ **Zero Dependencies** - Pure TypeScript on Bun, compiles to a single binary\n\n## Install\n\n```sh\ncurl -fsSL tuicraft.vararu.org/install.sh | sh\n```\n\nOverride the install directory (default: `/usr/local/bin`):\n\n```sh\nTUICRAFT_INSTALL_DIR=~/.local/bin curl -fsSL tuicraft.vararu.org/install.sh | sh\n```\n\nPre-built binaries are available on the [releases\npage](https://github.com/tvararu/tuicraft/releases).\n\n## Compatibility\n\n| Platform | Architecture         | Status                        |\n| -------- | -------------------- | ----------------------------- |\n| Linux    | x64, ARM64           | Supported                     |\n| macOS    | Apple Silicon, Intel | Supported                     |\n| Windows  | WSL2                 | Supported (uses Linux binary) |\n\n## Development\n\nRequires [mise](https://mise.jdx.dev), automatically installs `bun`:\n\n```\nmise trust -y\nmise bundle\nmise build\n```\n\n## Testing\n\n```\nmise test\n```\n\nTo run live integration tests against a real server, copy the example config and\nfill in your credentials:\n\n```\ncp mise.local.toml.example mise.local.toml\n# edit mise.local.toml with your account details\nmise test:live\n```\n\n## Usage\n\n```\ntuicraft help              # show help\ntuicraft setup\ntuicraft                   # interactive TUI\ntuicraft send \"Hello\"      # send a say message (auto-starts daemon)\ntuicraft send -w Hemet \"x\" # whisper\ntuicraft send -g \"lfm\"     # guild chat\ntuicraft who               # who query\ntuicraft read --wait 5     # read events, wait up to 5s\ntuicraft tail              # continuous event stream\ntuicraft status            # daemon status\ntuicraft stop              # stop daemon\ntuicraft skill             # print SKILL.md for AI agents\n```\n\n## Roadmap\n\n- [x] 🔐 **0.1 - Auth & Connect:** SRP-6 auth, Arc4-encrypted world session,\n      character select, keepalive\n- [x] 💬 **0.2 - Chat:** Send/receive whispers, say, guild chat. TUI with\n      interactive and pipe modes\n- [x] 👥 **0.3 - Party Management:** Invite, kick, leave, leader transfer,\n      group roster, member stats\n- [x] 🌍 **0.4 - World State:** Parse `SMSG_UPDATE_OBJECT` to track nearby\n      entities\n- [ ] 🏃 **0.5 - Movement:** Send `CMSG_MOVE_*` opcodes, pathfinding via mmaps\n- [ ] 🤖 **0.6 - Automation:** Scriptable command sequences and event\n      subscriptions\n\n## Feature coverage\n\nBased on the list of all possible opcodes. Might still be missing some things\nthat the official game client does.\n\n### 🔐 Authentication\n\n| Feature               | Status |\n| --------------------- | ------ |\n| SRP-6 login           | ✅     |\n| Reconnect proof       | ✅     |\n| Realm selection       | ✅     |\n| Character select      | ✅     |\n| Arc4 encryption       | ✅     |\n| Keepalive / time sync | ✅     |\n| Warden anticheat      | ❌     |\n\n### 💬 Chat\n\n| Feature                                 | Status |\n| --------------------------------------- | ------ |\n| Say, yell                               | ✅     |\n| Whisper (`/w`, `/r`)                    | ✅     |\n| Guild, officer                          | ✅     |\n| Party, raid                             | ✅     |\n| Channels (`/1`, `/2`, …)                | ✅     |\n| MOTD                                    | ✅     |\n| Server broadcast messages               | ❌     |\n| Chat restricted / wrong faction notices | ❌     |\n| Text emotes (`/e`, `/emote`)            | ❌     |\n| DND / AFK status                        | ❌     |\n\n### 👥 Social\n\n| Feature                              | Status |\n| ------------------------------------ | ------ |\n| Who search                           | ✅     |\n| Party invite / kick / leave / leader | ✅     |\n| Group roster + member stats          | ✅     |\n| Friends list                         | ✅     |\n| Ignore list                          | ❌     |\n| Channel join / leave                 | ❌     |\n| Duel accept / decline                | ❌     |\n\n### 🏰 Guild\n\n| Feature                               | Status |\n| ------------------------------------- | ------ |\n| Guild chat                            | ✅     |\n| Guild roster                          | ❌     |\n| Guild events                          | ❌     |\n| Guild invite / kick / leave / promote | ❌     |\n| Guild bank                            | ❌     |\n\n### ✉️ Mail\n\n| Feature             | Status |\n| ------------------- | ------ |\n| Send / receive mail | ❌     |\n| Mail notifications  | ❌     |\n\n### 🏪 Economy\n\n| Feature       | Status |\n| ------------- | ------ |\n| Auction house | ❌     |\n| Vendors       | ❌     |\n| Trade         | ❌     |\n\n### 🌍 World\n\n| Feature           | Status |\n| ----------------- | ------ |\n| Object updates    | ✅     |\n| Movement          | ❌     |\n| Spells / auras    | ❌     |\n| Combat log        | ❌     |\n| Loot              | ❌     |\n| Items / inventory | ❌     |\n\n### 📜 PvE\n\n| Feature              | Status |\n| -------------------- | ------ |\n| Quests               | ❌     |\n| NPC gossip           | ❌     |\n| Trainers             | ❌     |\n| Taxi                 | ❌     |\n| Instances / dungeons | ❌     |\n\n### ⚔️ PvP\n\n| Feature               | Status |\n| --------------------- | ------ |\n| Battlegrounds         | ❌     |\n| Arena                 | ❌     |\n| Random roll (`/roll`) | ❌     |\n\n### 📊 Progression\n\n| Feature              | Status |\n| -------------------- | ------ |\n| Achievements         | ❌     |\n| Talents              | ❌     |\n| LFG / dungeon finder | ❌     |\n| Calendar             | ❌     |\n\n## Prior art\n\n- [swiftmatt/wow-chat-client](https://github.com/swiftmatt/wow-chat-client) -\n  Node.js WoW 3.3.5a chat client, primary reference for packet formats and\n  SRP-6 auth flow\n- [azerothcore/azerothcore-wotlk](https://github.com/azerothcore/azerothcore-wotlk) -\n  open-source WoW 3.3.5a server emulator, used as the canonical reference for\n  handler implementations and update field definitions\n- [mod-playerbots/mod-playerbots](https://github.com/mod-playerbots/mod-playerbots) -\n  AzerothCore playerbot module, the target server environment for tuicraft\n- [wowserhq/wowser](https://github.com/wowserhq/wowser) - browser-based WoW\n  3.3.5a client in JS/React/WebGL, useful for cross-referencing opcodes, auth\n  error codes, and realm parsing\n- [gtker/wow_messages](https://github.com/gtker/wow_messages) - auto-generated\n  WoW protocol definitions in `.wowm` format, machine-readable spec for every\n  opcode across Vanilla/TBC/WotLK\n- [namreeb/namigator](https://github.com/namreeb/namigator) - C++ pathfinding\n  and line-of-sight library for WoW, reads MPQ files and generates navmesh via\n  Recast/Detour\n- [gtker/namigator-rs](https://github.com/gtker/namigator-rs) - Rust FFI\n  bindings for namigator, API reference for the pathfinding integration\n\n## License\n\n[AGPLv3](LICENSE).\n","structuredPatch":[{"oldStart":140,"oldLines":7,"newStart":140,"newLines":7,"lines":[" | MOTD                                    | ✅     |"," | Server broadcast messages               | ❌     |"," | Chat restricted / wrong faction notices | ❌     |","-| Text emotes (`/e`, `/emote`)            | ❌     |","+| Text emotes (`/e`, `/emote`)            | ✅     |"," | DND / AFK status                        | ❌     |"," "," ### 👥 Social"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ace3d297-f2dc-4f93-a7cd-4029563bda04"}
{"parentUuid":"ae7b763f-53e1-40ea-acee-2e34fda8c93d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01XkoDx4TeAxYjaheWagZ7fq","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `manual.md`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":102839,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":193},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMnk3u7848ra9CfL9Zw","type":"assistant","uuid":"e248c2bf-9c9b-4ea4-a626-65400eb7354a","timestamp":"2026-02-28T23:47:03.572Z"}
{"parentUuid":"e248c2bf-9c9b-4ea4-a626-65400eb7354a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01XkoDx4TeAxYjaheWagZ7fq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W96C9Wd4XVALiJsXwS2muK","name":"Grep","input":{"pattern":"/raid|/say|/yell|interactive|INTERACTIVE|slash.*command|TUI.*mode","path":"/home/openclaw/code/tuicraft/docs/manual.md","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":102839,"output_tokens":152,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":193,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMnk3u7848ra9CfL9Zw","type":"assistant","uuid":"2af34dd4-5ed4-41c9-bdf0-5aa9d2768d80","timestamp":"2026-02-28T23:47:05.503Z"}
{"parentUuid":"2af34dd4-5ed4-41c9-bdf0-5aa9d2768d80","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W96C9Wd4XVALiJsXwS2muK","type":"tool_result","content":"18-## Description\n19-\n20-tuicraft is a single binary that connects to a WoW 3.3.5a server as a player\n21:character. It runs in three modes: interactive TUI (no args), background daemon\n22-(`--daemon`), or one-shot CLI client (subcommands and flags).\n23-\n24-CLI commands auto-start a background daemon that holds the WoW connection and\n--\n29-## Commands\n30-\n31-`tuicraft`\n32:: Interactive TUI with a readline prompt. Type slash commands or plain text.\n33-\n34-`tuicraft` _message_\n35-: Send a say message. Auto-starts the daemon if needed.\n36-\n37-`tuicraft setup` [*flags*]\n38:: Configure account credentials. With no flags, runs an interactive wizard.\n39-\n40-`tuicraft read` [`--wait` *N*] [`--json`]\n41-: Read buffered events. `--wait` polls for _N_ seconds before returning.\n--\n109-\n110-## Interactive Commands\n111-\n112:When running in TUI mode, the following slash commands are available:\n113-\n114-| Command                      | Action                      |\n115-| ---------------------------- | --------------------------- |\n--\n120-| `/r` _msg_                   | Reply to last whisper       |\n121-| `/g` _msg_                   | Guild chat                  |\n122-| `/p` _msg_                   | Party chat                  |\n123:| `/raid` _msg_                | Raid chat                   |\n124-| `/1` _msg_                   | Channel 1 (usually General) |\n125-| `/2` _msg_                   | Channel 2 (usually Trade)   |\n126-| `/who` _query_               | Who search                  |"}]},"uuid":"f6a6a1ff-7ac2-41d8-9912-85c260ef829a","timestamp":"2026-02-28T23:47:05.585Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"18-## Description\n19-\n20-tuicraft is a single binary that connects to a WoW 3.3.5a server as a player\n21:character. It runs in three modes: interactive TUI (no args), background daemon\n22-(`--daemon`), or one-shot CLI client (subcommands and flags).\n23-\n24-CLI commands auto-start a background daemon that holds the WoW connection and\n--\n29-## Commands\n30-\n31-`tuicraft`\n32:: Interactive TUI with a readline prompt. Type slash commands or plain text.\n33-\n34-`tuicraft` _message_\n35-: Send a say message. Auto-starts the daemon if needed.\n36-\n37-`tuicraft setup` [*flags*]\n38:: Configure account credentials. With no flags, runs an interactive wizard.\n39-\n40-`tuicraft read` [`--wait` *N*] [`--json`]\n41-: Read buffered events. `--wait` polls for _N_ seconds before returning.\n--\n109-\n110-## Interactive Commands\n111-\n112:When running in TUI mode, the following slash commands are available:\n113-\n114-| Command                      | Action                      |\n115-| ---------------------------- | --------------------------- |\n--\n120-| `/r` _msg_                   | Reply to last whisper       |\n121-| `/g` _msg_                   | Guild chat                  |\n122-| `/p` _msg_                   | Party chat                  |\n123:| `/raid` _msg_                | Raid chat                   |\n124-| `/1` _msg_                   | Channel 1 (usually General) |\n125-| `/2` _msg_                   | Channel 2 (usually Trade)   |\n126-| `/who` _query_               | Who search                  |","numLines":37},"sourceToolAssistantUUID":"2af34dd4-5ed4-41c9-bdf0-5aa9d2768d80"}
{"parentUuid":"f6a6a1ff-7ac2-41d8-9912-85c260ef829a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_0143mwEJA5xGPSVwAnqCYaqP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TsbPGP8fV32E3eXXfRMbyn","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/docs/manual.md","offset":114,"limit":25},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":603,"cache_read_input_tokens":103032,"output_tokens":103,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":603,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMo6dABosiGWLNtEDSc","type":"assistant","uuid":"f8001f4d-76f6-4375-abc8-38be80331998","timestamp":"2026-02-28T23:47:10.798Z"}
{"parentUuid":"f8001f4d-76f6-4375-abc8-38be80331998","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TsbPGP8fV32E3eXXfRMbyn","type":"tool_result","content":"   114→| Command                      | Action                      |\n   115→| ---------------------------- | --------------------------- |\n   116→| _text_                       | Say (no slash needed)       |\n   117→| `/s` _msg_                   | Say (explicit)              |\n   118→| `/y` _msg_                   | Yell                        |\n   119→| `/w` _name_ _msg_            | Whisper                     |\n   120→| `/r` _msg_                   | Reply to last whisper       |\n   121→| `/g` _msg_                   | Guild chat                  |\n   122→| `/p` _msg_                   | Party chat                  |\n   123→| `/raid` _msg_                | Raid chat                   |\n   124→| `/1` _msg_                   | Channel 1 (usually General) |\n   125→| `/2` _msg_                   | Channel 2 (usually Trade)   |\n   126→| `/who` _query_               | Who search                  |\n   127→| `/invite` _name_             | Invite player to group      |\n   128→| `/kick` _name_               | Remove player from group    |\n   129→| `/leave`                     | Leave the current group     |\n   130→| `/leader` _name_             | Transfer group leadership   |\n   131→| `/accept`                    | Accept a group invitation   |\n   132→| `/decline`                   | Decline a group invitation  |\n   133→| `/friends`                   | Show your friends list      |\n   134→| `/friend add` _name_         | Add a player to friends     |\n   135→| `/friend remove` _name_      | Remove from friends         |\n   136→| `/tuicraft entities on\\|off` | Toggle entity event display |\n   137→| `/quit`                      | Disconnect and exit         |\n   138→"}]},"uuid":"f6311440-4e89-4213-b48e-6c8851b6f8ff","timestamp":"2026-02-28T23:47:10.800Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/docs/manual.md","content":"| Command                      | Action                      |\n| ---------------------------- | --------------------------- |\n| _text_                       | Say (no slash needed)       |\n| `/s` _msg_                   | Say (explicit)              |\n| `/y` _msg_                   | Yell                        |\n| `/w` _name_ _msg_            | Whisper                     |\n| `/r` _msg_                   | Reply to last whisper       |\n| `/g` _msg_                   | Guild chat                  |\n| `/p` _msg_                   | Party chat                  |\n| `/raid` _msg_                | Raid chat                   |\n| `/1` _msg_                   | Channel 1 (usually General) |\n| `/2` _msg_                   | Channel 2 (usually Trade)   |\n| `/who` _query_               | Who search                  |\n| `/invite` _name_             | Invite player to group      |\n| `/kick` _name_               | Remove player from group    |\n| `/leave`                     | Leave the current group     |\n| `/leader` _name_             | Transfer group leadership   |\n| `/accept`                    | Accept a group invitation   |\n| `/decline`                   | Decline a group invitation  |\n| `/friends`                   | Show your friends list      |\n| `/friend add` _name_         | Add a player to friends     |\n| `/friend remove` _name_      | Remove from friends         |\n| `/tuicraft entities on\\|off` | Toggle entity event display |\n| `/quit`                      | Disconnect and exit         |\n","numLines":25,"startLine":114,"totalLines":207}},"sourceToolAssistantUUID":"f8001f4d-76f6-4375-abc8-38be80331998"}
{"parentUuid":"f6311440-4e89-4213-b48e-6c8851b6f8ff","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01WVRpG3mZU52uEnxUSBj3NP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gphksobyqa7XG81Pvbz8Jm","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/docs/manual.md","old_string":"| `/raid` _msg_                | Raid chat                   |\n| `/1` _msg_                   | Channel 1 (usually General) |","new_string":"| `/raid` _msg_                | Raid chat                   |\n| `/e` _msg_                   | Text emote                  |\n| `/1` _msg_                   | Channel 1 (usually General) |"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":570,"cache_read_input_tokens":103635,"output_tokens":211,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":570,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMoV436fFJtJETLSVDB","type":"assistant","uuid":"f825f013-5c70-4c4f-bf19-e6d270391d08","timestamp":"2026-02-28T23:47:15.049Z"}
{"parentUuid":"f825f013-5c70-4c4f-bf19-e6d270391d08","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gphksobyqa7XG81Pvbz8Jm","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/docs/manual.md has been updated successfully."}]},"uuid":"f1228655-5576-4bdc-99f7-a86c204dea7f","timestamp":"2026-02-28T23:47:15.057Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/docs/manual.md","oldString":"| `/raid` _msg_                | Raid chat                   |\n| `/1` _msg_                   | Channel 1 (usually General) |","newString":"| `/raid` _msg_                | Raid chat                   |\n| `/e` _msg_                   | Text emote                  |\n| `/1` _msg_                   | Channel 1 (usually General) |","originalFile":"# tuicraft(1)\n\nWoW 3.3.5a chat client\n\n## Synopsis\n\n```\ntuicraft\ntuicraft <message>\ntuicraft [-w <name> | -y | -g | -p] <message>\ntuicraft [--who [filter]] [--json]\ntuicraft setup [--account NAME] [--password PASS] [--character NAME]\ntuicraft read [--wait N] [--json]\ntuicraft tail [--json]\ntuicraft status | stop | logs | skill | help\n```\n\n## Description\n\ntuicraft is a single binary that connects to a WoW 3.3.5a server as a player\ncharacter. It runs in three modes: interactive TUI (no args), background daemon\n(`--daemon`), or one-shot CLI client (subcommands and flags).\n\nCLI commands auto-start a background daemon that holds the WoW connection and\nbuffers events in a ring buffer. The daemon listens on a unix domain socket. CLI\nclients connect, send one command, read the response, and disconnect. The daemon\nidles out after 30 minutes of inactivity.\n\n## Commands\n\n`tuicraft`\n: Interactive TUI with a readline prompt. Type slash commands or plain text.\n\n`tuicraft` _message_\n: Send a say message. Auto-starts the daemon if needed.\n\n`tuicraft setup` [*flags*]\n: Configure account credentials. With no flags, runs an interactive wizard.\n\n`tuicraft read` [`--wait` *N*] [`--json`]\n: Read buffered events. `--wait` polls for _N_ seconds before returning.\n\n`tuicraft tail` [`--json`]\n: Continuous event stream. Blocks and prints events as they arrive.\n\n`tuicraft status`\n: Print daemon connection status (`CONNECTED` or error).\n\n`tuicraft stop`\n: Graceful daemon shutdown.\n\n`tuicraft logs`\n: Print the JSONL session log to stdout.\n\n`tuicraft skill`\n: Print a SKILL.md reference for AI agents. Includes command usage, event types, and integration examples.\n\n`tuicraft help`\n: Print usage summary.\n\n## Chat Flags\n\n`-w` _name_ _message_\n: Whisper to a player.\n\n`-y` _message_\n: Yell.\n\n`-g` _message_\n: Guild chat.\n\n`-p` _message_\n: Party chat.\n\n`--who` [*filter*]\n: Who query. Optional name/class/level filter.\n\n## Options\n\n`--json`\n: Output events as JSONL instead of human-readable format. Works with `read`,\n`tail`, `--who`, and chat commands.\n\n`--wait` _N_\n: Wait _N_ seconds for events before returning. For use with `read`.\n\n`--help`\n: Print usage summary.\n\n`--daemon`\n: Start as background daemon. Internal — not meant to be called directly.\n\n## Setup Flags\n\n`--account` _NAME_\n: Account name (required).\n\n`--password` _PASS_\n: Account password (required).\n\n`--character` _NAME_\n: Character name (required).\n\n`--host` _HOST_\n: Auth server hostname. Default: `t1`.\n\n`--port` _PORT_\n: Auth server port. Default: `3724`.\n\n## Interactive Commands\n\nWhen running in TUI mode, the following slash commands are available:\n\n| Command                      | Action                      |\n| ---------------------------- | --------------------------- |\n| _text_                       | Say (no slash needed)       |\n| `/s` _msg_                   | Say (explicit)              |\n| `/y` _msg_                   | Yell                        |\n| `/w` _name_ _msg_            | Whisper                     |\n| `/r` _msg_                   | Reply to last whisper       |\n| `/g` _msg_                   | Guild chat                  |\n| `/p` _msg_                   | Party chat                  |\n| `/raid` _msg_                | Raid chat                   |\n| `/1` _msg_                   | Channel 1 (usually General) |\n| `/2` _msg_                   | Channel 2 (usually Trade)   |\n| `/who` _query_               | Who search                  |\n| `/invite` _name_             | Invite player to group      |\n| `/kick` _name_               | Remove player from group    |\n| `/leave`                     | Leave the current group     |\n| `/leader` _name_             | Transfer group leadership   |\n| `/accept`                    | Accept a group invitation   |\n| `/decline`                   | Decline a group invitation  |\n| `/friends`                   | Show your friends list      |\n| `/friend add` _name_         | Add a player to friends     |\n| `/friend remove` _name_      | Remove from friends         |\n| `/tuicraft entities on\\|off` | Toggle entity event display |\n| `/quit`                      | Disconnect and exit         |\n\n## Output Format\n\nHuman-readable (default):\n\n```\n[say] Xi: hello world\n[whisper from Xiara] Following Deity\n[guild] Xiara: heading out\n[who] 3 results: Xiara (80), Hemet (74), Sanu (14)\n[group] Voidtrix invites you to a group\n[group] Xia is now the group leader\n[world] Young Wolf appeared (NPC, level 6)\n[world] Young Wolf left range\n[friends] 2/3 online — Arthas — Online, Level 80 Death Knight | Jaina — AFK\n[friends] Arthas is now online (Level 80 Death Knight)\n```\n\nJSONL (`--json`):\n\n```jsonl\n{\"type\":\"SAY\",\"sender\":\"Xi\",\"message\":\"hello world\"}\n{\"type\":\"WHISPER_FROM\",\"sender\":\"Xiara\",\"message\":\"Following Deity\"}\n```\n\n## Files\n\n`~/.config/tuicraft/config.toml`\n: Account credentials and settings.\n\n`$TMPDIR/tuicraft-<uid>/sock`\n: Daemon unix domain socket.\n\n`$TMPDIR/tuicraft-<uid>/pid`\n: Daemon pidfile.\n\n`~/.local/state/tuicraft/session.log`\n: Persistent JSONL session log.\n\n## Examples\n\nFirst-time setup:\n\n```sh\ntuicraft setup --account XI --password pass --character Xi\n```\n\nSend a message and read the response:\n\n```sh\ntuicraft \"hello world\"\ntuicraft read --wait 3\n```\n\nScript integration:\n\n```sh\ntuicraft \"follow me\"\ntuicraft read --wait 3 --json | jq .\ntuicraft --who mage --json\n```\n\n## Notes\n\nHorde characters use Orcish (language 1) by default. Alliance characters should\nset `language = 7` in the config file.\n\nThe daemon buffers up to 1000 events. The idle timeout is configurable via\n`timeout_minutes` in the config file.\n","structuredPatch":[{"oldStart":121,"oldLines":6,"newStart":121,"newLines":7,"lines":[" | `/g` _msg_                   | Guild chat                  |"," | `/p` _msg_                   | Party chat                  |"," | `/raid` _msg_                | Raid chat                   |","+| `/e` _msg_                   | Text emote                  |"," | `/1` _msg_                   | Channel 1 (usually General) |"," | `/2` _msg_                   | Channel 2 (usually Trade)   |"," | `/who` _query_               | Who search                  |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f825f013-5c70-4c4f-bf19-e6d270391d08"}
{"parentUuid":"f1228655-5576-4bdc-99f7-a86c204dea7f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01M4UAXvWTjfutQdZP8DGcQe","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `SKILL.md`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":246,"cache_read_input_tokens":104205,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":246},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMoocVfs7nzyPpNPkr7","type":"assistant","uuid":"1b13a8cb-4c25-4c25-8b00-dec52de183ea","timestamp":"2026-02-28T23:47:21.832Z"}
{"parentUuid":"1b13a8cb-4c25-4c25-8b00-dec52de183ea","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01M4UAXvWTjfutQdZP8DGcQe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017QRtiupuPncrVSn58ZvoqX","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","offset":14,"limit":30},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":246,"cache_read_input_tokens":104205,"output_tokens":119,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":246,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMoocVfs7nzyPpNPkr7","type":"assistant","uuid":"299667c3-df95-420d-863d-eacde36ffcb1","timestamp":"2026-02-28T23:47:22.708Z"}
{"parentUuid":"299667c3-df95-420d-863d-eacde36ffcb1","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017QRtiupuPncrVSn58ZvoqX","type":"tool_result","content":"    14→Returns CONNECTED or an error. Check this before other commands.\n    15→\n    16→## Sending Messages\n    17→\n    18→    tuicraft send \"message\"               # say (nearby players)\n    19→    tuicraft send -y \"message\"            # yell (wider range)\n    20→    tuicraft send -p \"message\"            # party chat\n    21→    tuicraft send -g \"message\"            # guild chat\n    22→    tuicraft send -w PlayerName \"message\" # whisper to player\n    23→\n    24→Slash commands work too:\n    25→\n    26→    tuicraft send \"/raid message\"         # raid chat\n    27→    tuicraft send \"/1 message\"            # channel 1\n    28→    tuicraft send \"/2 message\"            # channel 2\n    29→\n    30→## Reading Events\n    31→\n    32→    tuicraft read                  # buffered events since last read\n    33→    tuicraft read --wait 5         # wait 5 seconds, then return events\n    34→    tuicraft tail                  # continuous stream (blocks)\n    35→\n    36→Add `--json` for structured output. Each JSON line:\n    37→\n    38→    {\"type\":\"PARTY\",\"sender\":\"PlayerName\",\"message\":\"hello\"}\n    39→\n    40→## Event Types\n    41→\n    42→| Type             | Meaning                                          |\n    43→| ---------------- | ------------------------------------------------ |"}]},"uuid":"3220b09f-36de-4798-8698-4cd2dee66c77","timestamp":"2026-02-28T23:47:22.710Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","content":"Returns CONNECTED or an error. Check this before other commands.\n\n## Sending Messages\n\n    tuicraft send \"message\"               # say (nearby players)\n    tuicraft send -y \"message\"            # yell (wider range)\n    tuicraft send -p \"message\"            # party chat\n    tuicraft send -g \"message\"            # guild chat\n    tuicraft send -w PlayerName \"message\" # whisper to player\n\nSlash commands work too:\n\n    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/1 message\"            # channel 1\n    tuicraft send \"/2 message\"            # channel 2\n\n## Reading Events\n\n    tuicraft read                  # buffered events since last read\n    tuicraft read --wait 5         # wait 5 seconds, then return events\n    tuicraft tail                  # continuous stream (blocks)\n\nAdd `--json` for structured output. Each JSON line:\n\n    {\"type\":\"PARTY\",\"sender\":\"PlayerName\",\"message\":\"hello\"}\n\n## Event Types\n\n| Type             | Meaning                                          |\n| ---------------- | ------------------------------------------------ |","numLines":30,"startLine":14,"totalLines":134}},"sourceToolAssistantUUID":"299667c3-df95-420d-863d-eacde36ffcb1"}
{"parentUuid":"3220b09f-36de-4798-8698-4cd2dee66c77","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_013GvEQV7AEQNNTEJihd89o2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011HCc3zznkJdw2KJK5yahc6","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","old_string":"    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/1 message\"            # channel 1","new_string":"    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/e waves hello\"        # text emote\n    tuicraft send \"/1 message\"            # channel 1"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":718,"cache_read_input_tokens":104451,"output_tokens":205,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":718,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMpMxfzoBBq25gmgo9e","type":"assistant","uuid":"1929fc40-56cc-4400-b437-6961a012a586","timestamp":"2026-02-28T23:47:27.810Z"}
{"parentUuid":"1929fc40-56cc-4400-b437-6961a012a586","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011HCc3zznkJdw2KJK5yahc6","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md has been updated successfully."}]},"uuid":"48362d23-cfff-489c-92d5-f5284ac639e6","timestamp":"2026-02-28T23:47:27.828Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","oldString":"    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/1 message\"            # channel 1","newString":"    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/e waves hello\"        # text emote\n    tuicraft send \"/1 message\"            # channel 1","originalFile":"---\nname: tuicraft\ndescription: Use when interacting with a WoW 3.3.5a game world — sending chat messages, reading events, querying players, or managing groups via the tuicraft CLI\n---\n\n# tuicraft\n\nCLI client for World of Warcraft 3.3.5a. A background daemon maintains the game connection and buffers events. The daemon starts automatically on first use and stays running for 30 minutes of inactivity.\n\n## Status\n\n    tuicraft status\n\nReturns CONNECTED or an error. Check this before other commands.\n\n## Sending Messages\n\n    tuicraft send \"message\"               # say (nearby players)\n    tuicraft send -y \"message\"            # yell (wider range)\n    tuicraft send -p \"message\"            # party chat\n    tuicraft send -g \"message\"            # guild chat\n    tuicraft send -w PlayerName \"message\" # whisper to player\n\nSlash commands work too:\n\n    tuicraft send \"/raid message\"         # raid chat\n    tuicraft send \"/1 message\"            # channel 1\n    tuicraft send \"/2 message\"            # channel 2\n\n## Reading Events\n\n    tuicraft read                  # buffered events since last read\n    tuicraft read --wait 5         # wait 5 seconds, then return events\n    tuicraft tail                  # continuous stream (blocks)\n\nAdd `--json` for structured output. Each JSON line:\n\n    {\"type\":\"PARTY\",\"sender\":\"PlayerName\",\"message\":\"hello\"}\n\n## Event Types\n\n| Type             | Meaning                                          |\n| ---------------- | ------------------------------------------------ |\n| SAY              | Nearby /say chat                                 |\n| YELL             | /yell chat                                       |\n| PARTY            | Party member message                             |\n| PARTY_LEADER     | Party leader message                             |\n| GUILD            | Guild chat                                       |\n| OFFICER          | Officer chat                                     |\n| RAID             | Raid chat                                        |\n| RAID_LEADER      | Raid leader message                              |\n| RAID_WARNING     | Raid warning                                     |\n| WHISPER          | Incoming whisper                                 |\n| WHISPER_TO       | Outgoing whisper confirmation                    |\n| CHANNEL          | Custom channel message                           |\n| EMOTE            | Player emote                                     |\n| SYSTEM           | System messages and unimplemented packet notices |\n| ENTITY_APPEAR    | NPC/player/object appeared nearby (--json only)  |\n| ENTITY_DISAPPEAR | Entity left range (--json only)                  |\n| ENTITY_UPDATE    | Entity field changed (--json only)               |\n| FRIEND_ONLINE    | Friend came online                               |\n| FRIEND_OFFLINE   | Friend went offline                              |\n| FRIEND_ADDED     | Friend added to list                             |\n| FRIEND_REMOVED   | Friend removed from list                         |\n| FRIEND_ERROR     | Friend operation error                           |\n\nThe `channel` field appears on CHANNEL events only.\n\nEntity events include `guid`, `objectType`, `name`, and type-specific fields like `level`, `health`, `maxHealth`, `x`, `y`, `z`.\n\n## Who Queries\n\n    tuicraft who              # all online players\n    tuicraft who \"warrior\"    # filter by name/class/etc\n\n## Group Commands\n\n    tuicraft send \"/invite PlayerName\"   # invite to group\n    tuicraft send \"/kick PlayerName\"     # remove from group\n    tuicraft send \"/leave\"               # leave group\n    tuicraft send \"/leader PlayerName\"   # transfer leadership\n    tuicraft send \"/accept\"              # accept group invite\n    tuicraft send \"/decline\"             # decline group invite\n\n## Friends List\n\n    tuicraft send \"/friends\"                # show friends list\n    tuicraft send \"/friend add PlayerName\"  # add friend\n    tuicraft send \"/friend remove PlayerName\" # remove friend\n\nIPC verbs:\n\n    echo \"FRIENDS\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n    echo \"FRIENDS_JSON\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n    echo \"ADD_FRIEND PlayerName\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n    echo \"DEL_FRIEND PlayerName\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n\n## Entity Queries\n\nThe daemon exposes `NEARBY` and `NEARBY_JSON` IPC verbs for querying tracked entities:\n\n    echo \"NEARBY\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n    echo \"NEARBY_JSON\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n\nIn the TUI, toggle entity event display with `/tuicraft entities on|off`.\n\n## Openclaw Integration\n\nComplete example: forward party chat to an openclaw agent, filtering out the\nagent's own character to prevent feedback loops. Each agent turn runs in the\nbackground so the pipeline doesn't block.\n\n    tuicraft tail --json \\\n      | jq -r --unbuffered '\n          select((.type == \"PARTY\" or .type == \"PARTY_LEADER\")\n            and .sender != \"Xia\")\n          | \"\\(.sender): \\(.message)\"' \\\n      | while IFS= read -r line; do\n          openclaw agent --agent x \\\n            --message \"$line\" \\\n            </dev/null >/dev/null 2>&1 &\n        done\n\nReplace `Xia` with the agent's WoW character name and `x` with the openclaw\nagent id. The agent can respond in-game with `tuicraft send -p \"message\"`.\n\nTo watch different event types, change the jq `select` filter:\n\n| Filter               | Events                         |\n| -------------------- | ------------------------------ |\n| `.type == \"WHISPER\"` | Incoming whispers only         |\n| `.type == \"GUILD\"`   | Guild chat only                |\n| `.type != \"SYSTEM\"`  | Everything except system noise |\n","structuredPatch":[{"oldStart":24,"oldLines":6,"newStart":24,"newLines":7,"lines":[" Slash commands work too:"," ","     tuicraft send \"/raid message\"         # raid chat","+    tuicraft send \"/e waves hello\"        # text emote","     tuicraft send \"/1 message\"            # channel 1","     tuicraft send \"/2 message\"            # channel 2"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1929fc40-56cc-4400-b437-6961a012a586"}
{"parentUuid":"48362d23-cfff-489c-92d5-f5284ac639e6","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01YL5W93vECeRiaZDxUVC1BG","type":"message","role":"assistant","content":[{"type":"text","text":"Also need to check if `tuicraft send` CLI supports emote via a flag or slash command. Let me check the send command handler."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":247,"cache_read_input_tokens":105169,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":247},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMpkBPyQShvAf9RL9x3","type":"assistant","uuid":"7457822d-7090-412b-84cc-38d1b2c8a17d","timestamp":"2026-02-28T23:47:32.125Z"}
{"parentUuid":"7457822d-7090-412b-84cc-38d1b2c8a17d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01YL5W93vECeRiaZDxUVC1BG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BU425aaHaRQsYUxa8M4bSL","name":"Grep","input":{"pattern":"send.*-y|send.*-g|send.*-p|send.*flag|yell.*flag","path":"/home/openclaw/code/tuicraft/src/cli","output_mode":"content","-C":3},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":247,"cache_read_input_tokens":105169,"output_tokens":173,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":247,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMpkBPyQShvAf9RL9x3","type":"assistant","uuid":"ec4fccdb-01e4-435c-a874-2c14dd04eb65","timestamp":"2026-02-28T23:47:33.947Z"}
{"parentUuid":"ec4fccdb-01e4-435c-a874-2c14dd04eb65","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BU425aaHaRQsYUxa8M4bSL","type":"tool_result","content":"/home/openclaw/code/tuicraft/src/cli/args.test.ts-130-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-131-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-132-\nsrc/cli/args.test.ts:133:  test(\"send -y = yell\", () => {\nsrc/cli/args.test.ts:134:    expect(parseArgs([\"send\", \"-y\", \"HELLO\"])).toEqual({\nsrc/cli/args.test.ts-135-      mode: \"yell\",\nsrc/cli/args.test.ts-136-      message: \"HELLO\",\nsrc/cli/args.test.ts-137-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-139-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-140-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-141-\nsrc/cli/args.test.ts:142:  test(\"send -g = guild\", () => {\nsrc/cli/args.test.ts:143:    expect(parseArgs([\"send\", \"-g\", \"guild msg\"])).toEqual({\nsrc/cli/args.test.ts-144-      mode: \"guild\",\nsrc/cli/args.test.ts-145-      message: \"guild msg\",\nsrc/cli/args.test.ts-146-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-148-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-149-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-150-\nsrc/cli/args.test.ts:151:  test(\"send -p = party\", () => {\nsrc/cli/args.test.ts:152:    expect(parseArgs([\"send\", \"-p\", \"party msg\"])).toEqual({\nsrc/cli/args.test.ts-153-      mode: \"party\",\nsrc/cli/args.test.ts-154-      message: \"party msg\",\nsrc/cli/args.test.ts-155-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-166-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-167-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-168-\nsrc/cli/args.test.ts:169:  test(\"send -y with --json\", () => {\nsrc/cli/args.test.ts:170:    expect(parseArgs([\"send\", \"-y\", \"--json\", \"hello\"])).toEqual({\nsrc/cli/args.test.ts-171-      mode: \"yell\",\nsrc/cli/args.test.ts-172-      message: \"hello\",\nsrc/cli/args.test.ts-173-      json: true,\n--\n/home/openclaw/code/tuicraft/src/cli/help.ts-6-  tuicraft setup [flags]      Configure account credentials\n/home/openclaw/code/tuicraft/src/cli/help.ts-7-  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n/home/openclaw/code/tuicraft/src/cli/help.ts-8-  tuicraft send -w <name> \"m\" Whisper a player\nsrc/cli/help.ts:9:  tuicraft send -y \"message\"  Yell\nsrc/cli/help.ts:10:  tuicraft send -g \"message\"  Guild chat\nsrc/cli/help.ts:11:  tuicraft send -p \"message\"  Party chat\n/home/openclaw/code/tuicraft/src/cli/help.ts-12-  tuicraft who [filter]       Who query\n/home/openclaw/code/tuicraft/src/cli/help.ts-13-  tuicraft read [--wait N]    Read buffered events\n/home/openclaw/code/tuicraft/src/cli/help.ts-14-  tuicraft tail               Continuous event stream"}]},"uuid":"60f999fe-1f1b-42d9-b434-0adf0f2f4b85","timestamp":"2026-02-28T23:47:34.033Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/openclaw/code/tuicraft/src/cli/args.test.ts-130-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-131-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-132-\nsrc/cli/args.test.ts:133:  test(\"send -y = yell\", () => {\nsrc/cli/args.test.ts:134:    expect(parseArgs([\"send\", \"-y\", \"HELLO\"])).toEqual({\nsrc/cli/args.test.ts-135-      mode: \"yell\",\nsrc/cli/args.test.ts-136-      message: \"HELLO\",\nsrc/cli/args.test.ts-137-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-139-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-140-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-141-\nsrc/cli/args.test.ts:142:  test(\"send -g = guild\", () => {\nsrc/cli/args.test.ts:143:    expect(parseArgs([\"send\", \"-g\", \"guild msg\"])).toEqual({\nsrc/cli/args.test.ts-144-      mode: \"guild\",\nsrc/cli/args.test.ts-145-      message: \"guild msg\",\nsrc/cli/args.test.ts-146-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-148-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-149-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-150-\nsrc/cli/args.test.ts:151:  test(\"send -p = party\", () => {\nsrc/cli/args.test.ts:152:    expect(parseArgs([\"send\", \"-p\", \"party msg\"])).toEqual({\nsrc/cli/args.test.ts-153-      mode: \"party\",\nsrc/cli/args.test.ts-154-      message: \"party msg\",\nsrc/cli/args.test.ts-155-      json: false,\n--\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-166-    });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-167-  });\n/home/openclaw/code/tuicraft/src/cli/args.test.ts-168-\nsrc/cli/args.test.ts:169:  test(\"send -y with --json\", () => {\nsrc/cli/args.test.ts:170:    expect(parseArgs([\"send\", \"-y\", \"--json\", \"hello\"])).toEqual({\nsrc/cli/args.test.ts-171-      mode: \"yell\",\nsrc/cli/args.test.ts-172-      message: \"hello\",\nsrc/cli/args.test.ts-173-      json: true,\n--\n/home/openclaw/code/tuicraft/src/cli/help.ts-6-  tuicraft setup [flags]      Configure account credentials\n/home/openclaw/code/tuicraft/src/cli/help.ts-7-  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n/home/openclaw/code/tuicraft/src/cli/help.ts-8-  tuicraft send -w <name> \"m\" Whisper a player\nsrc/cli/help.ts:9:  tuicraft send -y \"message\"  Yell\nsrc/cli/help.ts:10:  tuicraft send -g \"message\"  Guild chat\nsrc/cli/help.ts:11:  tuicraft send -p \"message\"  Party chat\n/home/openclaw/code/tuicraft/src/cli/help.ts-12-  tuicraft who [filter]       Who query\n/home/openclaw/code/tuicraft/src/cli/help.ts-13-  tuicraft read [--wait N]    Read buffered events\n/home/openclaw/code/tuicraft/src/cli/help.ts-14-  tuicraft tail               Continuous event stream","numLines":45},"sourceToolAssistantUUID":"ec4fccdb-01e4-435c-a874-2c14dd04eb65"}
{"parentUuid":"60f999fe-1f1b-42d9-b434-0adf0f2f4b85","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Js1yFbQvoZ9aKKMF7pE1fs","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The CLI `send` command supports `-y`, `-g`, `-p`, `-w` flags. Emote doesn't really need a dedicated flag since the user can use `tuicraft send \"/e waves hello\"` with slash commands. The user didn't ask for a CLI flag, and the other chat modes like raid also don't have a CLI flag. The slash command route is sufficient.\n\nNow let me also add the `EMOTE` uppercase command to the IPC help in SKILL.md if relevant, and also check if there's an \"EMOTE\" IPC command documented anywhere in the SKILL.md.","signature":"EpoFCkYICxgCKkCk3XZcyOud2qWSPmEpFzwLtuZl7d164VnZ+vqjGA1E5GlnokuyjeLNXTzAO9Js83H+rQLNSIPSWouMllUKfqvoEgyakVPj4r4VpNJ+WZAaDCsKsWlTkvfBjw3G+yIw2xmeQ5mcx1d8lHVA0yWwsLUUPB0QTMyk8S8Gf2hPnnrUqLED4mnDpQ7AoszmRMwYKoEEzWf4wKpZGMRCD54kGnxQKv/K5/rOrSWDrGXiOgX3qu4cAlluSi1CUaGS+aIaiFrd+Ii3NQB+eslUYJC7jI2Nk0kZ7V4n1BFGERF4Chy35L9UGx0mXMproMwbxV50rVjlvwT6NsCRPodTL8vuPrmS+kz3Ey8V8RsxuCYJG3tlA/v55cL7BzxFvUyX7Szvx7AdRv+hDt8a832tI3BcOF32cmxf51u9T56Yrmq0egOKsKkiI6I8Sv4qklV5rzLtv1Z6GL679H+JAR0ts+8HjCe7TRSRRssOMwlgnnNcUblVedcY5cRhoGBQSwKpukemq87bCHPstYTZajRCw9sOWqKgnk29MznSd5RLyvST4WwSFpFxgV0+520qNjqJWLZ8TIGedcKBLKy8eo1qzxmuNeaZnEGJeyf20QdLftEQImmclCUmDrA57f8jSzXoXHZh6LiVNlh82DJsO4q7kn0htjDlkJ2JyUuxunaOSsLykCtMJX1Ka+023YlP/D93bQ1HuzPdbLgfffPM5x5QvPWDe07YBo8ENA/i/KHlfLqE49W6114bO9E5HzvWIbCcR+v60saIXjlCmHOB31rPVgHwylfLfvErtVCrt+60d+x9V8fo32BbkCs6A9v8IjHzD5YlhsHHQKPPIiWVnegMlW95HqW9PMIoUjE8MdTKY4dv4ocFc7SkGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2232,"cache_read_input_tokens":105416,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2232},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMqCLWUEDg2PzEZnCMv","type":"assistant","uuid":"f21d1b06-8f70-48c1-810c-9f8c6de8ed27","timestamp":"2026-02-28T23:47:40.970Z"}
{"parentUuid":"f21d1b06-8f70-48c1-810c-9f8c6de8ed27","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Js1yFbQvoZ9aKKMF7pE1fs","type":"message","role":"assistant","content":[{"type":"text","text":"The CLI send command uses flags for common modes (`-y`, `-g`, `-p`, `-w`) but raid also only works via slash (`/raid`). Emote via slash (`/e`) is consistent. Let me check if the SKILL.md documents the IPC commands."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2232,"cache_read_input_tokens":105416,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2232},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMqCLWUEDg2PzEZnCMv","type":"assistant","uuid":"c46a0f9e-7720-45b6-8039-1a22a0134f2a","timestamp":"2026-02-28T23:47:42.952Z"}
{"parentUuid":"c46a0f9e-7720-45b6-8039-1a22a0134f2a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Js1yFbQvoZ9aKKMF7pE1fs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TRfapvgXknSJUi6WS6enKk","name":"Grep","input":{"pattern":"SAY|YELL|GUILD|PARTY|RAID|EMOTE|IPC","path":"/home/openclaw/code/tuicraft/.claude/skills/tuicraft/SKILL.md","output_mode":"content","-C":2},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2232,"cache_read_input_tokens":105416,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2232},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMqCLWUEDg2PzEZnCMv","type":"assistant","uuid":"60281cff-f074-4ed1-a3da-502d5963a254","timestamp":"2026-02-28T23:47:46.509Z"}
{"parentUuid":"60281cff-f074-4ed1-a3da-502d5963a254","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TRfapvgXknSJUi6WS6enKk","type":"tool_result","content":"37-Add `--json` for structured output. Each JSON line:\n38-\n39:    {\"type\":\"PARTY\",\"sender\":\"PlayerName\",\"message\":\"hello\"}\n40-\n41-## Event Types\n--\n43-| Type             | Meaning                                          |\n44-| ---------------- | ------------------------------------------------ |\n45:| SAY              | Nearby /say chat                                 |\n46:| YELL             | /yell chat                                       |\n47:| PARTY            | Party member message                             |\n48:| PARTY_LEADER     | Party leader message                             |\n49:| GUILD            | Guild chat                                       |\n50-| OFFICER          | Officer chat                                     |\n51:| RAID             | Raid chat                                        |\n52:| RAID_LEADER      | Raid leader message                              |\n53:| RAID_WARNING     | Raid warning                                     |\n54-| WHISPER          | Incoming whisper                                 |\n55-| WHISPER_TO       | Outgoing whisper confirmation                    |\n56-| CHANNEL          | Custom channel message                           |\n57:| EMOTE            | Player emote                                     |\n58-| SYSTEM           | System messages and unimplemented packet notices |\n59-| ENTITY_APPEAR    | NPC/player/object appeared nearby (--json only)  |\n--\n90-    tuicraft send \"/friend remove PlayerName\" # remove friend\n91-\n92:IPC verbs:\n93-\n94-    echo \"FRIENDS\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n--\n99-## Entity Queries\n100-\n101:The daemon exposes `NEARBY` and `NEARBY_JSON` IPC verbs for querying tracked entities:\n102-\n103-    echo \"NEARBY\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n--\n114-    tuicraft tail --json \\\n115-      | jq -r --unbuffered '\n116:          select((.type == \"PARTY\" or .type == \"PARTY_LEADER\")\n117-            and .sender != \"Xia\")\n118-          | \"\\(.sender): \\(.message)\"' \\\n--\n131-| -------------------- | ------------------------------ |\n132-| `.type == \"WHISPER\"` | Incoming whispers only         |\n133:| `.type == \"GUILD\"`   | Guild chat only                |\n134-| `.type != \"SYSTEM\"`  | Everything except system noise |"}]},"uuid":"dbde0579-2757-44c5-920c-8db7670915c8","timestamp":"2026-02-28T23:47:46.590Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"37-Add `--json` for structured output. Each JSON line:\n38-\n39:    {\"type\":\"PARTY\",\"sender\":\"PlayerName\",\"message\":\"hello\"}\n40-\n41-## Event Types\n--\n43-| Type             | Meaning                                          |\n44-| ---------------- | ------------------------------------------------ |\n45:| SAY              | Nearby /say chat                                 |\n46:| YELL             | /yell chat                                       |\n47:| PARTY            | Party member message                             |\n48:| PARTY_LEADER     | Party leader message                             |\n49:| GUILD            | Guild chat                                       |\n50-| OFFICER          | Officer chat                                     |\n51:| RAID             | Raid chat                                        |\n52:| RAID_LEADER      | Raid leader message                              |\n53:| RAID_WARNING     | Raid warning                                     |\n54-| WHISPER          | Incoming whisper                                 |\n55-| WHISPER_TO       | Outgoing whisper confirmation                    |\n56-| CHANNEL          | Custom channel message                           |\n57:| EMOTE            | Player emote                                     |\n58-| SYSTEM           | System messages and unimplemented packet notices |\n59-| ENTITY_APPEAR    | NPC/player/object appeared nearby (--json only)  |\n--\n90-    tuicraft send \"/friend remove PlayerName\" # remove friend\n91-\n92:IPC verbs:\n93-\n94-    echo \"FRIENDS\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n--\n99-## Entity Queries\n100-\n101:The daemon exposes `NEARBY` and `NEARBY_JSON` IPC verbs for querying tracked entities:\n102-\n103-    echo \"NEARBY\" | nc -U $TMPDIR/tuicraft-$(id -u)/sock\n--\n114-    tuicraft tail --json \\\n115-      | jq -r --unbuffered '\n116:          select((.type == \"PARTY\" or .type == \"PARTY_LEADER\")\n117-            and .sender != \"Xia\")\n118-          | \"\\(.sender): \\(.message)\"' \\\n--\n131-| -------------------- | ------------------------------ |\n132-| `.type == \"WHISPER\"` | Incoming whispers only         |\n133:| `.type == \"GUILD\"`   | Guild chat only                |\n134-| `.type != \"SYSTEM\"`  | Everything except system noise |","numLines":46},"sourceToolAssistantUUID":"60281cff-f074-4ed1-a3da-502d5963a254"}
{"parentUuid":"dbde0579-2757-44c5-920c-8db7670915c8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_012cB2XwK9Dhckn1rsJi5rQT","type":"message","role":"assistant","content":[{"type":"text","text":"Good — `EMOTE` is already listed in the event types table. The SKILL.md is up to date with the slash command example I added. Let me run the full CI to verify everything passes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":981,"cache_read_input_tokens":107648,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":981},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMr8enKbgGimYUFjrDV","type":"assistant","uuid":"0f58c56a-9b24-424c-bceb-0dde569df7fd","timestamp":"2026-02-28T23:47:50.763Z"}
{"parentUuid":"0f58c56a-9b24-424c-bceb-0dde569df7fd","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_012cB2XwK9Dhckn1rsJi5rQT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011ezpz7YocceKNJyphDWcuz","name":"Bash","input":{"command":"mise ci 2>&1","description":"Run typecheck, test, and format in parallel","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":981,"cache_read_input_tokens":107648,"output_tokens":146,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":981,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMr8enKbgGimYUFjrDV","type":"assistant","uuid":"c5e2a500-922c-460e-8d97-a87a0aaa104b","timestamp":"2026-02-28T23:47:51.653Z"}
{"parentUuid":"c5e2a500-922c-460e-8d97-a87a0aaa104b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011ezpz7YocceKNJyphDWcuz","type":"tool_result","content":"[ci] $ mise typecheck ::: test ::: format\n[typecheck] $ bun run typecheck\n[test] $ bun test\n[format] $ bunx prettier --check src/\n[test] bun test v1.3.9 (cf6cdbbb)\n[typecheck] $ tsc --noEmit\n[format] Checking formatting...\n[test] \n[test]  825 pass\n[test]  0 fail\n[test]  2149 expect() calls\n[test] Ran 825 tests across 33 files. [623.00ms]\n[format] All matched files use Prettier code style!\nFinished in 1.60s","is_error":false}]},"uuid":"9f9af8dc-ebff-43ff-9b55-be34e51c47cf","timestamp":"2026-02-28T23:47:53.300Z","toolUseResult":{"stdout":"[ci] $ mise typecheck ::: test ::: format\n[typecheck] $ bun run typecheck\n[test] $ bun test\n[format] $ bunx prettier --check src/\n[test] bun test v1.3.9 (cf6cdbbb)\n[typecheck] $ tsc --noEmit\n[format] Checking formatting...\n[test] \n[test]  825 pass\n[test]  0 fail\n[test]  2149 expect() calls\n[test] Ran 825 tests across 33 files. [623.00ms]\n[format] All matched files use Prettier code style!\nFinished in 1.60s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"c5e2a500-922c-460e-8d97-a87a0aaa104b"}
{"parentUuid":"9f9af8dc-ebff-43ff-9b55-be34e51c47cf","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01ReqzJoCDYuwEfnMktLR7DB","type":"message","role":"assistant","content":[{"type":"text","text":"All passing — typecheck, tests, and formatting. Now let me also run the live tests since CLAUDE.md says to always run `mise test:live` after protocol changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":318,"cache_read_input_tokens":108629,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":318},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMrccXohV44ESafTqCC","type":"assistant","uuid":"3b9673af-13f4-41e1-ac3a-c6d136a191f3","timestamp":"2026-02-28T23:47:58.116Z"}
{"parentUuid":"3b9673af-13f4-41e1-ac3a-c6d136a191f3","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01ReqzJoCDYuwEfnMktLR7DB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P6k2sF24jSirZyNp7odC15","name":"Bash","input":{"command":"mise test:live 2>&1","description":"Run live server tests","timeout":60000},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":318,"cache_read_input_tokens":108629,"output_tokens":136,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":318,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMrccXohV44ESafTqCC","type":"assistant","uuid":"33404823-b994-454e-a194-0c8f0970172e","timestamp":"2026-02-28T23:47:58.159Z"}
{"parentUuid":"33404823-b994-454e-a194-0c8f0970172e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P6k2sF24jSirZyNp7odC15","type":"tool_result","content":"[test:live] $ bun test ./src/test/live.ts\nbun test v1.3.9 (cf6cdbbb)\n\n 9 pass\n 0 fail\n 232 expect() calls\nRan 9 tests across 1 file. [25.16s]","is_error":false}]},"uuid":"a0152ca2-31f7-418a-9856-57d1f04258ee","timestamp":"2026-02-28T23:48:23.353Z","toolUseResult":{"stdout":"[test:live] $ bun test ./src/test/live.ts\nbun test v1.3.9 (cf6cdbbb)\n\n 9 pass\n 0 fail\n 232 expect() calls\nRan 9 tests across 1 file. [25.16s]","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"33404823-b994-454e-a194-0c8f0970172e"}
{"parentUuid":"a0152ca2-31f7-418a-9856-57d1f04258ee","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01S3ce88he4xav1sCpRqEy45","type":"message","role":"assistant","content":[{"type":"text","text":"All 9 live server tests pass. Now let me use the verification skill before committing."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":218,"cache_read_input_tokens":108947,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":218},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMtq6S3ZxU917HvNk4c","type":"assistant","uuid":"db9fcbe7-3144-4d00-890c-96c65597af8d","timestamp":"2026-02-28T23:48:26.448Z"}
{"parentUuid":"db9fcbe7-3144-4d00-890c-96c65597af8d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01S3ce88he4xav1sCpRqEy45","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017a4wyoSNJYjF1cjFZ4neXU","name":"Skill","input":{"skill":"superpowers:verification-before-completion"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":218,"cache_read_input_tokens":108947,"output_tokens":81,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":218,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMtq6S3ZxU917HvNk4c","type":"assistant","uuid":"95647110-b915-4908-b51d-99dddbeec7a9","timestamp":"2026-02-28T23:48:26.991Z"}
{"parentUuid":"95647110-b915-4908-b51d-99dddbeec7a9","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_017a4wyoSNJYjF1cjFZ4neXU","content":"Launching skill: superpowers:verification-before-completion"}]},"uuid":"afededa5-a2e6-431b-ae2a-ce9c02139c77","timestamp":"2026-02-28T23:48:27.002Z","toolUseResult":{"success":true,"commandName":"superpowers:verification-before-completion"},"sourceToolAssistantUUID":"95647110-b915-4908-b51d-99dddbeec7a9"}
{"parentUuid":"afededa5-a2e6-431b-ae2a-ce9c02139c77","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"text","text":"Base directory for this skill: /home/openclaw/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/verification-before-completion\n\n# Verification Before Completion\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\n**Violating the letter of this rule is violating the spirit of this rule.**\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Linter clean | Linter output: 0 errors | Partial check, extrapolation |\n| Build succeeds | Build command: exit 0 | Linter passing, logs look good |\n| Bug fixed | Test original symptom: passes | Code changed, assumed fixed |\n| Regression test works | Red-green cycle verified | Test passes once |\n| Agent completed | VCS diff shows changes | Agent reports \"success\" |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\", etc.)\n- About to commit/push/PR without verification\n- Trusting agent success reports\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence ≠ evidence |\n| \"Just this once\" | No exceptions |\n| \"Linter passed\" | Linter ≠ compiler |\n| \"Agent said success\" | Verify independently |\n| \"I'm tired\" | Exhaustion ≠ excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n| \"Different words so rule doesn't apply\" | Spirit over letter |\n\n## Key Patterns\n\n**Tests:**\n```\n✅ [Run test command] [See: 34/34 pass] \"All tests pass\"\n❌ \"Should pass now\" / \"Looks correct\"\n```\n\n**Regression tests (TDD Red-Green):**\n```\n✅ Write → Run (pass) → Revert fix → Run (MUST FAIL) → Restore → Run (pass)\n❌ \"I've written a regression test\" (without red-green verification)\n```\n\n**Build:**\n```\n✅ [Run build] [See: exit 0] \"Build passes\"\n❌ \"Linter passed\" (linter doesn't check compilation)\n```\n\n**Requirements:**\n```\n✅ Re-read plan → Create checklist → Verify each → Report gaps or completion\n❌ \"Tests pass, phase complete\"\n```\n\n**Agent delegation:**\n```\n✅ Agent reports success → Check VCS diff → Verify changes → Report actual state\n❌ Trust agent report\n```\n\n## Why This Matters\n\nFrom 24 failure memories:\n- your human partner said \"I don't believe you\" - trust broken\n- Undefined functions shipped - would crash\n- Missing requirements shipped - incomplete features\n- Time wasted on false completion → redirect → rework\n- Violates: \"Honesty is a core value. If you lie, you'll be replaced.\"\n\n## When To Apply\n\n**ALWAYS before:**\n- ANY variation of success/completion claims\n- ANY expression of satisfaction\n- ANY positive statement about work state\n- Committing, PR creation, task completion\n- Moving to next task\n- Delegating to agents\n\n**Rule applies to:**\n- Exact phrases\n- Paraphrases and synonyms\n- Implications of success\n- ANY communication suggesting completion/correctness\n\n## The Bottom Line\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. THEN claim the result.\n\nThis is non-negotiable.\n"}]},"isMeta":true,"uuid":"56089533-decb-4d07-b029-461d6d92a22a","timestamp":"2026-02-28T23:48:27.002Z","sourceToolUseID":"toolu_017a4wyoSNJYjF1cjFZ4neXU"}
{"parentUuid":"56089533-decb-4d07-b029-461d6d92a22a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01BhKDmdWpmqXSdsLMHeFBgp","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nUsing verification-before-completion to confirm all claims before committing.\n\nI've already run fresh verification in this session. Let me confirm the evidence:\n\n1. **`mise ci`** — typecheck, test, format all passed: `825 pass, 0 fail`, `All matched files use Prettier code style!`, tsc clean\n2. **`mise test:live`** — 9 pass, 0 fail against the real server\n\nLet me do a quick requirements checklist against the user's request:\n\n- `/e` and `/emote` slash commands parse to `{ type: \"emote\", message }` — verified in tui.test.ts\n- Sends CHAT_MSG_EMOTE via `sendEmote()` on WorldHandle — verified in client.test.ts (echo test + sendInCurrentMode test)\n- Handles receiving emotes from other players — already worked via generic `handleChatMessage` + format labels; verified by echo tests\n- Follows same pattern as say/yell — confirmed, identical structure\n- Full test coverage — parseCommand, IPC parse, dispatch, client echo, sendInCurrentMode, integration\n- Docs updated — help.ts, manual.md, SKILL.md, README.md\n\nNow let me commit and open the PR."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1438,"cache_read_input_tokens":109165,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1438},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMu6in3PPac6JXLWuRE","type":"assistant","uuid":"93690e62-2d67-4135-b41f-631142f84d7f","timestamp":"2026-02-28T23:48:39.714Z"}
{"parentUuid":"93690e62-2d67-4135-b41f-631142f84d7f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01BhKDmdWpmqXSdsLMHeFBgp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UwhTZ5DmcDP473NSh9f5FL","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"completed","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"in_progress","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1438,"cache_read_input_tokens":109165,"output_tokens":602,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1438,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMu6in3PPac6JXLWuRE","type":"assistant","uuid":"4647eda6-344d-4e82-a057-78f7bf7ee30d","timestamp":"2026-02-28T23:48:43.854Z"}
{"parentUuid":"4647eda6-344d-4e82-a057-78f7bf7ee30d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UwhTZ5DmcDP473NSh9f5FL","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"8be53fcc-4793-41d7-9542-2002f0498e75","timestamp":"2026-02-28T23:48:43.857Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"in_progress","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"pending","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"completed","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"in_progress","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"4647eda6-344d-4e82-a057-78f7bf7ee30d"}
{"parentUuid":"8be53fcc-4793-41d7-9542-2002f0498e75","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01LNPvmPqF5SzxkjAebcpt1E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0139FuzGofVsVPy21RyA9xuH","name":"Bash","input":{"command":"git status","description":"Show working tree status"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":646,"cache_read_input_tokens":110603,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":646},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMvLwpbgL18XKeUz6Hs","type":"assistant","uuid":"7606832d-63f3-4d57-a72a-c69c84101a38","timestamp":"2026-02-28T23:48:47.092Z"}
{"parentUuid":"7606832d-63f3-4d57-a72a-c69c84101a38","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0139FuzGofVsVPy21RyA9xuH","type":"tool_result","content":"On branch feat/text-emote\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .claude/skills/tuicraft/SKILL.md\n\tmodified:   README.md\n\tmodified:   docs/manual.md\n\tmodified:   src/cli/help.ts\n\tmodified:   src/daemon/commands.test.ts\n\tmodified:   src/daemon/commands.ts\n\tmodified:   src/daemon/start.test.ts\n\tmodified:   src/test/mock-handle.ts\n\tmodified:   src/ui/tui.test.ts\n\tmodified:   src/ui/tui.ts\n\tmodified:   src/wow/client.test.ts\n\tmodified:   src/wow/client.ts\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdocs/plans/2026-02-19-reconnect-auth-design.md\n\tdocs/plans/2026-02-19-reconnect-auth-plan.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"uuid":"ed8f4f6c-4917-45d8-bb3a-65eab3850c1b","timestamp":"2026-02-28T23:48:47.109Z","toolUseResult":{"stdout":"On branch feat/text-emote\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .claude/skills/tuicraft/SKILL.md\n\tmodified:   README.md\n\tmodified:   docs/manual.md\n\tmodified:   src/cli/help.ts\n\tmodified:   src/daemon/commands.test.ts\n\tmodified:   src/daemon/commands.ts\n\tmodified:   src/daemon/start.test.ts\n\tmodified:   src/test/mock-handle.ts\n\tmodified:   src/ui/tui.test.ts\n\tmodified:   src/ui/tui.ts\n\tmodified:   src/wow/client.test.ts\n\tmodified:   src/wow/client.ts\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdocs/plans/2026-02-19-reconnect-auth-design.md\n\tdocs/plans/2026-02-19-reconnect-auth-plan.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"7606832d-63f3-4d57-a72a-c69c84101a38"}
{"parentUuid":"ed8f4f6c-4917-45d8-bb3a-65eab3850c1b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01LNPvmPqF5SzxkjAebcpt1E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011RLKykWz1Cwwrfh5a2YZUs","name":"Bash","input":{"command":"git diff","description":"Show all unstaged changes"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":646,"cache_read_input_tokens":110603,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":646},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMvLwpbgL18XKeUz6Hs","type":"assistant","uuid":"2bc69723-aa1b-43d3-a02d-32e888c0838c","timestamp":"2026-02-28T23:48:47.803Z"}
{"parentUuid":"2bc69723-aa1b-43d3-a02d-32e888c0838c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011RLKykWz1Cwwrfh5a2YZUs","type":"tool_result","content":"diff --git a/.claude/skills/tuicraft/SKILL.md b/.claude/skills/tuicraft/SKILL.md\nindex 66f01d5..5336154 100644\n--- a/.claude/skills/tuicraft/SKILL.md\n+++ b/.claude/skills/tuicraft/SKILL.md\n@@ -24,6 +24,7 @@ Returns CONNECTED or an error. Check this before other commands.\n Slash commands work too:\n \n     tuicraft send \"/raid message\"         # raid chat\n+    tuicraft send \"/e waves hello\"        # text emote\n     tuicraft send \"/1 message\"            # channel 1\n     tuicraft send \"/2 message\"            # channel 2\n \ndiff --git a/README.md b/README.md\nindex 4467f73..705dcdb 100644\n--- a/README.md\n+++ b/README.md\n@@ -140,7 +140,7 @@ that the official game client does.\n | MOTD                                    | ✅     |\n | Server broadcast messages               | ❌     |\n | Chat restricted / wrong faction notices | ❌     |\n-| Text emotes (`/e`, `/emote`)            | ❌     |\n+| Text emotes (`/e`, `/emote`)            | ✅     |\n | DND / AFK status                        | ❌     |\n \n ### 👥 Social\ndiff --git a/docs/manual.md b/docs/manual.md\nindex d63b92e..02a2c4b 100644\n--- a/docs/manual.md\n+++ b/docs/manual.md\n@@ -121,6 +121,7 @@ When running in TUI mode, the following slash commands are available:\n | `/g` _msg_                   | Guild chat                  |\n | `/p` _msg_                   | Party chat                  |\n | `/raid` _msg_                | Raid chat                   |\n+| `/e` _msg_                   | Text emote                  |\n | `/1` _msg_                   | Channel 1 (usually General) |\n | `/2` _msg_                   | Channel 2 (usually Trade)   |\n | `/who` _query_               | Who search                  |\ndiff --git a/src/cli/help.ts b/src/cli/help.ts\nindex 90da19a..ac249db 100644\n--- a/src/cli/help.ts\n+++ b/src/cli/help.ts\n@@ -36,7 +36,7 @@ SETUP FLAGS\n   --timeout_minutes N  Daemon idle timeout (default: 30)\n \n INTERACTIVE COMMANDS (TUI mode)\n-  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n+  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n   /r              Reply to last whisper\n   /who [filter]   Who search\n   /invite <name>  Invite player to group\ndiff --git a/src/daemon/commands.test.ts b/src/daemon/commands.test.ts\nindex 663e440..67336f2 100644\n--- a/src/daemon/commands.test.ts\n+++ b/src/daemon/commands.test.ts\n@@ -74,6 +74,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"EMOTE\", () => {\n+    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves hello\",\n+    });\n+  });\n+\n   test(\"WHISPER\", () => {\n     expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n       type: \"whisper\",\n@@ -202,6 +209,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"slash /emote maps to emote\", () => {\n+    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves\",\n+    });\n+  });\n+\n   test(\"slash /who maps to who with filter\", () => {\n     expect(parseIpcCommand(\"/who mage\")).toEqual({\n       type: \"who\",\n@@ -280,7 +294,6 @@ describe(\"parseIpcCommand\", () => {\n       [\"ROLL\", \"Random roll\"],\n       [\"DND\", \"Player status\"],\n       [\"AFK\", \"Player status\"],\n-      [\"EMOTE waves\", \"Text emotes\"],\n     ] as const;\n \n     for (const [input, feature] of cases) {\n@@ -467,6 +480,24 @@ describe(\"dispatchCommand\", () => {\n     expect(socket.written()).toBe(\"OK\\n\\n\");\n   });\n \n+  test(\"emote calls sendEmote and writes OK\", async () => {\n+    const handle = createMockHandle();\n+    const events = new RingBuffer<EventEntry>(10);\n+    const socket = createMockSocket();\n+    const cleanup = jest.fn();\n+\n+    await dispatchCommand(\n+      { type: \"emote\", message: \"waves hello\" },\n+      handle,\n+      events,\n+      socket,\n+      cleanup,\n+    );\n+\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+    expect(socket.written()).toBe(\"OK\\n\\n\");\n+  });\n+\n   test(\"whisper calls sendWhisper and writes OK\", async () => {\n     const handle = createMockHandle();\n     const events = new RingBuffer<EventEntry>(10);\n@@ -1661,6 +1692,13 @@ describe(\"IPC round-trip\", () => {\n     expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n   });\n \n+  test(\"EMOTE returns OK and calls handle\", async () => {\n+    startTestServer();\n+    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n+    expect(lines).toEqual([\"OK\"]);\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+  });\n+\n   test(\"WHISPER returns OK\", async () => {\n     startTestServer();\n     const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\ndiff --git a/src/daemon/commands.ts b/src/daemon/commands.ts\nindex 264e6b1..c49c3f2 100644\n--- a/src/daemon/commands.ts\n+++ b/src/daemon/commands.ts\n@@ -37,6 +37,7 @@ export type IpcCommand =\n   | { type: \"yell\"; message: string }\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"read\" }\n   | { type: \"read_json\" }\n@@ -68,6 +69,7 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n       case \"yell\":\n       case \"guild\":\n       case \"party\":\n+      case \"emote\":\n         return parsed;\n       case \"whisper\":\n         return parsed;\n@@ -104,8 +106,14 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"YELL\":\n     case \"GUILD\":\n     case \"PARTY\":\n+    case \"EMOTE\":\n       return {\n-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n+        type: verb.toLowerCase() as\n+          | \"say\"\n+          | \"yell\"\n+          | \"guild\"\n+          | \"party\"\n+          | \"emote\",\n         message: rest,\n       };\n     case \"WHISPER\": {\n@@ -180,8 +188,6 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"DND\":\n     case \"AFK\":\n       return { type: \"unimplemented\", feature: \"Player status\" };\n-    case \"EMOTE\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n     default:\n       return line ? { type: \"chat\", message: line } : undefined;\n   }\n@@ -246,6 +252,10 @@ export async function dispatchCommand(\n       handle.sendParty(cmd.message);\n       writeLines(socket, [\"OK\"]);\n       return false;\n+    case \"emote\":\n+      handle.sendEmote(cmd.message);\n+      writeLines(socket, [\"OK\"]);\n+      return false;\n     case \"whisper\":\n       handle.sendWhisper(cmd.target, cmd.message);\n       writeLines(socket, [\"OK\"]);\ndiff --git a/src/daemon/start.test.ts b/src/daemon/start.test.ts\nindex 8c7d50c..21b51bf 100644\n--- a/src/daemon/start.test.ts\n+++ b/src/daemon/start.test.ts\n@@ -50,6 +50,7 @@ function makeMockClient(): {\n         sendGuild: jest.fn(),\n         sendParty: jest.fn(),\n         sendRaid: jest.fn(),\n+        sendEmote: jest.fn(),\n         sendWhisper: jest.fn(),\n         sendChannel: jest.fn(),\n         getChannel: jest.fn(),\ndiff --git a/src/test/mock-handle.ts b/src/test/mock-handle.ts\nindex 5b1da9e..a74be9e 100644\n--- a/src/test/mock-handle.ts\n+++ b/src/test/mock-handle.ts\n@@ -37,6 +37,7 @@ export function createMockHandle(): WorldHandle & {\n     sendGuild: jest.fn(),\n     sendParty: jest.fn(),\n     sendRaid: jest.fn(),\n+    sendEmote: jest.fn(),\n     sendChannel: jest.fn(),\n     getChannel: jest.fn(),\n     who: jest.fn(async () => []),\ndiff --git a/src/ui/tui.test.ts b/src/ui/tui.test.ts\nindex dba55be..ce1e4d2 100644\n--- a/src/ui/tui.test.ts\n+++ b/src/ui/tui.test.ts\n@@ -291,16 +291,16 @@ describe(\"parseCommand\", () => {\n         feature: \"Player status\",\n       });\n     });\n-    test(\"/e returns unimplemented\", () => {\n+    test(\"/e sends emote\", () => {\n       expect(parseCommand(\"/e waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n-    test(\"/emote returns unimplemented\", () => {\n+    test(\"/emote sends emote\", () => {\n       expect(parseCommand(\"/emote waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n   });\n@@ -452,7 +452,7 @@ describe(\"startTui\", () => {\n     await done;\n   });\n \n-  test(\"dispatches yell, guild, party, raid commands\", async () => {\n+  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n     const handle = createMockHandle();\n     const input = new PassThrough();\n \n@@ -461,12 +461,14 @@ describe(\"startTui\", () => {\n     writeLine(input, \"/g guild msg\");\n     writeLine(input, \"/p party msg\");\n     writeLine(input, \"/raid pull now\");\n+    writeLine(input, \"/e waves hello\");\n     await flush();\n \n     expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n     expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n     expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n     expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n \n     input.end();\n     await done;\ndiff --git a/src/ui/tui.ts b/src/ui/tui.ts\nindex c85b02f..97934c7 100644\n--- a/src/ui/tui.ts\n+++ b/src/ui/tui.ts\n@@ -21,6 +21,7 @@ export type Command =\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n   | { type: \"raid\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"reply\"; message: string }\n   | { type: \"channel\"; target: string; message: string }\n@@ -133,7 +134,7 @@ export function parseCommand(input: string): Command {\n       return { type: \"unimplemented\", feature: \"Player status\" };\n     case \"/e\":\n     case \"/emote\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n+      return { type: \"emote\", message: rest };\n     default: {\n       const channelMatch = cmd.match(/^\\/(\\d+)$/);\n       if (channelMatch) {\n@@ -520,6 +521,9 @@ export async function executeCommand(\n     case \"raid\":\n       state.handle.sendRaid(cmd.message);\n       break;\n+    case \"emote\":\n+      state.handle.sendEmote(cmd.message);\n+      break;\n     case \"whisper\":\n       state.handle.sendWhisper(cmd.target, cmd.message);\n       state.lastWhisperFrom = cmd.target;\ndiff --git a/src/wow/client.test.ts b/src/wow/client.test.ts\nindex 93181ec..e529890 100644\n--- a/src/wow/client.test.ts\n+++ b/src/wow/client.test.ts\n@@ -767,6 +767,25 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendEmote sends message and receives echo\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendEmote(\"test emote\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"test emote\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendChannel sends message and receives echo\", async () => {\n     const ws = await startMockWorldServer();\n     try {\n@@ -1150,6 +1169,26 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendInCurrentMode dispatches emote\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      handle.setLastChatMode({ type: \"emote\" });\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendInCurrentMode(\"emote test\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"emote test\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendInCurrentMode dispatches channel\", async () => {\n     const ws = await startMockWorldServer();\n     try {\ndiff --git a/src/wow/client.ts b/src/wow/client.ts\nindex 4edec05..b17a443 100644\n--- a/src/wow/client.ts\n+++ b/src/wow/client.ts\n@@ -151,6 +151,7 @@ export type ChatMode =\n   | { type: \"guild\" }\n   | { type: \"party\" }\n   | { type: \"raid\" }\n+  | { type: \"emote\" }\n   | { type: \"whisper\"; target: string }\n   | { type: \"channel\"; channel: string };\n \n@@ -164,6 +165,7 @@ export type WorldHandle = {\n   sendGuild(message: string): void;\n   sendParty(message: string): void;\n   sendRaid(message: string): void;\n+  sendEmote(message: string): void;\n   sendChannel(channel: string, message: string): void;\n   getChannel(index: number): string | undefined;\n   who(opts?: {\n@@ -1144,6 +1146,14 @@ export function worldSession(\n             buildChatMessage(ChatType.RAID, lang, message),\n           );\n         },\n+        sendEmote(message) {\n+          conn.lastChatMode = { type: \"emote\" };\n+          sendPacket(\n+            conn,\n+            GameOpcode.CMSG_MESSAGE_CHAT,\n+            buildChatMessage(ChatType.EMOTE, lang, message),\n+          );\n+        },\n         sendChannel(channel, message) {\n           conn.lastChatMode = { type: \"channel\", channel };\n           sendPacket(\n@@ -1184,6 +1194,9 @@ export function worldSession(\n             case \"raid\":\n               handle.sendRaid(message);\n               break;\n+            case \"emote\":\n+              handle.sendEmote(message);\n+              break;\n             case \"whisper\":\n               handle.sendWhisper(mode.target, message);\n               break;","is_error":false}]},"uuid":"8dab4575-26fc-467f-a53b-af6104210bdb","timestamp":"2026-02-28T23:48:47.821Z","toolUseResult":{"stdout":"diff --git a/.claude/skills/tuicraft/SKILL.md b/.claude/skills/tuicraft/SKILL.md\nindex 66f01d5..5336154 100644\n--- a/.claude/skills/tuicraft/SKILL.md\n+++ b/.claude/skills/tuicraft/SKILL.md\n@@ -24,6 +24,7 @@ Returns CONNECTED or an error. Check this before other commands.\n Slash commands work too:\n \n     tuicraft send \"/raid message\"         # raid chat\n+    tuicraft send \"/e waves hello\"        # text emote\n     tuicraft send \"/1 message\"            # channel 1\n     tuicraft send \"/2 message\"            # channel 2\n \ndiff --git a/README.md b/README.md\nindex 4467f73..705dcdb 100644\n--- a/README.md\n+++ b/README.md\n@@ -140,7 +140,7 @@ that the official game client does.\n | MOTD                                    | ✅     |\n | Server broadcast messages               | ❌     |\n | Chat restricted / wrong faction notices | ❌     |\n-| Text emotes (`/e`, `/emote`)            | ❌     |\n+| Text emotes (`/e`, `/emote`)            | ✅     |\n | DND / AFK status                        | ❌     |\n \n ### 👥 Social\ndiff --git a/docs/manual.md b/docs/manual.md\nindex d63b92e..02a2c4b 100644\n--- a/docs/manual.md\n+++ b/docs/manual.md\n@@ -121,6 +121,7 @@ When running in TUI mode, the following slash commands are available:\n | `/g` _msg_                   | Guild chat                  |\n | `/p` _msg_                   | Party chat                  |\n | `/raid` _msg_                | Raid chat                   |\n+| `/e` _msg_                   | Text emote                  |\n | `/1` _msg_                   | Channel 1 (usually General) |\n | `/2` _msg_                   | Channel 2 (usually Trade)   |\n | `/who` _query_               | Who search                  |\ndiff --git a/src/cli/help.ts b/src/cli/help.ts\nindex 90da19a..ac249db 100644\n--- a/src/cli/help.ts\n+++ b/src/cli/help.ts\n@@ -36,7 +36,7 @@ SETUP FLAGS\n   --timeout_minutes N  Daemon idle timeout (default: 30)\n \n INTERACTIVE COMMANDS (TUI mode)\n-  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n+  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n   /r              Reply to last whisper\n   /who [filter]   Who search\n   /invite <name>  Invite player to group\ndiff --git a/src/daemon/commands.test.ts b/src/daemon/commands.test.ts\nindex 663e440..67336f2 100644\n--- a/src/daemon/commands.test.ts\n+++ b/src/daemon/commands.test.ts\n@@ -74,6 +74,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"EMOTE\", () => {\n+    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves hello\",\n+    });\n+  });\n+\n   test(\"WHISPER\", () => {\n     expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n       type: \"whisper\",\n@@ -202,6 +209,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"slash /emote maps to emote\", () => {\n+    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves\",\n+    });\n+  });\n+\n   test(\"slash /who maps to who with filter\", () => {\n     expect(parseIpcCommand(\"/who mage\")).toEqual({\n       type: \"who\",\n@@ -280,7 +294,6 @@ describe(\"parseIpcCommand\", () => {\n       [\"ROLL\", \"Random roll\"],\n       [\"DND\", \"Player status\"],\n       [\"AFK\", \"Player status\"],\n-      [\"EMOTE waves\", \"Text emotes\"],\n     ] as const;\n \n     for (const [input, feature] of cases) {\n@@ -467,6 +480,24 @@ describe(\"dispatchCommand\", () => {\n     expect(socket.written()).toBe(\"OK\\n\\n\");\n   });\n \n+  test(\"emote calls sendEmote and writes OK\", async () => {\n+    const handle = createMockHandle();\n+    const events = new RingBuffer<EventEntry>(10);\n+    const socket = createMockSocket();\n+    const cleanup = jest.fn();\n+\n+    await dispatchCommand(\n+      { type: \"emote\", message: \"waves hello\" },\n+      handle,\n+      events,\n+      socket,\n+      cleanup,\n+    );\n+\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+    expect(socket.written()).toBe(\"OK\\n\\n\");\n+  });\n+\n   test(\"whisper calls sendWhisper and writes OK\", async () => {\n     const handle = createMockHandle();\n     const events = new RingBuffer<EventEntry>(10);\n@@ -1661,6 +1692,13 @@ describe(\"IPC round-trip\", () => {\n     expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n   });\n \n+  test(\"EMOTE returns OK and calls handle\", async () => {\n+    startTestServer();\n+    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n+    expect(lines).toEqual([\"OK\"]);\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+  });\n+\n   test(\"WHISPER returns OK\", async () => {\n     startTestServer();\n     const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\ndiff --git a/src/daemon/commands.ts b/src/daemon/commands.ts\nindex 264e6b1..c49c3f2 100644\n--- a/src/daemon/commands.ts\n+++ b/src/daemon/commands.ts\n@@ -37,6 +37,7 @@ export type IpcCommand =\n   | { type: \"yell\"; message: string }\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"read\" }\n   | { type: \"read_json\" }\n@@ -68,6 +69,7 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n       case \"yell\":\n       case \"guild\":\n       case \"party\":\n+      case \"emote\":\n         return parsed;\n       case \"whisper\":\n         return parsed;\n@@ -104,8 +106,14 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"YELL\":\n     case \"GUILD\":\n     case \"PARTY\":\n+    case \"EMOTE\":\n       return {\n-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n+        type: verb.toLowerCase() as\n+          | \"say\"\n+          | \"yell\"\n+          | \"guild\"\n+          | \"party\"\n+          | \"emote\",\n         message: rest,\n       };\n     case \"WHISPER\": {\n@@ -180,8 +188,6 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"DND\":\n     case \"AFK\":\n       return { type: \"unimplemented\", feature: \"Player status\" };\n-    case \"EMOTE\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n     default:\n       return line ? { type: \"chat\", message: line } : undefined;\n   }\n@@ -246,6 +252,10 @@ export async function dispatchCommand(\n       handle.sendParty(cmd.message);\n       writeLines(socket, [\"OK\"]);\n       return false;\n+    case \"emote\":\n+      handle.sendEmote(cmd.message);\n+      writeLines(socket, [\"OK\"]);\n+      return false;\n     case \"whisper\":\n       handle.sendWhisper(cmd.target, cmd.message);\n       writeLines(socket, [\"OK\"]);\ndiff --git a/src/daemon/start.test.ts b/src/daemon/start.test.ts\nindex 8c7d50c..21b51bf 100644\n--- a/src/daemon/start.test.ts\n+++ b/src/daemon/start.test.ts\n@@ -50,6 +50,7 @@ function makeMockClient(): {\n         sendGuild: jest.fn(),\n         sendParty: jest.fn(),\n         sendRaid: jest.fn(),\n+        sendEmote: jest.fn(),\n         sendWhisper: jest.fn(),\n         sendChannel: jest.fn(),\n         getChannel: jest.fn(),\ndiff --git a/src/test/mock-handle.ts b/src/test/mock-handle.ts\nindex 5b1da9e..a74be9e 100644\n--- a/src/test/mock-handle.ts\n+++ b/src/test/mock-handle.ts\n@@ -37,6 +37,7 @@ export function createMockHandle(): WorldHandle & {\n     sendGuild: jest.fn(),\n     sendParty: jest.fn(),\n     sendRaid: jest.fn(),\n+    sendEmote: jest.fn(),\n     sendChannel: jest.fn(),\n     getChannel: jest.fn(),\n     who: jest.fn(async () => []),\ndiff --git a/src/ui/tui.test.ts b/src/ui/tui.test.ts\nindex dba55be..ce1e4d2 100644\n--- a/src/ui/tui.test.ts\n+++ b/src/ui/tui.test.ts\n@@ -291,16 +291,16 @@ describe(\"parseCommand\", () => {\n         feature: \"Player status\",\n       });\n     });\n-    test(\"/e returns unimplemented\", () => {\n+    test(\"/e sends emote\", () => {\n       expect(parseCommand(\"/e waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n-    test(\"/emote returns unimplemented\", () => {\n+    test(\"/emote sends emote\", () => {\n       expect(parseCommand(\"/emote waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n   });\n@@ -452,7 +452,7 @@ describe(\"startTui\", () => {\n     await done;\n   });\n \n-  test(\"dispatches yell, guild, party, raid commands\", async () => {\n+  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n     const handle = createMockHandle();\n     const input = new PassThrough();\n \n@@ -461,12 +461,14 @@ describe(\"startTui\", () => {\n     writeLine(input, \"/g guild msg\");\n     writeLine(input, \"/p party msg\");\n     writeLine(input, \"/raid pull now\");\n+    writeLine(input, \"/e waves hello\");\n     await flush();\n \n     expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n     expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n     expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n     expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n \n     input.end();\n     await done;\ndiff --git a/src/ui/tui.ts b/src/ui/tui.ts\nindex c85b02f..97934c7 100644\n--- a/src/ui/tui.ts\n+++ b/src/ui/tui.ts\n@@ -21,6 +21,7 @@ export type Command =\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n   | { type: \"raid\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"reply\"; message: string }\n   | { type: \"channel\"; target: string; message: string }\n@@ -133,7 +134,7 @@ export function parseCommand(input: string): Command {\n       return { type: \"unimplemented\", feature: \"Player status\" };\n     case \"/e\":\n     case \"/emote\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n+      return { type: \"emote\", message: rest };\n     default: {\n       const channelMatch = cmd.match(/^\\/(\\d+)$/);\n       if (channelMatch) {\n@@ -520,6 +521,9 @@ export async function executeCommand(\n     case \"raid\":\n       state.handle.sendRaid(cmd.message);\n       break;\n+    case \"emote\":\n+      state.handle.sendEmote(cmd.message);\n+      break;\n     case \"whisper\":\n       state.handle.sendWhisper(cmd.target, cmd.message);\n       state.lastWhisperFrom = cmd.target;\ndiff --git a/src/wow/client.test.ts b/src/wow/client.test.ts\nindex 93181ec..e529890 100644\n--- a/src/wow/client.test.ts\n+++ b/src/wow/client.test.ts\n@@ -767,6 +767,25 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendEmote sends message and receives echo\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendEmote(\"test emote\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"test emote\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendChannel sends message and receives echo\", async () => {\n     const ws = await startMockWorldServer();\n     try {\n@@ -1150,6 +1169,26 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendInCurrentMode dispatches emote\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      handle.setLastChatMode({ type: \"emote\" });\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendInCurrentMode(\"emote test\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"emote test\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendInCurrentMode dispatches channel\", async () => {\n     const ws = await startMockWorldServer();\n     try {\ndiff --git a/src/wow/client.ts b/src/wow/client.ts\nindex 4edec05..b17a443 100644\n--- a/src/wow/client.ts\n+++ b/src/wow/client.ts\n@@ -151,6 +151,7 @@ export type ChatMode =\n   | { type: \"guild\" }\n   | { type: \"party\" }\n   | { type: \"raid\" }\n+  | { type: \"emote\" }\n   | { type: \"whisper\"; target: string }\n   | { type: \"channel\"; channel: string };\n \n@@ -164,6 +165,7 @@ export type WorldHandle = {\n   sendGuild(message: string): void;\n   sendParty(message: string): void;\n   sendRaid(message: string): void;\n+  sendEmote(message: string): void;\n   sendChannel(channel: string, message: string): void;\n   getChannel(index: number): string | undefined;\n   who(opts?: {\n@@ -1144,6 +1146,14 @@ export function worldSession(\n             buildChatMessage(ChatType.RAID, lang, message),\n           );\n         },\n+        sendEmote(message) {\n+          conn.lastChatMode = { type: \"emote\" };\n+          sendPacket(\n+            conn,\n+            GameOpcode.CMSG_MESSAGE_CHAT,\n+            buildChatMessage(ChatType.EMOTE, lang, message),\n+          );\n+        },\n         sendChannel(channel, message) {\n           conn.lastChatMode = { type: \"channel\", channel };\n           sendPacket(\n@@ -1184,6 +1194,9 @@ export function worldSession(\n             case \"raid\":\n               handle.sendRaid(message);\n               break;\n+            case \"emote\":\n+              handle.sendEmote(message);\n+              break;\n             case \"whisper\":\n               handle.sendWhisper(mode.target, message);\n               break;","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"2bc69723-aa1b-43d3-a02d-32e888c0838c"}
{"parentUuid":"8dab4575-26fc-467f-a53b-af6104210bdb","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01LNPvmPqF5SzxkjAebcpt1E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hr1HWe4ktiGMymwcVCb2JJ","name":"Bash","input":{"command":"git log -n 5","description":"Show recent commit messages"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":646,"cache_read_input_tokens":110603,"output_tokens":190,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":646,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMvLwpbgL18XKeUz6Hs","type":"assistant","uuid":"abd843a4-9d17-469d-b418-74a5c2cbe35d","timestamp":"2026-02-28T23:48:48.773Z"}
{"parentUuid":"abd843a4-9d17-469d-b418-74a5c2cbe35d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hr1HWe4ktiGMymwcVCb2JJ","type":"tool_result","content":"commit c8b54093bf60081d63af829bca14faaa1ecf8c14\nAuthor: Theodor Vararu <theo@vararu.org>\nDate:   Sat Feb 28 20:39:51 2026 +0700\n\n    test: Bump coverage to 100% functions and lines\n    \n    Cover the slash-command unimplemented branch, friend event server\n    wiring, and mock-handle default implementations that were bypassed\n    by mockReturnValue in all existing tests.\n    \n    Entire-Checkpoint: 9a9e2425e156\n\ncommit 10236569abeeae2946516e7a757e067289487089\nAuthor: Theodor Vararu <theo@vararu.org>\nDate:   Sat Feb 28 20:30:29 2026 +0700\n\n    docs: Update workflow\n    \n    Simplify the reviewing process, make it clearer.\n\ncommit 93e0ff9256eadd0d9198565d1d94a7588cbac379\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:57:46 2026 +0000\n\n    chore: Remove bugs.md\n    \n    The sole entry (SMSG_CONTACT_LIST) has been implemented.\n    \n    Entire-Checkpoint: de9baccf35c8\n\ncommit 25f1e514073cef803692dad61f1edbfddc06941a\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:46:24 2026 +0000\n\n    docs: Add friend list to all documentation\n    \n    Update help text, manual, SKILL.md, and README with friend list\n    commands, event types, and IPC verbs. Mark bugs.md as resolved.\n    \n    Entire-Checkpoint: bdb3c77539de\n\ncommit 507fd73a1abe7ca9694aa8f62b61e7bc2e15aced\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:45:03 2026 +0000\n\n    fix: Address review findings for friend list\n    \n    Add explicit FriendStore constructor for Bun coverage, add missing\n    formatFriendListJson / ADDED_OFFLINE / error-branch tests, remove\n    redundant null coalescing in event handlers.\n    \n    Entire-Checkpoint: d9a3326136ff","is_error":false}]},"uuid":"7dac1d05-f2db-41e4-a7dd-73a58572501a","timestamp":"2026-02-28T23:48:48.788Z","toolUseResult":{"stdout":"commit c8b54093bf60081d63af829bca14faaa1ecf8c14\nAuthor: Theodor Vararu <theo@vararu.org>\nDate:   Sat Feb 28 20:39:51 2026 +0700\n\n    test: Bump coverage to 100% functions and lines\n    \n    Cover the slash-command unimplemented branch, friend event server\n    wiring, and mock-handle default implementations that were bypassed\n    by mockReturnValue in all existing tests.\n    \n    Entire-Checkpoint: 9a9e2425e156\n\ncommit 10236569abeeae2946516e7a757e067289487089\nAuthor: Theodor Vararu <theo@vararu.org>\nDate:   Sat Feb 28 20:30:29 2026 +0700\n\n    docs: Update workflow\n    \n    Simplify the reviewing process, make it clearer.\n\ncommit 93e0ff9256eadd0d9198565d1d94a7588cbac379\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:57:46 2026 +0000\n\n    chore: Remove bugs.md\n    \n    The sole entry (SMSG_CONTACT_LIST) has been implemented.\n    \n    Entire-Checkpoint: de9baccf35c8\n\ncommit 25f1e514073cef803692dad61f1edbfddc06941a\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:46:24 2026 +0000\n\n    docs: Add friend list to all documentation\n    \n    Update help text, manual, SKILL.md, and README with friend list\n    commands, event types, and IPC verbs. Mark bugs.md as resolved.\n    \n    Entire-Checkpoint: bdb3c77539de\n\ncommit 507fd73a1abe7ca9694aa8f62b61e7bc2e15aced\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 11:45:03 2026 +0000\n\n    fix: Address review findings for friend list\n    \n    Add explicit FriendStore constructor for Bun coverage, add missing\n    formatFriendListJson / ADDED_OFFLINE / error-branch tests, remove\n    redundant null coalescing in event handlers.\n    \n    Entire-Checkpoint: d9a3326136ff","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"abd843a4-9d17-469d-b418-74a5c2cbe35d"}
{"parentUuid":"7dac1d05-f2db-41e4-a7dd-73a58572501a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Bdnyt9QrfL952hgKCtWALg","type":"message","role":"assistant","content":[{"type":"text","text":"Everything looks clean. The untracked files are from a previous session (reconnect-auth docs), not part of this change. Let me commit and push."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5945,"cache_read_input_tokens":111249,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5945},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMvhrRAgUCAcLXQKTzu","type":"assistant","uuid":"487c8561-5187-4670-9c67-630bf9aca765","timestamp":"2026-02-28T23:48:52.738Z"}
{"parentUuid":"487c8561-5187-4670-9c67-630bf9aca765","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Bdnyt9QrfL952hgKCtWALg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0184tJuVeXgace5ED64bjRzT","name":"Bash","input":{"command":"git add src/ui/tui.ts src/ui/tui.test.ts src/wow/client.ts src/wow/client.test.ts src/daemon/commands.ts src/daemon/commands.test.ts src/daemon/start.test.ts src/test/mock-handle.ts src/cli/help.ts docs/manual.md .claude/skills/tuicraft/SKILL.md README.md","description":"Stage all emote-related changes"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5945,"cache_read_input_tokens":111249,"output_tokens":206,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":5945,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMvhrRAgUCAcLXQKTzu","type":"assistant","uuid":"b7b6f2c0-5882-489e-a41a-c9d35983552e","timestamp":"2026-02-28T23:48:55.138Z"}
{"parentUuid":"b7b6f2c0-5882-489e-a41a-c9d35983552e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0184tJuVeXgace5ED64bjRzT","type":"tool_result","content":"","is_error":false}]},"uuid":"da015410-b75b-4abe-bdef-8d0a6a92cc23","timestamp":"2026-02-28T23:48:55.157Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"b7b6f2c0-5882-489e-a41a-c9d35983552e"}
{"parentUuid":"da015410-b75b-4abe-bdef-8d0a6a92cc23","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01YQ1YmpTycPhheuXxv5EAxG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Ru7tFmTsYtTWLKk2MRE6M","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat: Add text emote support\n\nWire /e and /emote slash commands through the chat pipeline using\nthe same pattern as say/yell. Handles both sending and receiving\nemotes via CHAT_MSG_EMOTE (0x0a).\nEOF\n)\"","description":"Commit text emote feature"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":232,"cache_read_input_tokens":117194,"output_tokens":145,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":232,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMwB7zrGQDWx1ebPZ4T","type":"assistant","uuid":"8bd85756-f3b8-4958-9af0-20c7286bc222","timestamp":"2026-02-28T23:49:02.008Z"}
{"parentUuid":"8bd85756-f3b8-4958-9af0-20c7286bc222","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Ru7tFmTsYtTWLKk2MRE6M","type":"tool_result","content":"[feat/text-emote 751b13b] feat: Add text emote support\n 12 files changed, 124 insertions(+), 14 deletions(-)","is_error":false}]},"uuid":"e7e7186c-d540-4d13-a0ee-6a3d8a00ff4c","timestamp":"2026-02-28T23:49:05.440Z","toolUseResult":{"stdout":"[feat/text-emote 751b13b] feat: Add text emote support\n 12 files changed, 124 insertions(+), 14 deletions(-)","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"8bd85756-f3b8-4958-9af0-20c7286bc222"}
{"parentUuid":"e7e7186c-d540-4d13-a0ee-6a3d8a00ff4c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Cbfi4ijAkHLhc8yJZwWBRs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RHtxcGSJkKF41DtqxoEMsQ","name":"Bash","input":{"command":"git push -u origin feat/text-emote 2>&1","description":"Push feature branch to remote"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":197,"cache_read_input_tokens":117426,"output_tokens":87,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":197,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMww2TGzNCzoBGtJLCq","type":"assistant","uuid":"07e13a05-6ceb-4770-9256-ef25841ddc97","timestamp":"2026-02-28T23:49:08.975Z"}
{"parentUuid":"07e13a05-6ceb-4770-9256-ef25841ddc97","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RHtxcGSJkKF41DtqxoEMsQ","type":"tool_result","content":"[entire] Pushing session logs to origin...\n[entire] Syncing with remote session logs...\nremote: \nremote: Create a pull request for 'feat/text-emote' on GitHub by visiting:        \nremote:      https://github.com/tvararu/tuicraft/pull/new/feat/text-emote        \nremote: \nTo https://github.com/tvararu/tuicraft.git\n * [new branch]      feat/text-emote -> feat/text-emote\nbranch 'feat/text-emote' set up to track 'origin/feat/text-emote'.","is_error":false}]},"uuid":"03c6c97b-5967-4124-8c00-9ef010dd860a","timestamp":"2026-02-28T23:49:14.346Z","toolUseResult":{"stdout":"[entire] Pushing session logs to origin...\n[entire] Syncing with remote session logs...\nremote: \nremote: Create a pull request for 'feat/text-emote' on GitHub by visiting:        \nremote:      https://github.com/tvararu/tuicraft/pull/new/feat/text-emote        \nremote: \nTo https://github.com/tvararu/tuicraft.git\n * [new branch]      feat/text-emote -> feat/text-emote\nbranch 'feat/text-emote' set up to track 'origin/feat/text-emote'.","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"07e13a05-6ceb-4770-9256-ef25841ddc97"}
{"parentUuid":"03c6c97b-5967-4124-8c00-9ef010dd860a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_011HjyfPqWvHW1Gi3hsHhSQe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HA7hosDF5ARKQLUieN75Ex","name":"Bash","input":{"command":"gh pr create --title \"feat: Add text emote support\" --body \"$(cat <<'EOF'\n## Summary\n\nWires `/e` and `/emote` slash commands through the existing chat pipeline, following the same pattern as say/yell. Sends `CHAT_MSG_EMOTE` (type `0x0a`) and handles incoming emotes from other players. Also adds `EMOTE` as an IPC verb for programmatic use.\n\n- Adds `sendEmote()` to `WorldHandle`, `emote` to `ChatMode` and `sendInCurrentMode`\n- Updates slash command parser, IPC command parser, and dispatch routing\n- Updates all four doc surfaces: help text, manual, SKILL.md, README\n\n## Test plan\n\n- [x] parseCommand tests for `/e` and `/emote`\n- [x] IPC parse tests for `EMOTE` verb and `/emote` slash\n- [x] dispatchCommand test for emote routing\n- [x] client.test.ts echo test for `sendEmote`\n- [x] client.test.ts `sendInCurrentMode` dispatches emote\n- [x] IPC round-trip integration test\n- [x] `mise ci` passes (typecheck + 825 tests + format)\n- [x] `mise test:live` passes (9 tests against real server)\nEOF\n)\"","description":"Create pull request"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":244,"cache_read_input_tokens":117623,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":244},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbMxb8A9yadFS3UUviMn","type":"assistant","uuid":"12a3cf79-6874-409e-a765-df43b37ddb8e","timestamp":"2026-02-28T23:49:24.223Z"}
{"type":"pr-link","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","prNumber":61,"prUrl":"https://github.com/tvararu/tuicraft/pull/61","prRepository":"tvararu/tuicraft","timestamp":"2026-02-28T23:49:27.069Z"}
{"parentUuid":"12a3cf79-6874-409e-a765-df43b37ddb8e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HA7hosDF5ARKQLUieN75Ex","type":"tool_result","content":"Warning: 2 uncommitted changes\nhttps://github.com/tvararu/tuicraft/pull/61","is_error":false}]},"uuid":"9d4ce310-d96d-4947-99b7-cb8aa6cc5a6f","timestamp":"2026-02-28T23:49:27.069Z","toolUseResult":{"stdout":"Warning: 2 uncommitted changes\nhttps://github.com/tvararu/tuicraft/pull/61","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"12a3cf79-6874-409e-a765-df43b37ddb8e"}
{"parentUuid":"9d4ce310-d96d-4947-99b7-cb8aa6cc5a6f","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01JqiCWwv9oPuYM7hcNWTjNE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NmMjhGedZWFAGADmYwHJwy","name":"TodoWrite","input":{"todos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"completed","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"completed","activeForm":"Committing and opening PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":426,"cache_read_input_tokens":117867,"output_tokens":309,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":426,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMyXX9D7uZLQrd386se","type":"assistant","uuid":"644c2899-776b-49cf-b62e-f997d111dd5b","timestamp":"2026-02-28T23:49:33.815Z"}
{"parentUuid":"644c2899-776b-49cf-b62e-f997d111dd5b","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NmMjhGedZWFAGADmYwHJwy","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"49c11c9f-ac6a-4bc9-8af1-da12cc73a559","timestamp":"2026-02-28T23:49:33.816Z","toolUseResult":{"oldTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"completed","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"in_progress","activeForm":"Committing and opening PR"}],"newTodos":[{"content":"Update tui.ts parseCommand for /e and /emote","status":"completed","activeForm":"Updating parseCommand for /e and /emote"},{"content":"Add sendEmote to WorldHandle in client.ts","status":"completed","activeForm":"Adding sendEmote to WorldHandle"},{"content":"Wire emote through IPC in commands.ts","status":"completed","activeForm":"Wiring emote through IPC commands"},{"content":"Update mock handles","status":"completed","activeForm":"Updating mock handles"},{"content":"Write tests for all emote changes","status":"completed","activeForm":"Writing tests for emote changes"},{"content":"Run tests and verify","status":"completed","activeForm":"Running tests and verifying"},{"content":"Update help text and docs","status":"completed","activeForm":"Updating help text and docs"},{"content":"Commit and open PR","status":"completed","activeForm":"Committing and opening PR"}]},"sourceToolAssistantUUID":"644c2899-776b-49cf-b62e-f997d111dd5b"}
{"parentUuid":"49c11c9f-ac6a-4bc9-8af1-da12cc73a559","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01RuCVAwQeYwc8NKBj19uDXn","type":"message","role":"assistant","content":[{"type":"text","text":"Done. PR is at https://github.com/tvararu/tuicraft/pull/61\n\n**Summary of changes across 12 files:**\n\n- **`tui.ts`** — `/e` and `/emote` now return `{ type: \"emote\", message }` instead of unimplemented; `executeCommand` calls `sendEmote`\n- **`client.ts`** — Added `sendEmote()` to `WorldHandle`, `emote` to `ChatMode`, and emote case to `sendInCurrentMode`\n- **`commands.ts`** — Added `emote` to `IpcCommand`, wired through `parseIpcCommand` (slash + `EMOTE` verb) and `dispatchCommand`\n- **`mock-handle.ts`** + **`start.test.ts`** — Added `sendEmote` stubs\n- **Tests** — 7 new tests covering parse, IPC, dispatch, echo, sendInCurrentMode, and integration\n- **Docs** — Updated help.ts, manual.md, SKILL.md, README.md"}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":351,"cache_read_input_tokens":118293,"output_tokens":255,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":351,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbMz2WR1eSLHFLPRnzbc","type":"assistant","uuid":"103b06a2-f8e3-4f10-adf3-db4be64888ad","timestamp":"2026-02-28T23:49:41.235Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-28T23:49:57.534Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","content":"/security-review"}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-28T23:49:57.535Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd"}
{"parentUuid":"103b06a2-f8e3-4f10-adf3-db4be64888ad","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.sh"},"parentToolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","toolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","timestamp":"2026-02-28T23:49:57.518Z","uuid":"b4637d79-5688-4c84-b8e8-34d5893f4462"}
{"parentUuid":"b4637d79-5688-4c84-b8e8-34d5893f4462","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"entire hooks claude-code session-start"},"parentToolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","toolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","timestamp":"2026-02-28T23:49:57.518Z","uuid":"72a986da-d62f-4f24-9098-57e8f7980750"}
{"parentUuid":"72a986da-d62f-4f24-9098-57e8f7980750","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"'${CLAUDE_PLUGIN_ROOT}/hooks/run-hook.cmd' session-start"},"parentToolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","toolUseID":"b0595b48-48d7-4eff-b4e4-22e3f1abccc3","timestamp":"2026-02-28T23:49:57.518Z","uuid":"c763fdf9-4d15-48bd-bd48-37152c1bdcc2"}
{"parentUuid":"c763fdf9-4d15-48bd-bd48-37152c1bdcc2","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":"<command-message>security-review</command-message>\n<command-name>/security-review</command-name>"},"uuid":"f006078f-c6fd-425b-b171-a781931eb47c","timestamp":"2026-02-28T23:49:57.985Z"}
{"parentUuid":"f006078f-c6fd-425b-b171-a781931eb47c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"text","text":"You are a senior security engineer conducting a focused security review of the changes on this branch.\n\nGIT STATUS:\n\n```\nOn branch feat/text-emote\nYour branch is up to date with 'origin/feat/text-emote'.\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdocs/plans/2026-02-19-reconnect-auth-design.md\n\tdocs/plans/2026-02-19-reconnect-auth-plan.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nFILES MODIFIED:\n\n```\n.claude/skills/tuicraft/SKILL.md\nREADME.md\ndocs/manual.md\nsrc/cli/help.ts\nsrc/daemon/commands.test.ts\nsrc/daemon/commands.ts\nsrc/daemon/start.test.ts\nsrc/test/mock-handle.ts\nsrc/ui/tui.test.ts\nsrc/ui/tui.ts\nsrc/wow/client.test.ts\nsrc/wow/client.ts\n```\n\nCOMMITS:\n\n```\ncommit 751b13b2e6fbec729fa48a92886c5ec0a0bef4a0\nAuthor: OpenClaw <openclaw@vararu.org>\nDate:   Sat Feb 28 23:49:02 2026 +0000\n\n    feat: Add text emote support\n    \n    Wire /e and /emote slash commands through the chat pipeline using\n    the same pattern as say/yell. Handles both sending and receiving\n    emotes via CHAT_MSG_EMOTE (0x0a).\n    \n    Entire-Checkpoint: 7d877df11c0e\n```\n\nDIFF CONTENT:\n\n```\ndiff --git a/.claude/skills/tuicraft/SKILL.md b/.claude/skills/tuicraft/SKILL.md\nindex 66f01d5..5336154 100644\n--- a/.claude/skills/tuicraft/SKILL.md\n+++ b/.claude/skills/tuicraft/SKILL.md\n@@ -24,6 +24,7 @@ Returns CONNECTED or an error. Check this before other commands.\n Slash commands work too:\n \n     tuicraft send \"/raid message\"         # raid chat\n+    tuicraft send \"/e waves hello\"        # text emote\n     tuicraft send \"/1 message\"            # channel 1\n     tuicraft send \"/2 message\"            # channel 2\n \ndiff --git a/README.md b/README.md\nindex 4467f73..705dcdb 100644\n--- a/README.md\n+++ b/README.md\n@@ -140,7 +140,7 @@ that the official game client does.\n | MOTD                                    | ✅     |\n | Server broadcast messages               | ❌     |\n | Chat restricted / wrong faction notices | ❌     |\n-| Text emotes (`/e`, `/emote`)            | ❌     |\n+| Text emotes (`/e`, `/emote`)            | ✅     |\n | DND / AFK status                        | ❌     |\n \n ### 👥 Social\ndiff --git a/docs/manual.md b/docs/manual.md\nindex d63b92e..02a2c4b 100644\n--- a/docs/manual.md\n+++ b/docs/manual.md\n@@ -121,6 +121,7 @@ When running in TUI mode, the following slash commands are available:\n | `/g` _msg_                   | Guild chat                  |\n | `/p` _msg_                   | Party chat                  |\n | `/raid` _msg_                | Raid chat                   |\n+| `/e` _msg_                   | Text emote                  |\n | `/1` _msg_                   | Channel 1 (usually General) |\n | `/2` _msg_                   | Channel 2 (usually Trade)   |\n | `/who` _query_               | Who search                  |\ndiff --git a/src/cli/help.ts b/src/cli/help.ts\nindex 90da19a..ac249db 100644\n--- a/src/cli/help.ts\n+++ b/src/cli/help.ts\n@@ -36,7 +36,7 @@ SETUP FLAGS\n   --timeout_minutes N  Daemon idle timeout (default: 30)\n \n INTERACTIVE COMMANDS (TUI mode)\n-  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n+  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n   /r              Reply to last whisper\n   /who [filter]   Who search\n   /invite <name>  Invite player to group\ndiff --git a/src/daemon/commands.test.ts b/src/daemon/commands.test.ts\nindex 663e440..67336f2 100644\n--- a/src/daemon/commands.test.ts\n+++ b/src/daemon/commands.test.ts\n@@ -74,6 +74,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"EMOTE\", () => {\n+    expect(parseIpcCommand(\"EMOTE waves hello\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves hello\",\n+    });\n+  });\n+\n   test(\"WHISPER\", () => {\n     expect(parseIpcCommand(\"WHISPER Xiara follow me\")).toEqual({\n       type: \"whisper\",\n@@ -202,6 +209,13 @@ describe(\"parseIpcCommand\", () => {\n     });\n   });\n \n+  test(\"slash /emote maps to emote\", () => {\n+    expect(parseIpcCommand(\"/emote waves\")).toEqual({\n+      type: \"emote\",\n+      message: \"waves\",\n+    });\n+  });\n+\n   test(\"slash /who maps to who with filter\", () => {\n     expect(parseIpcCommand(\"/who mage\")).toEqual({\n       type: \"who\",\n@@ -280,7 +294,6 @@ describe(\"parseIpcCommand\", () => {\n       [\"ROLL\", \"Random roll\"],\n       [\"DND\", \"Player status\"],\n       [\"AFK\", \"Player status\"],\n-      [\"EMOTE waves\", \"Text emotes\"],\n     ] as const;\n \n     for (const [input, feature] of cases) {\n@@ -467,6 +480,24 @@ describe(\"dispatchCommand\", () => {\n     expect(socket.written()).toBe(\"OK\\n\\n\");\n   });\n \n+  test(\"emote calls sendEmote and writes OK\", async () => {\n+    const handle = createMockHandle();\n+    const events = new RingBuffer<EventEntry>(10);\n+    const socket = createMockSocket();\n+    const cleanup = jest.fn();\n+\n+    await dispatchCommand(\n+      { type: \"emote\", message: \"waves hello\" },\n+      handle,\n+      events,\n+      socket,\n+      cleanup,\n+    );\n+\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+    expect(socket.written()).toBe(\"OK\\n\\n\");\n+  });\n+\n   test(\"whisper calls sendWhisper and writes OK\", async () => {\n     const handle = createMockHandle();\n     const events = new RingBuffer<EventEntry>(10);\n@@ -1661,6 +1692,13 @@ describe(\"IPC round-trip\", () => {\n     expect(handle.sendSay).toHaveBeenCalledWith(\"hello world\");\n   });\n \n+  test(\"EMOTE returns OK and calls handle\", async () => {\n+    startTestServer();\n+    const lines = await sendToSocket(\"EMOTE waves hello\", sockPath);\n+    expect(lines).toEqual([\"OK\"]);\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n+  });\n+\n   test(\"WHISPER returns OK\", async () => {\n     startTestServer();\n     const lines = await sendToSocket(\"WHISPER Xiara hey\", sockPath);\ndiff --git a/src/daemon/commands.ts b/src/daemon/commands.ts\nindex 264e6b1..c49c3f2 100644\n--- a/src/daemon/commands.ts\n+++ b/src/daemon/commands.ts\n@@ -37,6 +37,7 @@ export type IpcCommand =\n   | { type: \"yell\"; message: string }\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"read\" }\n   | { type: \"read_json\" }\n@@ -68,6 +69,7 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n       case \"yell\":\n       case \"guild\":\n       case \"party\":\n+      case \"emote\":\n         return parsed;\n       case \"whisper\":\n         return parsed;\n@@ -104,8 +106,14 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"YELL\":\n     case \"GUILD\":\n     case \"PARTY\":\n+    case \"EMOTE\":\n       return {\n-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n+        type: verb.toLowerCase() as\n+          | \"say\"\n+          | \"yell\"\n+          | \"guild\"\n+          | \"party\"\n+          | \"emote\",\n         message: rest,\n       };\n     case \"WHISPER\": {\n@@ -180,8 +188,6 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"DND\":\n     case \"AFK\":\n       return { type: \"unimplemented\", feature: \"Player status\" };\n-    case \"EMOTE\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n     default:\n       return line ? { type: \"chat\", message: line } : undefined;\n   }\n@@ -246,6 +252,10 @@ export async function dispatchCommand(\n       handle.sendParty(cmd.message);\n       writeLines(socket, [\"OK\"]);\n       return false;\n+    case \"emote\":\n+      handle.sendEmote(cmd.message);\n+      writeLines(socket, [\"OK\"]);\n+      return false;\n     case \"whisper\":\n       handle.sendWhisper(cmd.target, cmd.message);\n       writeLines(socket, [\"OK\"]);\ndiff --git a/src/daemon/start.test.ts b/src/daemon/start.test.ts\nindex 8c7d50c..21b51bf 100644\n--- a/src/daemon/start.test.ts\n+++ b/src/daemon/start.test.ts\n@@ -50,6 +50,7 @@ function makeMockClient(): {\n         sendGuild: jest.fn(),\n         sendParty: jest.fn(),\n         sendRaid: jest.fn(),\n+        sendEmote: jest.fn(),\n         sendWhisper: jest.fn(),\n         sendChannel: jest.fn(),\n         getChannel: jest.fn(),\ndiff --git a/src/test/mock-handle.ts b/src/test/mock-handle.ts\nindex 5b1da9e..a74be9e 100644\n--- a/src/test/mock-handle.ts\n+++ b/src/test/mock-handle.ts\n@@ -37,6 +37,7 @@ export function createMockHandle(): WorldHandle & {\n     sendGuild: jest.fn(),\n     sendParty: jest.fn(),\n     sendRaid: jest.fn(),\n+    sendEmote: jest.fn(),\n     sendChannel: jest.fn(),\n     getChannel: jest.fn(),\n     who: jest.fn(async () => []),\ndiff --git a/src/ui/tui.test.ts b/src/ui/tui.test.ts\nindex dba55be..ce1e4d2 100644\n--- a/src/ui/tui.test.ts\n+++ b/src/ui/tui.test.ts\n@@ -291,16 +291,16 @@ describe(\"parseCommand\", () => {\n         feature: \"Player status\",\n       });\n     });\n-    test(\"/e returns unimplemented\", () => {\n+    test(\"/e sends emote\", () => {\n       expect(parseCommand(\"/e waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n-    test(\"/emote returns unimplemented\", () => {\n+    test(\"/emote sends emote\", () => {\n       expect(parseCommand(\"/emote waves\")).toEqual({\n-        type: \"unimplemented\",\n-        feature: \"Text emotes\",\n+        type: \"emote\",\n+        message: \"waves\",\n       });\n     });\n   });\n@@ -452,7 +452,7 @@ describe(\"startTui\", () => {\n     await done;\n   });\n \n-  test(\"dispatches yell, guild, party, raid commands\", async () => {\n+  test(\"dispatches yell, guild, party, raid, emote commands\", async () => {\n     const handle = createMockHandle();\n     const input = new PassThrough();\n \n@@ -461,12 +461,14 @@ describe(\"startTui\", () => {\n     writeLine(input, \"/g guild msg\");\n     writeLine(input, \"/p party msg\");\n     writeLine(input, \"/raid pull now\");\n+    writeLine(input, \"/e waves hello\");\n     await flush();\n \n     expect(handle.sendYell).toHaveBeenCalledWith(\"LOUD\");\n     expect(handle.sendGuild).toHaveBeenCalledWith(\"guild msg\");\n     expect(handle.sendParty).toHaveBeenCalledWith(\"party msg\");\n     expect(handle.sendRaid).toHaveBeenCalledWith(\"pull now\");\n+    expect(handle.sendEmote).toHaveBeenCalledWith(\"waves hello\");\n \n     input.end();\n     await done;\ndiff --git a/src/ui/tui.ts b/src/ui/tui.ts\nindex c85b02f..97934c7 100644\n--- a/src/ui/tui.ts\n+++ b/src/ui/tui.ts\n@@ -21,6 +21,7 @@ export type Command =\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n   | { type: \"raid\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"reply\"; message: string }\n   | { type: \"channel\"; target: string; message: string }\n@@ -133,7 +134,7 @@ export function parseCommand(input: string): Command {\n       return { type: \"unimplemented\", feature: \"Player status\" };\n     case \"/e\":\n     case \"/emote\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n+      return { type: \"emote\", message: rest };\n     default: {\n       const channelMatch = cmd.match(/^\\/(\\d+)$/);\n       if (channelMatch) {\n@@ -520,6 +521,9 @@ export async function executeCommand(\n     case \"raid\":\n       state.handle.sendRaid(cmd.message);\n       break;\n+    case \"emote\":\n+      state.handle.sendEmote(cmd.message);\n+      break;\n     case \"whisper\":\n       state.handle.sendWhisper(cmd.target, cmd.message);\n       state.lastWhisperFrom = cmd.target;\ndiff --git a/src/wow/client.test.ts b/src/wow/client.test.ts\nindex 93181ec..e529890 100644\n--- a/src/wow/client.test.ts\n+++ b/src/wow/client.test.ts\n@@ -767,6 +767,25 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendEmote sends message and receives echo\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendEmote(\"test emote\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"test emote\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendChannel sends message and receives echo\", async () => {\n     const ws = await startMockWorldServer();\n     try {\n@@ -1150,6 +1169,26 @@ describe(\"world error paths\", () => {\n     }\n   });\n \n+  test(\"sendInCurrentMode dispatches emote\", async () => {\n+    const ws = await startMockWorldServer();\n+    try {\n+      const handle = await worldSession(\n+        { ...base, host: \"127.0.0.1\", port: ws.port },\n+        fakeAuth(ws.port),\n+      );\n+      handle.setLastChatMode({ type: \"emote\" });\n+      const received = new Promise<ChatMessage>((r) => handle.onMessage(r));\n+      handle.sendInCurrentMode(\"emote test\");\n+      const msg = await received;\n+      expect(msg.type).toBe(ChatType.EMOTE);\n+      expect(msg.message).toBe(\"emote test\");\n+      handle.close();\n+      await handle.closed;\n+    } finally {\n+      ws.stop();\n+    }\n+  });\n+\n   test(\"sendInCurrentMode dispatches channel\", async () => {\n     const ws = await startMockWorldServer();\n     try {\ndiff --git a/src/wow/client.ts b/src/wow/client.ts\nindex 4edec05..b17a443 100644\n--- a/src/wow/client.ts\n+++ b/src/wow/client.ts\n@@ -151,6 +151,7 @@ export type ChatMode =\n   | { type: \"guild\" }\n   | { type: \"party\" }\n   | { type: \"raid\" }\n+  | { type: \"emote\" }\n   | { type: \"whisper\"; target: string }\n   | { type: \"channel\"; channel: string };\n \n@@ -164,6 +165,7 @@ export type WorldHandle = {\n   sendGuild(message: string): void;\n   sendParty(message: string): void;\n   sendRaid(message: string): void;\n+  sendEmote(message: string): void;\n   sendChannel(channel: string, message: string): void;\n   getChannel(index: number): string | undefined;\n   who(opts?: {\n@@ -1144,6 +1146,14 @@ export function worldSession(\n             buildChatMessage(ChatType.RAID, lang, message),\n           );\n         },\n+        sendEmote(message) {\n+          conn.lastChatMode = { type: \"emote\" };\n+          sendPacket(\n+            conn,\n+            GameOpcode.CMSG_MESSAGE_CHAT,\n+            buildChatMessage(ChatType.EMOTE, lang, message),\n+          );\n+        },\n         sendChannel(channel, message) {\n           conn.lastChatMode = { type: \"channel\", channel };\n           sendPacket(\n@@ -1184,6 +1194,9 @@ export function worldSession(\n             case \"raid\":\n               handle.sendRaid(message);\n               break;\n+            case \"emote\":\n+              handle.sendEmote(message);\n+              break;\n             case \"whisper\":\n               handle.sendWhisper(mode.target, message);\n               break;\n```\n\nReview the complete diff above. This contains all code changes in the PR.\n\n\nOBJECTIVE:\nPerform a security-focused code review to identify HIGH-CONFIDENCE security vulnerabilities that could have real exploitation potential. This is not a general code review - focus ONLY on security implications newly added by this PR. Do not comment on existing security concerns.\n\nCRITICAL INSTRUCTIONS:\n1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability\n2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings\n3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise\n4. EXCLUSIONS: Do NOT report the following issue types:\n   - Denial of Service (DOS) vulnerabilities, even if they allow service disruption\n   - Secrets or sensitive data stored on disk (these are handled by other processes)\n   - Rate limiting or resource exhaustion issues\n\nSECURITY CATEGORIES TO EXAMINE:\n\n**Input Validation Vulnerabilities:**\n- SQL injection via unsanitized user input\n- Command injection in system calls or subprocesses\n- XXE injection in XML parsing\n- Template injection in templating engines\n- NoSQL injection in database queries\n- Path traversal in file operations\n\n**Authentication & Authorization Issues:**\n- Authentication bypass logic\n- Privilege escalation paths\n- Session management flaws\n- JWT token vulnerabilities\n- Authorization logic bypasses\n\n**Crypto & Secrets Management:**\n- Hardcoded API keys, passwords, or tokens\n- Weak cryptographic algorithms or implementations\n- Improper key storage or management\n- Cryptographic randomness issues\n- Certificate validation bypasses\n\n**Injection & Code Execution:**\n- Remote code execution via deseralization\n- Pickle injection in Python\n- YAML deserialization vulnerabilities\n- Eval injection in dynamic code execution\n- XSS vulnerabilities in web applications (reflected, stored, DOM-based)\n\n**Data Exposure:**\n- Sensitive data logging or storage\n- PII handling violations\n- API endpoint data leakage\n- Debug information exposure\n\nAdditional notes:\n- Even if something is only exploitable from the local network, it can still be a HIGH severity issue\n\nANALYSIS METHODOLOGY:\n\nPhase 1 - Repository Context Research (Use file search tools):\n- Identify existing security frameworks and libraries in use\n- Look for established secure coding patterns in the codebase\n- Examine existing sanitization and validation patterns\n- Understand the project's security model and threat model\n\nPhase 2 - Comparative Analysis:\n- Compare new code changes against existing security patterns\n- Identify deviations from established secure practices\n- Look for inconsistent security implementations\n- Flag code that introduces new attack surfaces\n\nPhase 3 - Vulnerability Assessment:\n- Examine each modified file for security implications\n- Trace data flow from user inputs to sensitive operations\n- Look for privilege boundaries being crossed unsafely\n- Identify injection points and unsafe deserialization\n\nREQUIRED OUTPUT FORMAT:\n\nYou MUST output your findings in markdown. The markdown output should contain the file, line number, severity, category (e.g. `sql_injection` or `xss`), description, exploit scenario, and fix recommendation.\n\nFor example:\n\n# Vuln 1: XSS: `foo.py:42`\n\n* Severity: High\n* Description: User input from `username` parameter is directly interpolated into HTML without escaping, allowing reflected XSS attacks\n* Exploit Scenario: Attacker crafts URL like /bar?q=<script>alert(document.cookie)</script> to execute JavaScript in victim's browser, enabling session hijacking or data theft\n* Recommendation: Use Flask's escape() function or Jinja2 templates with auto-escaping enabled for all user inputs rendered in HTML\n\nSEVERITY GUIDELINES:\n- **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass\n- **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact\n- **LOW**: Defense-in-depth issues or lower-impact vulnerabilities\n\nCONFIDENCE SCORING:\n- 0.9-1.0: Certain exploit path identified, tested if possible\n- 0.8-0.9: Clear vulnerability pattern with known exploitation methods\n- 0.7-0.8: Suspicious pattern requiring specific conditions to exploit\n- Below 0.7: Don't report (too speculative)\n\nFINAL REMINDER:\nFocus on HIGH and MEDIUM findings only. Better to miss some theoretical issues than flood the report with false positives. Each finding should be something a security engineer would confidently raise in a PR review.\n\nFALSE POSITIVE FILTERING:\n\n> You do not need to run commands to reproduce the vulnerability, just read the code to determine if it is a real vulnerability. Do not use the bash tool or write to any files.\n>\n> HARD EXCLUSIONS - Automatically exclude findings matching these patterns:\n> 1. Denial of Service (DOS) vulnerabilities or resource exhaustion attacks.\n> 2. Secrets or credentials stored on disk if they are otherwise secured.\n> 3. Rate limiting concerns or service overload scenarios.\n> 4. Memory consumption or CPU exhaustion issues.\n> 5. Lack of input validation on non-security-critical fields without proven security impact.\n> 6. Input sanitization concerns for GitHub Action workflows unless they are clearly triggerable via untrusted input.\n> 7. A lack of hardening measures. Code is not expected to implement all security best practices, only flag concrete vulnerabilities.\n> 8. Race conditions or timing attacks that are theoretical rather than practical issues. Only report a race condition if it is concretely problematic.\n> 9. Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.\n> 10. Memory safety issues such as buffer overflows or use-after-free-vulnerabilities are impossible in rust. Do not report memory safety issues in rust or any other memory safe languages.\n> 11. Files that are only unit tests or only used as part of running tests.\n> 12. Log spoofing concerns. Outputting un-sanitized user input to logs is not a vulnerability.\n> 13. SSRF vulnerabilities that only control the path. SSRF is only a concern if it can control the host or protocol.\n> 14. Including user-controlled content in AI system prompts is not a vulnerability.\n> 15. Regex injection. Injecting untrusted content into a regex is not a vulnerability.\n> 16. Regex DOS concerns.\n> 16. Insecure documentation. Do not report any findings in documentation files such as markdown files.\n> 17. A lack of audit logs is not a vulnerability.\n>\n> PRECEDENTS -\n> 1. Logging high value secrets in plaintext is a vulnerability. Logging URLs is assumed to be safe.\n> 2. UUIDs can be assumed to be unguessable and do not need to be validated.\n> 3. Environment variables and CLI flags are trusted values. Attackers are generally not able to modify them in a secure environment. Any attack that relies on controlling an environment variable is invalid.\n> 4. Resource management issues such as memory or file descriptor leaks are not valid.\n> 5. Subtle or low impact web vulnerabilities such as tabnabbing, XS-Leaks, prototype pollution, and open redirects should not be reported unless they are extremely high confidence.\n> 6. React and Angular are generally secure against XSS. These frameworks do not need to sanitize or escape user input unless it is using dangerouslySetInnerHTML, bypassSecurityTrustHtml, or similar methods. Do not report XSS vulnerabilities in React or Angular components or tsx files unless they are using unsafe methods.\n> 7. Most vulnerabilities in github action workflows are not exploitable in practice. Before validating a github action workflow vulnerability ensure it is concrete and has a very specific attack path.\n> 8. A lack of permission checking or authentication in client-side JS/TS code is not a vulnerability. Client-side code is not trusted and does not need to implement these checks, they are handled on the server-side. The same applies to all flows that send untrusted data to the backend, the backend is responsible for validating and sanitizing all inputs.\n> 9. Only include MEDIUM findings if they are obvious and concrete issues.\n> 10. Most vulnerabilities in ipython notebooks (*.ipynb files) are not exploitable in practice. Before validating a notebook vulnerability ensure it is concrete and has a very specific attack path where untrusted input can trigger the vulnerability.\n> 11. Logging non-PII data is not a vulnerability even if the data may be sensitive. Only report logging vulnerabilities if they expose sensitive information such as secrets, passwords, or personally identifiable information (PII).\n> 12. Command injection vulnerabilities in shell scripts are generally not exploitable in practice since shell scripts generally do not run with untrusted user input. Only report command injection vulnerabilities in shell scripts if they are concrete and have a very specific attack path for untrusted input.\n>\n> SIGNAL QUALITY CRITERIA - For remaining findings, assess:\n> 1. Is there a concrete, exploitable vulnerability with a clear attack path?\n> 2. Does this represent a real security risk vs theoretical best practice?\n> 3. Are there specific code locations and reproduction steps?\n> 4. Would this finding be actionable for a security team?\n>\n> For each finding, assign a confidence score from 1-10:\n> - 1-3: Low confidence, likely false positive or noise\n> - 4-6: Medium confidence, needs investigation\n> - 7-10: High confidence, likely true vulnerability\n\nSTART ANALYSIS:\n\nBegin your analysis now. Do this in 3 steps:\n\n1. Use a sub-task to identify vulnerabilities. Use the repository exploration tools to understand the codebase context, then analyze the PR changes for security implications. In the prompt for this sub-task, include all of the above.\n2. Then for each vulnerability identified by the above sub-task, create a new sub-task to filter out false-positives. Launch these sub-tasks as parallel sub-tasks. In the prompt for these sub-tasks, include everything in the \"FALSE POSITIVE FILTERING\" instructions.\n3. Filter out any vulnerabilities where the sub-task reported a confidence less than 8.\n\nYour final reply must contain the markdown report and nothing else."}]},"isMeta":true,"uuid":"3546aecb-2ddc-4153-9069-317127578360","timestamp":"2026-02-28T23:49:57.985Z"}
{"parentUuid":"3546aecb-2ddc-4153-9069-317127578360","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01QsyMCky2yqtKs7TxsCMF9N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012YacJApiwG7DfoJVW1XFd7","name":"Agent","input":{"description":"Security vulnerability analysis","subagent_type":"general-purpose","prompt":"You are a senior security engineer conducting a focused security review of changes on the `feat/text-emote` branch of the tuicraft project (a WoW 3.3.5a chat client).\n\nThe diff adds text emote support (`/e` and `/emote` slash commands) by wiring them through the existing chat pipeline. Here is the complete diff:\n\n```diff\ndiff --git a/src/daemon/commands.ts b/src/daemon/commands.ts\nindex 264e6b1..c49c3f2 100644\n--- a/src/daemon/commands.ts\n+++ b/src/daemon/commands.ts\n@@ -37,6 +37,7 @@ export type IpcCommand =\n   | { type: \"yell\"; message: string }\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"read\" }\n   | { type: \"read_json\" }\n@@ -68,6 +69,7 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n       case \"yell\":\n       case \"guild\":\n       case \"party\":\n+      case \"emote\":\n         return parsed;\n       case \"whisper\":\n         return parsed;\n@@ -104,8 +106,14 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"YELL\":\n     case \"GUILD\":\n     case \"PARTY\":\n+    case \"EMOTE\":\n       return {\n-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n+        type: verb.toLowerCase() as\n+          | \"say\"\n+          | \"yell\"\n+          | \"guild\"\n+          | \"party\"\n+          | \"emote\",\n         message: rest,\n       };\n     case \"WHISPER\": {\n@@ -180,8 +188,6 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"DND\":\n     case \"AFK\":\n       return { type: \"unimplemented\", feature: \"Player status\" };\n-    case \"EMOTE\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n     default:\n       return line ? { type: \"chat\", message: line } : undefined;\n   }\n@@ -246,6 +252,10 @@ export async function dispatchCommand(\n       handle.sendParty(cmd.message);\n       writeLines(socket, [\"OK\"]);\n       return false;\n+    case \"emote\":\n+      handle.sendEmote(cmd.message);\n+      writeLines(socket, [\"OK\"]);\n+      return false;\n     case \"whisper\":\n       handle.sendWhisper(cmd.target, cmd.message);\n       writeLines(socket, [\"OK\"]);\n\ndiff --git a/src/ui/tui.ts b/src/ui/tui.ts\nindex c85b02f..97934c7 100644\n--- a/src/ui/tui.ts\n+++ b/src/ui/tui.ts\n@@ -21,6 +21,7 @@ export type Command =\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n   | { type: \"raid\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"reply\"; message: string }\n   | { type: \"channel\"; target: string; message: string }\n@@ -133,7 +134,7 @@ export function parseCommand(input: string): Command {\n       return { type: \"unimplemented\", feature: \"Player status\" };\n     case \"/e\":\n     case \"/emote\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n+      return { type: \"emote\", message: rest };\n     default: {\n       const channelMatch = cmd.match(/^\\/(\\d+)$/);\n       if (channelMatch) {\n@@ -520,6 +521,9 @@ export async function executeCommand(\n     case \"raid\":\n       state.handle.sendRaid(cmd.message);\n       break;\n+    case \"emote\":\n+      state.handle.sendEmote(cmd.message);\n+      break;\n     case \"whisper\":\n       state.handle.sendWhisper(cmd.target, cmd.message);\n       state.lastWhisperFrom = cmd.target;\n\ndiff --git a/src/wow/client.ts b/src/wow/client.ts\nindex 4edec05..b17a443 100644\n--- a/src/wow/client.ts\n+++ b/src/wow/client.ts\n@@ -151,6 +151,7 @@ export type ChatMode =\n   | { type: \"guild\" }\n   | { type: \"party\" }\n   | { type: \"raid\" }\n+  | { type: \"emote\" }\n   | { type: \"whisper\"; target: string }\n   | { type: \"channel\"; channel: string };\n \n@@ -164,6 +165,7 @@ export type WorldHandle = {\n   sendGuild(message: string): void;\n   sendParty(message: string): void;\n   sendRaid(message: string): void;\n+  sendEmote(message: string): void;\n   sendChannel(channel: string, message: string): void;\n   getChannel(index: number): string | undefined;\n   who(opts?: {\n@@ -1144,6 +1146,14 @@ export function worldSession(\n             buildChatMessage(ChatType.RAID, lang, message),\n           );\n         },\n+        sendEmote(message) {\n+          conn.lastChatMode = { type: \"emote\" };\n+          sendPacket(\n+            conn,\n+            GameOpcode.CMSG_MESSAGE_CHAT,\n+            buildChatMessage(ChatType.EMOTE, lang, message),\n+          );\n+        },\n         sendChannel(channel, message) {\n           conn.lastChatMode = { type: \"channel\", channel };\n           sendPacket(\n@@ -1184,6 +1194,9 @@ export function worldSession(\n             case \"raid\":\n               handle.sendRaid(message);\n               break;\n+            case \"emote\":\n+              handle.sendEmote(message);\n+              break;\n             case \"whisper\":\n               handle.sendWhisper(mode.target, message);\n               break;\n```\n\nThe remaining changed files are: test files (commands.test.ts, start.test.ts, mock-handle.ts, tui.test.ts, client.test.ts) and documentation files (SKILL.md, README.md, manual.md, help.ts).\n\nYour task: Identify any security vulnerabilities introduced by this PR. Focus on:\n\n1. **Input Validation**: Is user input from the emote message sanitized before being sent over the wire or displayed? Could it cause injection issues?\n2. **Command Injection**: Could crafted emote messages inject into system calls or IPC?\n3. **Protocol Security**: Does the emote message get properly encoded in the WoW protocol packet? Could it cause buffer overflow or protocol confusion?\n4. **Authentication/Authorization**: Does this bypass any access controls?\n5. **Data Exposure**: Could emote messages leak sensitive data?\n\nTo understand the security context, examine:\n- How `buildChatMessage` constructs the packet (src/wow/protocol/chat.ts)\n- How the IPC socket handles data (look at the unix socket communication pattern)\n- How messages are displayed/logged\n- How other chat types (say, yell) handle the same data flow\n\nProvide a list of any vulnerabilities found with file, line number, severity, category, description, exploit scenario, and fix recommendation. If no vulnerabilities are found, state that clearly.\n"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":108594,"cache_read_input_tokens":19120,"output_tokens":2085,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":108594,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbN1otT3nuu4rwFaLg3X","type":"assistant","uuid":"d3dd64d7-1d5d-4a07-b7f5-323ef07f848a","timestamp":"2026-02-28T23:50:34.642Z"}
{"parentUuid":"d3dd64d7-1d5d-4a07-b7f5-323ef07f848a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012YacJApiwG7DfoJVW1XFd7","type":"tool_result","content":[{"type":"text","text":"## Security Review: Text Emote Support (`feat/text-emote` branch)\n\n### Summary\n\n**No security vulnerabilities were found in this PR.** The text emote feature introduces no new attack surface beyond what already exists for the other chat types (say, yell, guild, party, raid). Below is the detailed analysis for each security dimension.\n\n---\n\n### 1. Input Validation\n\n**Finding: No vulnerability.**\n\nThe emote message follows the exact same data flow as every other chat type. In the TUI path (`/home/openclaw/code/tuicraft/src/ui/tui.ts`, line 136-137), `/e` and `/emote` parse the rest of the input line into `{ type: \"emote\", message: rest }` -- the same pattern used by `/s`, `/y`, `/g`, `/p`, and `/raid`. In the IPC/daemon path (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, lines 109-117), the `EMOTE` verb extracts the message the same way `SAY`, `YELL`, `GUILD`, and `PARTY` do. No additional sanitization is needed at this layer because:\n\n- The message is passed directly to `buildChatMessage`, which encodes it as a null-terminated C string via `PacketWriter.cString()` (`/home/openclaw/code/tuicraft/src/wow/protocol/packet.ts`, lines 159-163). This uses `TextEncoder.encode()` which produces valid UTF-8, then appends a null byte. There is no possibility of injection into the binary protocol.\n- On the display side, incoming emote messages go through `formatMessage` (`/home/openclaw/code/tuicraft/src/ui/tui.ts`, line 165) which applies `stripColorCodes` (`/home/openclaw/code/tuicraft/src/lib/strip-colors.ts`) to strip WoW color/hyperlink markup. The emote type (`ChatType.EMOTE = 0x0a`) is already mapped in `CHAT_TYPE_LABELS` (line 158) and `JSON_TYPE_LABELS` (line 194), so it renders through the same safe path as all other message types.\n\n### 2. Command Injection\n\n**Finding: No vulnerability.**\n\nThe IPC transport uses a Unix domain socket (`/home/openclaw/code/tuicraft/src/daemon/server.ts`, line 123-126, `Bun.listen({ unix: sock })`). Commands are line-delimited text parsed by `parseIpcCommand` (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, line 64). The emote command is dispatched to `handle.sendEmote(cmd.message)` (line 255-258) which calls directly into the WoW protocol layer -- no shell execution, no `eval`, no process spawning. The message string flows from the Unix socket straight into a binary protocol packet. This is identical to how `handle.sendSay`, `handle.sendYell`, etc. work.\n\n### 3. Protocol Security\n\n**Finding: No vulnerability.**\n\nThe `sendEmote` implementation (`/home/openclaw/code/tuicraft/src/wow/client.ts`, lines 1149-1156) is structurally identical to `sendSay`, `sendYell`, `sendGuild`, `sendParty`, and `sendRaid`:\n\n```typescript\nsendEmote(message) {\n  conn.lastChatMode = { type: \"emote\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.EMOTE, lang, message),\n  );\n},\n```\n\nIt uses the same opcode (`CMSG_MESSAGE_CHAT`), the same `buildChatMessage` function (`/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts`, lines 70-84), and the same `sendPacket` -> `buildOutgoingPacket` pipeline (`/home/openclaw/code/tuicraft/src/wow/protocol/world.ts`, lines 212-229). The packet is properly length-prefixed (2-byte big-endian size field) and optionally Arc4-encrypted. `ChatType.EMOTE` (0x0a) is not `WHISPER` or `CHANNEL`, so it takes the no-target branch in `buildChatMessage` (line 79), producing the correct wire format: `[type:u32LE][lang:u32LE][message:cstring]`.\n\nThere is no buffer overflow risk. `PacketWriter` uses a dynamically growing buffer (`grow()` method, line 104-111) and `cString` writes exactly the encoded bytes plus one null terminator. The server enforces its own message length limits.\n\n### 4. Authentication/Authorization\n\n**Finding: No vulnerability.**\n\nThe emote command does not bypass any access controls. It requires an active `WorldHandle`, which is only created after successful SRP authentication (`authHandshake`/`authWithRetry`) and character login (`selectCharacter`). The IPC socket at `$XDG_RUNTIME_DIR/tuicraft/sock` is protected by the filesystem permissions of the runtime directory (typically mode 0700 under XDG_RUNTIME_DIR). No new authentication surface is introduced.\n\n### 5. Data Exposure\n\n**Finding: No vulnerability.**\n\nEmote messages are logged via `onChatMessage` -> `log.append()` (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, lines 493-501) through the same `SessionLog` path as all other chat types. The session log at `$XDG_STATE_HOME/tuicraft/session.log` stores the message with `stripColorCodes` applied. No credentials, session keys, or internal state are exposed. The emote message content is user-supplied text that would be visible to other players in-game anyway.\n\n---\n\n### Pre-existing Observations (Not Introduced by This PR)\n\nWhile reviewing the surrounding code, I noted these characteristics that are **not introduced or changed by this PR**, and are consistent with the project's existing security posture:\n\n1. **No message length validation on the client side**: None of the chat types (say, yell, guild, party, raid, emote, whisper, channel) validate message length before sending. The WoW 3.3.5a server enforces a 255-byte limit on chat messages and will silently truncate or reject oversized messages, so this is a server-side concern rather than a client vulnerability.\n\n2. **Null bytes in messages**: If a user somehow sends a message containing a null byte (`\\0`), the `cString` encoding would cause the server to see a truncated message. This is benign -- the server would process a shorter message. This affects all chat types equally and is not a security issue.\n\n3. **IPC socket uses default Bun.listen permissions**: The Unix socket at `runtimeDir()/sock` relies on the parent directory's permissions for access control. Under `XDG_RUNTIME_DIR` (typically `/run/user/<uid>`), this is restricted to the owning user. The fallback path (`/tmp/tuicraft-<uid>`) creates a user-specific directory via `mkdir({ recursive: true })`. This is a pre-existing design choice, not affected by this PR.\n\n### Conclusion\n\n**No security vulnerabilities are introduced by this PR.** The text emote feature is a minimal, mechanical extension that adds one more variant to an existing discriminated union type and wires it through the exact same validated, binary-encoded, encrypted protocol pipeline used by all other chat types. The implementation is structurally identical to `sendSay`/`sendYell`/`sendGuild`/`sendParty`/`sendRaid` across all three layers (TUI parsing, IPC daemon, WoW protocol)."},{"type":"text","text":"agentId: ac3b81c4b1a1b6fbb (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 64066\ntool_uses: 25\nduration_ms: 117639</usage>"}]}]},"uuid":"2983c2bb-6112-4dd3-b02a-b8b217803804","timestamp":"2026-02-28T23:52:32.301Z","toolUseResult":{"status":"completed","prompt":"You are a senior security engineer conducting a focused security review of changes on the `feat/text-emote` branch of the tuicraft project (a WoW 3.3.5a chat client).\n\nThe diff adds text emote support (`/e` and `/emote` slash commands) by wiring them through the existing chat pipeline. Here is the complete diff:\n\n```diff\ndiff --git a/src/daemon/commands.ts b/src/daemon/commands.ts\nindex 264e6b1..c49c3f2 100644\n--- a/src/daemon/commands.ts\n+++ b/src/daemon/commands.ts\n@@ -37,6 +37,7 @@ export type IpcCommand =\n   | { type: \"yell\"; message: string }\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"read\" }\n   | { type: \"read_json\" }\n@@ -68,6 +69,7 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n       case \"yell\":\n       case \"guild\":\n       case \"party\":\n+      case \"emote\":\n         return parsed;\n       case \"whisper\":\n         return parsed;\n@@ -104,8 +106,14 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"YELL\":\n     case \"GUILD\":\n     case \"PARTY\":\n+    case \"EMOTE\":\n       return {\n-        type: verb.toLowerCase() as \"say\" | \"yell\" | \"guild\" | \"party\",\n+        type: verb.toLowerCase() as\n+          | \"say\"\n+          | \"yell\"\n+          | \"guild\"\n+          | \"party\"\n+          | \"emote\",\n         message: rest,\n       };\n     case \"WHISPER\": {\n@@ -180,8 +188,6 @@ export function parseIpcCommand(line: string): IpcCommand | undefined {\n     case \"DND\":\n     case \"AFK\":\n       return { type: \"unimplemented\", feature: \"Player status\" };\n-    case \"EMOTE\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n     default:\n       return line ? { type: \"chat\", message: line } : undefined;\n   }\n@@ -246,6 +252,10 @@ export async function dispatchCommand(\n       handle.sendParty(cmd.message);\n       writeLines(socket, [\"OK\"]);\n       return false;\n+    case \"emote\":\n+      handle.sendEmote(cmd.message);\n+      writeLines(socket, [\"OK\"]);\n+      return false;\n     case \"whisper\":\n       handle.sendWhisper(cmd.target, cmd.message);\n       writeLines(socket, [\"OK\"]);\n\ndiff --git a/src/ui/tui.ts b/src/ui/tui.ts\nindex c85b02f..97934c7 100644\n--- a/src/ui/tui.ts\n+++ b/src/ui/tui.ts\n@@ -21,6 +21,7 @@ export type Command =\n   | { type: \"guild\"; message: string }\n   | { type: \"party\"; message: string }\n   | { type: \"raid\"; message: string }\n+  | { type: \"emote\"; message: string }\n   | { type: \"whisper\"; target: string; message: string }\n   | { type: \"reply\"; message: string }\n   | { type: \"channel\"; target: string; message: string }\n@@ -133,7 +134,7 @@ export function parseCommand(input: string): Command {\n       return { type: \"unimplemented\", feature: \"Player status\" };\n     case \"/e\":\n     case \"/emote\":\n-      return { type: \"unimplemented\", feature: \"Text emotes\" };\n+      return { type: \"emote\", message: rest };\n     default: {\n       const channelMatch = cmd.match(/^\\/(\\d+)$/);\n       if (channelMatch) {\n@@ -520,6 +521,9 @@ export async function executeCommand(\n     case \"raid\":\n       state.handle.sendRaid(cmd.message);\n       break;\n+    case \"emote\":\n+      state.handle.sendEmote(cmd.message);\n+      break;\n     case \"whisper\":\n       state.handle.sendWhisper(cmd.target, cmd.message);\n       state.lastWhisperFrom = cmd.target;\n\ndiff --git a/src/wow/client.ts b/src/wow/client.ts\nindex 4edec05..b17a443 100644\n--- a/src/wow/client.ts\n+++ b/src/wow/client.ts\n@@ -151,6 +151,7 @@ export type ChatMode =\n   | { type: \"guild\" }\n   | { type: \"party\" }\n   | { type: \"raid\" }\n+  | { type: \"emote\" }\n   | { type: \"whisper\"; target: string }\n   | { type: \"channel\"; channel: string };\n \n@@ -164,6 +165,7 @@ export type WorldHandle = {\n   sendGuild(message: string): void;\n   sendParty(message: string): void;\n   sendRaid(message: string): void;\n+  sendEmote(message: string): void;\n   sendChannel(channel: string, message: string): void;\n   getChannel(index: number): string | undefined;\n   who(opts?: {\n@@ -1144,6 +1146,14 @@ export function worldSession(\n             buildChatMessage(ChatType.RAID, lang, message),\n           );\n         },\n+        sendEmote(message) {\n+          conn.lastChatMode = { type: \"emote\" };\n+          sendPacket(\n+            conn,\n+            GameOpcode.CMSG_MESSAGE_CHAT,\n+            buildChatMessage(ChatType.EMOTE, lang, message),\n+          );\n+        },\n         sendChannel(channel, message) {\n           conn.lastChatMode = { type: \"channel\", channel };\n           sendPacket(\n@@ -1184,6 +1194,9 @@ export function worldSession(\n             case \"raid\":\n               handle.sendRaid(message);\n               break;\n+            case \"emote\":\n+              handle.sendEmote(message);\n+              break;\n             case \"whisper\":\n               handle.sendWhisper(mode.target, message);\n               break;\n```\n\nThe remaining changed files are: test files (commands.test.ts, start.test.ts, mock-handle.ts, tui.test.ts, client.test.ts) and documentation files (SKILL.md, README.md, manual.md, help.ts).\n\nYour task: Identify any security vulnerabilities introduced by this PR. Focus on:\n\n1. **Input Validation**: Is user input from the emote message sanitized before being sent over the wire or displayed? Could it cause injection issues?\n2. **Command Injection**: Could crafted emote messages inject into system calls or IPC?\n3. **Protocol Security**: Does the emote message get properly encoded in the WoW protocol packet? Could it cause buffer overflow or protocol confusion?\n4. **Authentication/Authorization**: Does this bypass any access controls?\n5. **Data Exposure**: Could emote messages leak sensitive data?\n\nTo understand the security context, examine:\n- How `buildChatMessage` constructs the packet (src/wow/protocol/chat.ts)\n- How the IPC socket handles data (look at the unix socket communication pattern)\n- How messages are displayed/logged\n- How other chat types (say, yell) handle the same data flow\n\nProvide a list of any vulnerabilities found with file, line number, severity, category, description, exploit scenario, and fix recommendation. If no vulnerabilities are found, state that clearly.\n","agentId":"ac3b81c4b1a1b6fbb","content":[{"type":"text","text":"## Security Review: Text Emote Support (`feat/text-emote` branch)\n\n### Summary\n\n**No security vulnerabilities were found in this PR.** The text emote feature introduces no new attack surface beyond what already exists for the other chat types (say, yell, guild, party, raid). Below is the detailed analysis for each security dimension.\n\n---\n\n### 1. Input Validation\n\n**Finding: No vulnerability.**\n\nThe emote message follows the exact same data flow as every other chat type. In the TUI path (`/home/openclaw/code/tuicraft/src/ui/tui.ts`, line 136-137), `/e` and `/emote` parse the rest of the input line into `{ type: \"emote\", message: rest }` -- the same pattern used by `/s`, `/y`, `/g`, `/p`, and `/raid`. In the IPC/daemon path (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, lines 109-117), the `EMOTE` verb extracts the message the same way `SAY`, `YELL`, `GUILD`, and `PARTY` do. No additional sanitization is needed at this layer because:\n\n- The message is passed directly to `buildChatMessage`, which encodes it as a null-terminated C string via `PacketWriter.cString()` (`/home/openclaw/code/tuicraft/src/wow/protocol/packet.ts`, lines 159-163). This uses `TextEncoder.encode()` which produces valid UTF-8, then appends a null byte. There is no possibility of injection into the binary protocol.\n- On the display side, incoming emote messages go through `formatMessage` (`/home/openclaw/code/tuicraft/src/ui/tui.ts`, line 165) which applies `stripColorCodes` (`/home/openclaw/code/tuicraft/src/lib/strip-colors.ts`) to strip WoW color/hyperlink markup. The emote type (`ChatType.EMOTE = 0x0a`) is already mapped in `CHAT_TYPE_LABELS` (line 158) and `JSON_TYPE_LABELS` (line 194), so it renders through the same safe path as all other message types.\n\n### 2. Command Injection\n\n**Finding: No vulnerability.**\n\nThe IPC transport uses a Unix domain socket (`/home/openclaw/code/tuicraft/src/daemon/server.ts`, line 123-126, `Bun.listen({ unix: sock })`). Commands are line-delimited text parsed by `parseIpcCommand` (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, line 64). The emote command is dispatched to `handle.sendEmote(cmd.message)` (line 255-258) which calls directly into the WoW protocol layer -- no shell execution, no `eval`, no process spawning. The message string flows from the Unix socket straight into a binary protocol packet. This is identical to how `handle.sendSay`, `handle.sendYell`, etc. work.\n\n### 3. Protocol Security\n\n**Finding: No vulnerability.**\n\nThe `sendEmote` implementation (`/home/openclaw/code/tuicraft/src/wow/client.ts`, lines 1149-1156) is structurally identical to `sendSay`, `sendYell`, `sendGuild`, `sendParty`, and `sendRaid`:\n\n```typescript\nsendEmote(message) {\n  conn.lastChatMode = { type: \"emote\" };\n  sendPacket(\n    conn,\n    GameOpcode.CMSG_MESSAGE_CHAT,\n    buildChatMessage(ChatType.EMOTE, lang, message),\n  );\n},\n```\n\nIt uses the same opcode (`CMSG_MESSAGE_CHAT`), the same `buildChatMessage` function (`/home/openclaw/code/tuicraft/src/wow/protocol/chat.ts`, lines 70-84), and the same `sendPacket` -> `buildOutgoingPacket` pipeline (`/home/openclaw/code/tuicraft/src/wow/protocol/world.ts`, lines 212-229). The packet is properly length-prefixed (2-byte big-endian size field) and optionally Arc4-encrypted. `ChatType.EMOTE` (0x0a) is not `WHISPER` or `CHANNEL`, so it takes the no-target branch in `buildChatMessage` (line 79), producing the correct wire format: `[type:u32LE][lang:u32LE][message:cstring]`.\n\nThere is no buffer overflow risk. `PacketWriter` uses a dynamically growing buffer (`grow()` method, line 104-111) and `cString` writes exactly the encoded bytes plus one null terminator. The server enforces its own message length limits.\n\n### 4. Authentication/Authorization\n\n**Finding: No vulnerability.**\n\nThe emote command does not bypass any access controls. It requires an active `WorldHandle`, which is only created after successful SRP authentication (`authHandshake`/`authWithRetry`) and character login (`selectCharacter`). The IPC socket at `$XDG_RUNTIME_DIR/tuicraft/sock` is protected by the filesystem permissions of the runtime directory (typically mode 0700 under XDG_RUNTIME_DIR). No new authentication surface is introduced.\n\n### 5. Data Exposure\n\n**Finding: No vulnerability.**\n\nEmote messages are logged via `onChatMessage` -> `log.append()` (`/home/openclaw/code/tuicraft/src/daemon/commands.ts`, lines 493-501) through the same `SessionLog` path as all other chat types. The session log at `$XDG_STATE_HOME/tuicraft/session.log` stores the message with `stripColorCodes` applied. No credentials, session keys, or internal state are exposed. The emote message content is user-supplied text that would be visible to other players in-game anyway.\n\n---\n\n### Pre-existing Observations (Not Introduced by This PR)\n\nWhile reviewing the surrounding code, I noted these characteristics that are **not introduced or changed by this PR**, and are consistent with the project's existing security posture:\n\n1. **No message length validation on the client side**: None of the chat types (say, yell, guild, party, raid, emote, whisper, channel) validate message length before sending. The WoW 3.3.5a server enforces a 255-byte limit on chat messages and will silently truncate or reject oversized messages, so this is a server-side concern rather than a client vulnerability.\n\n2. **Null bytes in messages**: If a user somehow sends a message containing a null byte (`\\0`), the `cString` encoding would cause the server to see a truncated message. This is benign -- the server would process a shorter message. This affects all chat types equally and is not a security issue.\n\n3. **IPC socket uses default Bun.listen permissions**: The Unix socket at `runtimeDir()/sock` relies on the parent directory's permissions for access control. Under `XDG_RUNTIME_DIR` (typically `/run/user/<uid>`), this is restricted to the owning user. The fallback path (`/tmp/tuicraft-<uid>`) creates a user-specific directory via `mkdir({ recursive: true })`. This is a pre-existing design choice, not affected by this PR.\n\n### Conclusion\n\n**No security vulnerabilities are introduced by this PR.** The text emote feature is a minimal, mechanical extension that adds one more variant to an existing discriminated union type and wires it through the exact same validated, binary-encoded, encrypted protocol pipeline used by all other chat types. The implementation is structurally identical to `sendSay`/`sendYell`/`sendGuild`/`sendParty`/`sendRaid` across all three layers (TUI parsing, IPC daemon, WoW protocol)."}],"totalDurationMs":117639,"totalTokens":64066,"totalToolUseCount":25,"usage":{"input_tokens":1,"cache_creation_input_tokens":287,"cache_read_input_tokens":61925,"output_tokens":1853,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":287,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"d3dd64d7-1d5d-4a07-b7f5-323ef07f848a"}
{"parentUuid":"2983c2bb-6112-4dd3-b02a-b8b217803804","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01NPv2DLtPNoUdGjufxeLjfz","type":"message","role":"assistant","content":[{"type":"text","text":"No security vulnerabilities were identified by the analysis. The changes are purely mechanical — adding one more variant to an existing discriminated union and wiring it through the same validated, binary-encoded, encrypted protocol pipeline used by all other chat types. No false-positive filtering sub-tasks are needed since there are zero findings.\n\n---\n\n# Security Review: `feat/text-emote`\n\n## Result: No vulnerabilities found\n\nThe text emote feature introduces **no new attack surface**. Every code path added by this PR is structurally identical to the existing say/yell/guild/party/raid chat types:\n\n- **Input handling**: User input flows through the same `parseCommand` / `parseIpcCommand` parsers, with no new parsing logic\n- **Protocol encoding**: Messages are encoded via the same `buildChatMessage` -> `PacketWriter.cString()` pipeline (length-prefixed, null-terminated, Arc4-encrypted)\n- **IPC transport**: Commands arrive over the existing Unix domain socket (filesystem-permission-protected), dispatched through the same `dispatchCommand` switch\n- **Display/logging**: Incoming emotes render through the existing `formatMessage` path with `stripColorCodes` sanitization, logged via the same `SessionLog.append`\n- **Auth boundary**: `sendEmote` requires an active `WorldHandle`, which is only available after SRP authentication and character login\n\nNo injection vectors, authentication bypasses, data exposure, or protocol confusion risks were identified."}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4008,"cache_read_input_tokens":127714,"output_tokens":329,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":4008,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNDBjA9zPLwNT9oA2nT","type":"assistant","uuid":"72b7cc06-cfd2-4109-9696-ee7557a8d76a","timestamp":"2026-02-28T23:52:42.591Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-28T23:52:52.767Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","content":"/review"}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-28T23:52:52.767Z","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd"}
{"parentUuid":"72b7cc06-cfd2-4109-9696-ee7557a8d76a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.sh"},"parentToolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","toolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","timestamp":"2026-02-28T23:52:52.750Z","uuid":"2766a114-f63e-43ac-be1c-3f6942923b26"}
{"parentUuid":"2766a114-f63e-43ac-be1c-3f6942923b26","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"entire hooks claude-code session-start"},"parentToolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","toolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","timestamp":"2026-02-28T23:52:52.750Z","uuid":"96a39a43-729c-48d8-b5eb-9d56f4255f17"}
{"parentUuid":"96a39a43-729c-48d8-b5eb-9d56f4255f17","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:resume","command":"'${CLAUDE_PLUGIN_ROOT}/hooks/run-hook.cmd' session-start"},"parentToolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","toolUseID":"12a0025c-3137-4b28-80f7-6e40d81a3552","timestamp":"2026-02-28T23:52:52.750Z","uuid":"0e1c4d1b-9272-42b7-a584-f1bc8919495a"}
{"parentUuid":"0e1c4d1b-9272-42b7-a584-f1bc8919495a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":"<command-message>review</command-message>\n<command-name>/review</command-name>"},"uuid":"3cb12548-eb9c-4f9e-90f3-0c744e56ec5a","timestamp":"2026-02-28T23:52:53.271Z"}
{"parentUuid":"3cb12548-eb9c-4f9e-90f3-0c744e56ec5a","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"text","text":"\n      You are an expert code reviewer. Follow these steps:\n\n      1. If no PR number is provided in the args, run `gh pr list` to show open PRs\n      2. If a PR number is provided, run `gh pr view <number>` to get PR details\n      3. Run `gh pr diff <number>` to get the diff\n      4. Analyze the changes and provide a thorough code review that includes:\n         - Overview of what the PR does\n         - Analysis of code quality and style\n         - Specific suggestions for improvements\n         - Any potential issues or risks\n\n      Keep your review concise but thorough. Focus on:\n      - Code correctness\n      - Following project conventions\n      - Performance implications\n      - Test coverage\n      - Security considerations\n\n      Format your review with clear sections and bullet points.\n\n      PR number: \n    "}]},"isMeta":true,"uuid":"d3b9196c-a16a-4b83-9ae4-5a6df6d7802c","timestamp":"2026-02-28T23:52:53.271Z"}
{"parentUuid":"d3b9196c-a16a-4b83-9ae4-5a6df6d7802c","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01XsNZfQNCRDV8hTqrbM5zNQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XZs8xLLPaXSGEyZ4KngdPc","name":"Skill","input":{"skill":"superpowers:requesting-code-review"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":18762,"cache_read_input_tokens":113505,"output_tokens":61,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":18762,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNEjFkpXyh9bYPhoBC7","type":"assistant","uuid":"367e9258-20b7-48ad-91d2-6be1eb888023","timestamp":"2026-02-28T23:52:57.634Z"}
{"parentUuid":"367e9258-20b7-48ad-91d2-6be1eb888023","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01XZs8xLLPaXSGEyZ4KngdPc","content":"Launching skill: superpowers:requesting-code-review"}]},"uuid":"ea6effcf-a888-4d79-8a1a-a98600d07631","timestamp":"2026-02-28T23:52:57.645Z","toolUseResult":{"success":true,"commandName":"superpowers:requesting-code-review"},"sourceToolAssistantUUID":"367e9258-20b7-48ad-91d2-6be1eb888023"}
{"parentUuid":"ea6effcf-a888-4d79-8a1a-a98600d07631","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"type":"text","text":"Base directory for this skill: /home/openclaw/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/requesting-code-review\n\n# Requesting Code Review\n\nDispatch superpowers:code-reviewer subagent to catch issues before they cascade.\n\n**Core principle:** Review early, review often.\n\n## When to Request Review\n\n**Mandatory:**\n- After each task in subagent-driven development\n- After completing major feature\n- Before merge to main\n\n**Optional but valuable:**\n- When stuck (fresh perspective)\n- Before refactoring (baseline check)\n- After fixing complex bug\n\n## How to Request\n\n**1. Get git SHAs:**\n```bash\nBASE_SHA=$(git rev-parse HEAD~1)  # or origin/main\nHEAD_SHA=$(git rev-parse HEAD)\n```\n\n**2. Dispatch code-reviewer subagent:**\n\nUse Task tool with superpowers:code-reviewer type, fill template at `code-reviewer.md`\n\n**Placeholders:**\n- `{WHAT_WAS_IMPLEMENTED}` - What you just built\n- `{PLAN_OR_REQUIREMENTS}` - What it should do\n- `{BASE_SHA}` - Starting commit\n- `{HEAD_SHA}` - Ending commit\n- `{DESCRIPTION}` - Brief summary\n\n**3. Act on feedback:**\n- Fix Critical issues immediately\n- Fix Important issues before proceeding\n- Note Minor issues for later\n- Push back if reviewer is wrong (with reasoning)\n\n## Example\n\n```\n[Just completed Task 2: Add verification function]\n\nYou: Let me request code review before proceeding.\n\nBASE_SHA=$(git log --oneline | grep \"Task 1\" | head -1 | awk '{print }')\nHEAD_SHA=$(git rev-parse HEAD)\n\n[Dispatch superpowers:code-reviewer subagent]\n  WHAT_WAS_IMPLEMENTED: Verification and repair functions for conversation index\n  PLAN_OR_REQUIREMENTS: Task 2 from docs/plans/deployment-plan.md\n  BASE_SHA: a7981ec\n  HEAD_SHA: 3df7661\n  DESCRIPTION: Added verifyIndex() and repairIndex() with 4 issue types\n\n[Subagent returns]:\n  Strengths: Clean architecture, real tests\n  Issues:\n    Important: Missing progress indicators\n    Minor: Magic number (100) for reporting interval\n  Assessment: Ready to proceed\n\nYou: [Fix progress indicators]\n[Continue to Task 3]\n```\n\n## Integration with Workflows\n\n**Subagent-Driven Development:**\n- Review after EACH task\n- Catch issues before they compound\n- Fix before moving to next task\n\n**Executing Plans:**\n- Review after each batch (3 tasks)\n- Get feedback, apply, continue\n\n**Ad-Hoc Development:**\n- Review before merge\n- Review when stuck\n\n## Red Flags\n\n**Never:**\n- Skip review because \"it's simple\"\n- Ignore Critical issues\n- Proceed with unfixed Important issues\n- Argue with valid technical feedback\n\n**If reviewer wrong:**\n- Push back with technical reasoning\n- Show code/tests that prove it works\n- Request clarification\n\nSee template at: requesting-code-review/code-reviewer.md\n"}]},"isMeta":true,"uuid":"0ad64327-e756-4184-a9d1-3ad16e82cc98","timestamp":"2026-02-28T23:52:57.644Z","sourceToolUseID":"toolu_01XZs8xLLPaXSGEyZ4KngdPc"}
{"parentUuid":"0ad64327-e756-4184-a9d1-3ad16e82cc98","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01FxhiEv6FoS6peGTohLhpsT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JEUz5hE9EhkwMgPB4R6fL7","name":"Bash","input":{"command":"gh pr list","description":"List open PRs"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":848,"cache_read_input_tokens":132267,"output_tokens":75,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":848,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNF3yt1RDBCTnKgciNU","type":"assistant","uuid":"c3f297b2-5c5d-40a8-92fd-727548ca14b5","timestamp":"2026-02-28T23:53:01.159Z"}
{"parentUuid":"c3f297b2-5c5d-40a8-92fd-727548ca14b5","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JEUz5hE9EhkwMgPB4R6fL7","type":"tool_result","content":"61\tfeat: Add text emote support\tfeat/text-emote\tOPEN\t2026-02-28T23:49:26Z\n59\tchore(main): release tuicraft 0.4.1\trelease-please--branches--main--components--tuicraft\tOPEN\t2026-02-28T13:22:31Z","is_error":false}]},"uuid":"27696851-db24-4e9b-80eb-839d5e63e4e7","timestamp":"2026-02-28T23:53:02.123Z","toolUseResult":{"stdout":"61\tfeat: Add text emote support\tfeat/text-emote\tOPEN\t2026-02-28T23:49:26Z\n59\tchore(main): release tuicraft 0.4.1\trelease-please--branches--main--components--tuicraft\tOPEN\t2026-02-28T13:22:31Z","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"c3f297b2-5c5d-40a8-92fd-727548ca14b5"}
{"parentUuid":"27696851-db24-4e9b-80eb-839d5e63e4e7","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01D9A1ZaMVpYnLxkooRvvQHB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KgQ1Ly1eh9Fececs4xPphx","name":"Bash","input":{"command":"git rev-parse main && git rev-parse HEAD","description":"Get base and head SHAs"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":170,"cache_read_input_tokens":133115,"output_tokens":85,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":170,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNFP46bVEoVwDEFZqVw","type":"assistant","uuid":"f69bf45c-09af-45c1-b50c-20fffa1d07bf","timestamp":"2026-02-28T23:53:05.281Z"}
{"parentUuid":"f69bf45c-09af-45c1-b50c-20fffa1d07bf","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KgQ1Ly1eh9Fececs4xPphx","type":"tool_result","content":"c8b54093bf60081d63af829bca14faaa1ecf8c14\n751b13b2e6fbec729fa48a92886c5ec0a0bef4a0","is_error":false}]},"uuid":"bee72fe2-5c14-42f4-af35-7faa6f9fae8d","timestamp":"2026-02-28T23:53:05.298Z","toolUseResult":{"stdout":"c8b54093bf60081d63af829bca14faaa1ecf8c14\n751b13b2e6fbec729fa48a92886c5ec0a0bef4a0","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"f69bf45c-09af-45c1-b50c-20fffa1d07bf"}
{"parentUuid":"bee72fe2-5c14-42f4-af35-7faa6f9fae8d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01TY4rJViJfwkbCB8VprSKUn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Agy4EXos6dLni9ZKkdBjxd","name":"Agent","input":{"description":"Code review of PR #61","subagent_type":"superpowers:code-reviewer","prompt":"\n## Code Review Request\n\n**What was implemented:** Text emote support — `/e` and `/emote` slash commands that send CHAT_MSG_EMOTE type messages, plus handling incoming emotes from other players. Follows the exact same pattern as say/yell.\n\n**Plan/Requirements:** Add text emote support: /e and /emote slash commands. This sends a chat message with CHAT_MSG_EMOTE type. Also handle receiving emotes from other players. Look at how say/yell work and follow the same pattern. Full test coverage required. Update all four doc surfaces (help.ts, manual.md, SKILL.md, README.md).\n\n**Base SHA:** c8b54093bf60081d63af829bca14faaa1ecf8c14 (main)\n**Head SHA:** 751b13b2e6fbec729fa48a92886c5ec0a0bef4a0\n\n**Description:** Single commit adding text emote support across 12 files. Wires /e and /emote through the existing chat pipeline (parseCommand → IPC → WorldHandle → CMSG_MESSAGE_CHAT with ChatType.EMOTE). All infrastructure was already in place (ChatType.EMOTE constant, format labels, parseChatMessage handler). The change is purely mechanical wiring.\n\nReview against the project conventions in CLAUDE.md, check test coverage, verify the pattern matches say/yell exactly, and flag any issues.\n"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":147,"cache_read_input_tokens":133285,"output_tokens":432,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":147,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNFcaSrkdG5ukJniVsE","type":"assistant","uuid":"2c610964-6147-49ed-bf6b-4232c9686948","timestamp":"2026-02-28T23:53:17.615Z"}
{"parentUuid":"2c610964-6147-49ed-bf6b-4232c9686948","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Agy4EXos6dLni9ZKkdBjxd","type":"tool_result","content":[{"type":"text","text":"Now I have all the information I need. Here is my review.\n\n---\n\n## Code Review: Text Emote Support (feat/text-emote)\n\n### What Was Done Well\n\nThe implementation is clean, methodical, and follows the existing patterns precisely. Specifically:\n\n- The commit is properly scoped -- a single logical change across all necessary layers.\n- The commit message follows Conventional Commits, is concise, and includes a \"why\" body.\n- All four documentation surfaces are updated as required (help.ts, manual.md, SKILL.md, README.md).\n- The full pipeline is wired end-to-end: `parseCommand` (TUI) -> `parseIpcCommand` (daemon) -> `dispatchCommand` -> `WorldHandle.sendEmote` -> `buildChatMessage(ChatType.EMOTE, lang, message)`.\n- The pattern exactly mirrors say/yell/guild/party/raid -- `sendEmote` sets `lastChatMode`, calls `sendPacket` with `CMSG_MESSAGE_CHAT`, and the `sendInCurrentMode` switch handles the `\"emote\"` case.\n- Both mock handles are updated (`/home/openclaw/code/tuicraft/src/test/mock-handle.ts` and the inline mock in `/home/openclaw/code/tuicraft/src/daemon/start.test.ts`).\n- Test coverage is thorough: unit tests for parsing (`EMOTE`, `/e`, `/emote`), dispatch tests, IPC round-trip tests, mock world server send+echo tests, and `sendInCurrentMode` dispatch tests.\n- The `\"EMOTE waves\"` case was correctly removed from the `unimplemented` test array in `commands.test.ts`.\n- All 825 tests pass. TypeScript type checking passes. Formatting passes. Coverage is 100% lines and functions on every changed file.\n\n### Issues\n\n**Important: `/2` channel dropped from help text**\n\nIn `/home/openclaw/code/tuicraft/src/cli/help.ts` at line 39, the old text was:\n\n```\n  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n```\n\nThe new text is:\n\n```\n  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n```\n\nThe `/2` channel shortcut was dropped to make room for `/e`. This is a documentation regression -- `/2` still works as a command, but it is no longer mentioned in the help text. The fix is to include both `/e` and `/2`. The line is already at the edge of readability with that many items, but the previous version included `/2`, so it should stay. Suggested fix:\n\n```\n  /s, /y, /w, /g, /p, /raid, /e, /1, /2  Chat commands\n```\n\nAlternatively, if the intent was to keep the line short, consider that `/2` was already present before and should not be removed without justification.\n\n### Suggestions (Nice to Have)\n\n**Suggestion: `/emote` not listed in manual.md or help.ts**\n\nThe manual.md table at line 124 only shows `/e`, not `/emote`:\n\n```\n| `/e` _msg_                   | Text emote                  |\n```\n\nFor comparison, the other doc surfaces vary in how they present aliases. This is consistent with `/s` not listing `/say`, so this is fine as-is. Just noting it for completeness -- no action needed.\n\n**Suggestion: Emote language handling is correct but worth understanding**\n\nThe implementation passes `lang` (the racial language like Orcish) to `buildChatMessage` for emotes. Looking at the AzerothCore server source (`ChatHandler.cpp` line 373-374), the server calls `sender->TextEmote(msg)` which does not use the client-provided language parameter -- it handles emote visibility its own way. So the language field in the packet is effectively ignored for emotes. This is correct behavior -- the client should still include a language value in the packet structure, and the server handles the rest. No change needed.\n\n### Summary\n\nThis is a well-executed, mechanical change. The code follows the established patterns exactly, test coverage is comprehensive, and all CI checks pass. There is one issue to address:\n\n| Category | Issue | Location |\n|----------|-------|----------|\n| Important | `/2` channel command dropped from help text | `/home/openclaw/code/tuicraft/src/cli/help.ts` line 39 |\n\nEverything else looks good. Fix the help text and this is ready to merge."},{"type":"text","text":"agentId: a95837a4bc7a85aba (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 42823\ntool_uses: 26\nduration_ms: 85566</usage>"}]}]},"uuid":"52cdfb2f-40cb-4aaf-be85-ed23738b6e7d","timestamp":"2026-02-28T23:54:43.199Z","toolUseResult":{"status":"completed","prompt":"\n## Code Review Request\n\n**What was implemented:** Text emote support — `/e` and `/emote` slash commands that send CHAT_MSG_EMOTE type messages, plus handling incoming emotes from other players. Follows the exact same pattern as say/yell.\n\n**Plan/Requirements:** Add text emote support: /e and /emote slash commands. This sends a chat message with CHAT_MSG_EMOTE type. Also handle receiving emotes from other players. Look at how say/yell work and follow the same pattern. Full test coverage required. Update all four doc surfaces (help.ts, manual.md, SKILL.md, README.md).\n\n**Base SHA:** c8b54093bf60081d63af829bca14faaa1ecf8c14 (main)\n**Head SHA:** 751b13b2e6fbec729fa48a92886c5ec0a0bef4a0\n\n**Description:** Single commit adding text emote support across 12 files. Wires /e and /emote through the existing chat pipeline (parseCommand → IPC → WorldHandle → CMSG_MESSAGE_CHAT with ChatType.EMOTE). All infrastructure was already in place (ChatType.EMOTE constant, format labels, parseChatMessage handler). The change is purely mechanical wiring.\n\nReview against the project conventions in CLAUDE.md, check test coverage, verify the pattern matches say/yell exactly, and flag any issues.\n","agentId":"a95837a4bc7a85aba","content":[{"type":"text","text":"Now I have all the information I need. Here is my review.\n\n---\n\n## Code Review: Text Emote Support (feat/text-emote)\n\n### What Was Done Well\n\nThe implementation is clean, methodical, and follows the existing patterns precisely. Specifically:\n\n- The commit is properly scoped -- a single logical change across all necessary layers.\n- The commit message follows Conventional Commits, is concise, and includes a \"why\" body.\n- All four documentation surfaces are updated as required (help.ts, manual.md, SKILL.md, README.md).\n- The full pipeline is wired end-to-end: `parseCommand` (TUI) -> `parseIpcCommand` (daemon) -> `dispatchCommand` -> `WorldHandle.sendEmote` -> `buildChatMessage(ChatType.EMOTE, lang, message)`.\n- The pattern exactly mirrors say/yell/guild/party/raid -- `sendEmote` sets `lastChatMode`, calls `sendPacket` with `CMSG_MESSAGE_CHAT`, and the `sendInCurrentMode` switch handles the `\"emote\"` case.\n- Both mock handles are updated (`/home/openclaw/code/tuicraft/src/test/mock-handle.ts` and the inline mock in `/home/openclaw/code/tuicraft/src/daemon/start.test.ts`).\n- Test coverage is thorough: unit tests for parsing (`EMOTE`, `/e`, `/emote`), dispatch tests, IPC round-trip tests, mock world server send+echo tests, and `sendInCurrentMode` dispatch tests.\n- The `\"EMOTE waves\"` case was correctly removed from the `unimplemented` test array in `commands.test.ts`.\n- All 825 tests pass. TypeScript type checking passes. Formatting passes. Coverage is 100% lines and functions on every changed file.\n\n### Issues\n\n**Important: `/2` channel dropped from help text**\n\nIn `/home/openclaw/code/tuicraft/src/cli/help.ts` at line 39, the old text was:\n\n```\n  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n```\n\nThe new text is:\n\n```\n  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n```\n\nThe `/2` channel shortcut was dropped to make room for `/e`. This is a documentation regression -- `/2` still works as a command, but it is no longer mentioned in the help text. The fix is to include both `/e` and `/2`. The line is already at the edge of readability with that many items, but the previous version included `/2`, so it should stay. Suggested fix:\n\n```\n  /s, /y, /w, /g, /p, /raid, /e, /1, /2  Chat commands\n```\n\nAlternatively, if the intent was to keep the line short, consider that `/2` was already present before and should not be removed without justification.\n\n### Suggestions (Nice to Have)\n\n**Suggestion: `/emote` not listed in manual.md or help.ts**\n\nThe manual.md table at line 124 only shows `/e`, not `/emote`:\n\n```\n| `/e` _msg_                   | Text emote                  |\n```\n\nFor comparison, the other doc surfaces vary in how they present aliases. This is consistent with `/s` not listing `/say`, so this is fine as-is. Just noting it for completeness -- no action needed.\n\n**Suggestion: Emote language handling is correct but worth understanding**\n\nThe implementation passes `lang` (the racial language like Orcish) to `buildChatMessage` for emotes. Looking at the AzerothCore server source (`ChatHandler.cpp` line 373-374), the server calls `sender->TextEmote(msg)` which does not use the client-provided language parameter -- it handles emote visibility its own way. So the language field in the packet is effectively ignored for emotes. This is correct behavior -- the client should still include a language value in the packet structure, and the server handles the rest. No change needed.\n\n### Summary\n\nThis is a well-executed, mechanical change. The code follows the established patterns exactly, test coverage is comprehensive, and all CI checks pass. There is one issue to address:\n\n| Category | Issue | Location |\n|----------|-------|----------|\n| Important | `/2` channel command dropped from help text | `/home/openclaw/code/tuicraft/src/cli/help.ts` line 39 |\n\nEverything else looks good. Fix the help text and this is ready to merge."}],"totalDurationMs":85566,"totalTokens":42823,"totalToolUseCount":26,"usage":{"input_tokens":1,"cache_creation_input_tokens":333,"cache_read_input_tokens":41408,"output_tokens":1081,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":333,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"2c610964-6147-49ed-bf6b-4232c9686948"}
{"parentUuid":"52cdfb2f-40cb-4aaf-be85-ed23738b6e7d","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01G7p3P9GmMPVRz7VwY4XEHZ","type":"message","role":"assistant","content":[{"type":"text","text":"## Code Review: PR #61 — Text Emote Support\n\n### Strengths\n\n- Clean, mechanical change that exactly mirrors the say/yell/guild/party/raid pattern\n- All four doc surfaces updated (help.ts, manual.md, SKILL.md, README.md)\n- Full test coverage: parsing, IPC, dispatch, echo, sendInCurrentMode, integration\n- Both mock handles updated\n- Commit message follows conventions\n- All 825 tests pass, typecheck clean, formatting clean\n\n### Issue Found\n\n**Important: `/2` dropped from help text**\n\nIn `src/cli/help.ts:39`, the old line was:\n```\n  /s, /y, /w, /g, /p, /raid, /1, /2  Chat commands\n```\nThe new line replaced `/2` with `/e`:\n```\n  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n```\n\n`/2` still works but is no longer documented. Let me fix that."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1578,"cache_read_input_tokens":133432,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1578},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbNNqVmhk99fsrh7CdWp","type":"assistant","uuid":"c549a1a2-e093-4d4c-bfb3-e0fd66ecb2ad","timestamp":"2026-02-28T23:54:50.888Z"}
{"parentUuid":"c549a1a2-e093-4d4c-bfb3-e0fd66ecb2ad","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01G7p3P9GmMPVRz7VwY4XEHZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018Pxz4bn5Qv9vq47JagZ9fG","name":"Read","input":{"file_path":"/home/openclaw/code/tuicraft/src/cli/help.ts","offset":38,"limit":3},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1578,"cache_read_input_tokens":133432,"output_tokens":348,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1578,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNNqVmhk99fsrh7CdWp","type":"assistant","uuid":"5e52b135-8071-44fa-9b49-91ce0fef6125","timestamp":"2026-02-28T23:54:51.511Z"}
{"parentUuid":"5e52b135-8071-44fa-9b49-91ce0fef6125","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018Pxz4bn5Qv9vq47JagZ9fG","type":"tool_result","content":"    38→INTERACTIVE COMMANDS (TUI mode)\n    39→  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n    40→  /r              Reply to last whisper"}]},"uuid":"ee682a48-9341-4d5e-a1fa-ca2a19558d59","timestamp":"2026-02-28T23:54:51.514Z","toolUseResult":{"type":"text","file":{"filePath":"/home/openclaw/code/tuicraft/src/cli/help.ts","content":"INTERACTIVE COMMANDS (TUI mode)\n  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n  /r              Reply to last whisper","numLines":3,"startLine":38,"totalLines":65}},"sourceToolAssistantUUID":"5e52b135-8071-44fa-9b49-91ce0fef6125"}
{"parentUuid":"ee682a48-9341-4d5e-a1fa-ca2a19558d59","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_011b6V6GppuPUqH2axjL1kYK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C3jayNAesSeYnQrBSt18UW","name":"Edit","input":{"replace_all":false,"file_path":"/home/openclaw/code/tuicraft/src/cli/help.ts","old_string":"  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands","new_string":"  /s, /y, /w, /g, /p, /raid, /e, /1, /2  Chat commands"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":416,"cache_read_input_tokens":135010,"output_tokens":164,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":416,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNPTTz1b1nmNYPHZKbq","type":"assistant","uuid":"405ffe54-7337-4945-ba90-f87bf0827838","timestamp":"2026-02-28T23:54:55.199Z"}
{"parentUuid":"405ffe54-7337-4945-ba90-f87bf0827838","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C3jayNAesSeYnQrBSt18UW","type":"tool_result","content":"The file /home/openclaw/code/tuicraft/src/cli/help.ts has been updated successfully."}]},"uuid":"b40e307b-bf65-4c84-a744-aa065aa28fb4","timestamp":"2026-02-28T23:54:55.218Z","toolUseResult":{"filePath":"/home/openclaw/code/tuicraft/src/cli/help.ts","oldString":"  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands","newString":"  /s, /y, /w, /g, /p, /raid, /e, /1, /2  Chat commands","originalFile":"export function helpText(): string {\n  return `tuicraft — WoW 3.3.5a chat client\n\nUSAGE\n  tuicraft                    Interactive TUI mode\n  tuicraft setup [flags]      Configure account credentials\n  tuicraft send \"message\"     Send a say message (auto-starts daemon)\n  tuicraft send -w <name> \"m\" Whisper a player\n  tuicraft send -y \"message\"  Yell\n  tuicraft send -g \"message\"  Guild chat\n  tuicraft send -p \"message\"  Party chat\n  tuicraft who [filter]       Who query\n  tuicraft read [--wait N]    Read buffered events\n  tuicraft tail               Continuous event stream\n  tuicraft status             Show daemon status\n  tuicraft stop               Stop the daemon\n  tuicraft logs               Print session log\n  tuicraft skill              Print SKILL.md for AI agents\n  tuicraft version            Print version and exit\n  tuicraft help               Show this help\n\nFLAGS\n  -v, --version   Print version and exit\n  -h, --help      Show this help\n  --json          Output events as JSONL (for read, tail, chat, who)\n  --wait N        Wait N seconds for events (for read and send commands)\n  --daemon        Start as background daemon (internal)\n\nSETUP FLAGS\n  --account NAME  Account name (required)\n  --password PASS Password (required)\n  --character NAME Character name (required)\n  --host HOST     Auth server hostname (default: t1)\n  --port PORT     Auth server port (default: 3724)\n  --language ID   Chat language code (default: 1/Orcish)\n  --timeout_minutes N  Daemon idle timeout (default: 30)\n\nINTERACTIVE COMMANDS (TUI mode)\n  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands\n  /r              Reply to last whisper\n  /who [filter]   Who search\n  /invite <name>  Invite player to group\n  /kick <name>    Remove player from group\n  /leave          Leave the current group\n  /leader <name>  Transfer group leadership\n  /accept         Accept a group invitation\n  /decline        Decline a group invitation\n  /friends        Show your friends list\n  /friend add <n> Add a player to friends\n  /friend remove  Remove a player from friends\n  /tuicraft entities on|off  Toggle entity event display\n  /quit           Disconnect and exit\n\nDAEMON\n  The daemon starts automatically when needed and stays running\n  for 30 minutes of inactivity. It maintains the WoW connection\n  and buffers events for CLI clients.\n\nFILES\n  ~/.config/tuicraft/config.toml  Account config\n  $TMPDIR/tuicraft-<uid>/sock     Daemon socket\n  $TMPDIR/tuicraft-<uid>/pid     Daemon pidfile\n  ~/.local/state/tuicraft/session.log  Session log`;\n}\n","structuredPatch":[{"oldStart":36,"oldLines":7,"newStart":36,"newLines":7,"lines":["   --timeout_minutes N  Daemon idle timeout (default: 30)"," "," INTERACTIVE COMMANDS (TUI mode)","-  /s, /y, /w, /g, /p, /raid, /e, /1   Chat commands","+  /s, /y, /w, /g, /p, /raid, /e, /1, /2  Chat commands","   /r              Reply to last whisper","   /who [filter]   Who search","   /invite <name>  Invite player to group"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"405ffe54-7337-4945-ba90-f87bf0827838"}
{"parentUuid":"b40e307b-bf65-4c84-a744-aa065aa28fb4","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_018daoaQ1XC2Pd1vTaEV5du6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N1yq1pBLe6H3q2QpN8ABGW","name":"Bash","input":{"command":"mise ci 2>&1","description":"Run typecheck, test, and format in parallel","timeout":120000},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":444,"cache_read_input_tokens":135426,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":444},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbNPixeFgqL2duDYg64U","type":"assistant","uuid":"7e4edf43-98f6-4506-84c7-d6e77548c0d8","timestamp":"2026-02-28T23:55:03.930Z"}
{"parentUuid":"7e4edf43-98f6-4506-84c7-d6e77548c0d8","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N1yq1pBLe6H3q2QpN8ABGW","type":"tool_result","content":"[ci] $ mise typecheck ::: test ::: format\n[format] $ bunx prettier --check src/\n[typecheck] $ bun run typecheck\n[test] $ bun test\n[typecheck] $ tsc --noEmit\n[test] bun test v1.3.9 (cf6cdbbb)\n[format] Checking formatting...\n[test] \n[test]  825 pass\n[test]  0 fail\n[test]  2149 expect() calls\n[test] Ran 825 tests across 33 files. [590.00ms]\n[format] All matched files use Prettier code style!\nFinished in 1.59s","is_error":false}]},"uuid":"951e1821-27f0-40ef-bedd-07e01f7b8723","timestamp":"2026-02-28T23:55:05.563Z","toolUseResult":{"stdout":"[ci] $ mise typecheck ::: test ::: format\n[format] $ bunx prettier --check src/\n[typecheck] $ bun run typecheck\n[test] $ bun test\n[typecheck] $ tsc --noEmit\n[test] bun test v1.3.9 (cf6cdbbb)\n[format] Checking formatting...\n[test] \n[test]  825 pass\n[test]  0 fail\n[test]  2149 expect() calls\n[test] Ran 825 tests across 33 files. [590.00ms]\n[format] All matched files use Prettier code style!\nFinished in 1.59s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"7e4edf43-98f6-4506-84c7-d6e77548c0d8"}
{"parentUuid":"951e1821-27f0-40ef-bedd-07e01f7b8723","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Qu4tNRsEZ5GDys47JyTKoN","type":"message","role":"assistant","content":[{"type":"text","text":"All passing. Let me amend the commit and force-push the fix."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":273,"cache_read_input_tokens":135870,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":273},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYbNQUm9G3oWDKcXzcfJE","type":"assistant","uuid":"00f7e901-0ded-4100-831c-cd259f94608e","timestamp":"2026-02-28T23:55:08.627Z"}
{"parentUuid":"00f7e901-0ded-4100-831c-cd259f94608e","isSidechain":false,"userType":"external","cwd":"/home/openclaw/code/tuicraft","sessionId":"e2ba95cc-715c-4a58-82d7-afe063fb0bcd","version":"2.1.63","gitBranch":"feat/text-emote","slug":"polished-hatching-quill","message":{"model":"claude-opus-4-6","id":"msg_01Qu4tNRsEZ5GDys47JyTKoN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nr5RNhwqKF26s9hG1Dt4LL","name":"Bash","input":{"command":"git add src/cli/help.ts && git commit -m \"$(cat <<'EOF'\nfix: Restore /2 in help text dropped during emote addition\n\nThe previous commit accidentally replaced /2 with /e instead of\nadding /e alongside it.\nEOF\n)\"","description":"Commit help text fix"},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":273,"cache_read_input_tokens":135870,"output_tokens":151,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":273,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CYbNQUm9G3oWDKcXzcfJE","type":"assistant","uuid":"419bf519-c7fc-4101-99bb-535ce3f16780","timestamp":"2026-02-28T23:55:10.562Z"}
