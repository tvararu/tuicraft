# 0.2 Chat Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add chat messaging (all types), name resolution, /who, and a terminal interface to tuicraft.

**Architecture:** Bottom-up: protocol parsers/builders → session API (WorldHandle extensions) → TUI layer. Each layer tested independently. Live two-client testing first, mock integration tests second.

**Tech Stack:** Bun, TypeScript, node:readline (built-in). Zero new dependencies.

**Reference:** `../wow-chat-client` for packet formats. `docs/plans/2026-02-18-chat-design.md` for full design. `../azerothcore-wotlk-playerbots/` for server implementation.

**Testing approach:** Use `src/test/live.ts` as the primary feedback loop throughout development. Two accounts are configured (`WOW_ACCOUNT_1`/`WOW_ACCOUNT_2` in `mise.local.toml`). After each protocol/session task, add a live test exercising the new behavior and run `mise test:live` to validate against the real server. Iterate on `live.ts` freely — it is a scratch pad for verifying protocol behavior. Only after live behavior is confirmed, encode it in mock integration tests (Task 8). The live tests may need debugging and iteration; the packet formats in this plan are based on the reference codebase but may need adjustment when tested against the actual server.

---

### Task 1: Add Chat Opcodes and Constants

**Files:**

- Modify: `src/protocol/opcodes.ts`

**Step 1: Add new opcodes and chat type constants**

Add to the existing `GameOpcode` object in `src/protocol/opcodes.ts`:

```typescript
CMSG_NAME_QUERY: 0x0050,
SMSG_NAME_QUERY_RESPONSE: 0x0051,
CMSG_WHO: 0x0062,
SMSG_WHO: 0x0063,
CMSG_MESSAGE_CHAT: 0x0095,
SMSG_MESSAGE_CHAT: 0x0096,
SMSG_CHAT_PLAYER_NOT_FOUND: 0x02a9,
SMSG_GM_MESSAGECHAT: 0x03b3,
```

Add a new `ChatType` constant object after `GameOpcode`:

```typescript
export const ChatType = {
  SYSTEM: 0x00,
  SAY: 0x01,
  PARTY: 0x02,
  RAID: 0x03,
  GUILD: 0x04,
  OFFICER: 0x05,
  YELL: 0x06,
  WHISPER: 0x07,
  WHISPER_INFORM: 0x09,
  EMOTE: 0x0a,
  CHANNEL: 0x11,
  RAID_LEADER: 0x27,
  RAID_WARNING: 0x28,
  BATTLEGROUND: 0x2c,
  BATTLEGROUND_LEADER: 0x2d,
  PARTY_LEADER: 0x33,
} as const;
```

**Step 2: Run typecheck**

Run: `mise typecheck`
Expected: PASS — no type errors

**Step 3: Run existing tests**

Run: `mise test`
Expected: All existing tests PASS (no behavior changed)

**Step 4: Commit**

```bash
git add src/protocol/opcodes.ts
git commit -m "Add chat, name query, and who opcodes

Adds CMSG/SMSG_MESSAGE_CHAT, CMSG/SMSG_NAME_QUERY, CMSG/SMSG_WHO,
SMSG_CHAT_PLAYER_NOT_FOUND, SMSG_GM_MESSAGECHAT, and a ChatType
constant object with all message types."
```

---

### Task 2: Add Packed GUID Reader to PacketReader

**Files:**

- Modify: `src/protocol/packet.ts`
- Modify: `src/protocol/packet.test.ts`

The SMSG_NAME_QUERY_RESPONSE uses a "packed GUID" — a variable-length encoding where a bitmask byte indicates which of the 8 GUID bytes are present.

**Step 1: Write the failing test**

Add to `src/protocol/packet.test.ts`:

```typescript
test("PacketReader reads packed GUID with all bytes present", () => {
  const r = new PacketReader(
    new Uint8Array([0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]),
  );
  const { low, high } = r.packedGuid();
  expect(low).toBe(0x04030201);
  expect(high).toBe(0x08070605);
});

test("PacketReader reads packed GUID with only low bytes", () => {
  const r = new PacketReader(new Uint8Array([0x01, 0x42]));
  const { low, high } = r.packedGuid();
  expect(low).toBe(0x42);
  expect(high).toBe(0);
});

test("PacketReader reads packed GUID with no bytes (zero GUID)", () => {
  const r = new PacketReader(new Uint8Array([0x00]));
  const { low, high } = r.packedGuid();
  expect(low).toBe(0);
  expect(high).toBe(0);
});

test("PacketReader reads packed GUID with sparse bytes", () => {
  const r = new PacketReader(new Uint8Array([0x05, 0xaa, 0xbb]));
  const { low, high } = r.packedGuid();
  expect(low).toBe(0xaa | (0xbb << 16));
  expect(high).toBe(0);
});
```

**Step 2: Run test to verify it fails**

Run: `mise test`
Expected: FAIL — `r.packedGuid is not a function`

**Step 3: Write minimal implementation**

Add to `PacketReader` class in `src/protocol/packet.ts`:

```typescript
packedGuid(): { low: number; high: number } {
  const mask = this.uint8();
  let low = 0;
  let high = 0;
  for (let i = 0; i < 8; i++) {
    if (mask & (1 << i)) {
      const byte = this.uint8();
      if (i < 4) low |= byte << (i * 8);
      else high |= byte << ((i - 4) * 8);
    }
  }
  return { low, high };
}
```

**Step 4: Run test to verify it passes**

Run: `mise test`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/protocol/packet.ts src/protocol/packet.test.ts
git commit -m "Add packed GUID reader to PacketReader

Variable-length GUID encoding used by SMSG_NAME_QUERY_RESPONSE. A
bitmask byte indicates which of the 8 GUID bytes are present."
```

---

### Task 3: Chat Protocol Parsers and Builders

**Files:**

- Create: `src/protocol/chat.ts`
- Create: `src/protocol/chat.test.ts`

**Step 1: Write the failing tests**

Create `src/protocol/chat.test.ts`:

```typescript
import { test, expect, describe } from "bun:test";
import { PacketReader, PacketWriter } from "protocol/packet";
import { ChatType } from "protocol/opcodes";
import {
  parseChatMessage,
  buildChatMessage,
  buildNameQuery,
  parseNameQueryResponse,
  buildWhoRequest,
  parseWhoResponse,
} from "protocol/chat";

describe("parseChatMessage", () => {
  test("parses a SAY message", () => {
    const w = new PacketWriter();
    w.uint8(ChatType.SAY);
    w.uint32LE(0);
    w.uint32LE(0x42);
    w.uint32LE(0x00);
    w.uint32LE(0);
    w.uint32LE(0x42);
    w.uint32LE(0x00);
    w.uint32LE(5);
    w.rawBytes(new TextEncoder().encode("hello"));
    w.uint8(0);

    const msg = parseChatMessage(new PacketReader(w.finish()));
    expect(msg.type).toBe(ChatType.SAY);
    expect(msg.senderGuidLow).toBe(0x42);
    expect(msg.message).toBe("hello");
    expect(msg.channel).toBeUndefined();
  });

  test("parses a WHISPER message", () => {
    const w = new PacketWriter();
    w.uint8(ChatType.WHISPER);
    w.uint32LE(0);
    w.uint32LE(0x10);
    w.uint32LE(0x00);
    w.uint32LE(0);
    w.uint32LE(0x10);
    w.uint32LE(0x00);
    w.uint32LE(3);
    w.rawBytes(new TextEncoder().encode("hey"));
    w.uint8(0);

    const msg = parseChatMessage(new PacketReader(w.finish()));
    expect(msg.type).toBe(ChatType.WHISPER);
    expect(msg.message).toBe("hey");
  });

  test("parses a CHANNEL message with channel name", () => {
    const w = new PacketWriter();
    w.uint8(ChatType.CHANNEL);
    w.uint32LE(0);
    w.uint32LE(0x42);
    w.uint32LE(0x00);
    w.uint32LE(0);
    w.cString("General");
    w.uint32LE(0x42);
    w.uint32LE(0x00);
    w.uint32LE(2);
    w.rawBytes(new TextEncoder().encode("hi"));
    w.uint8(0);

    const msg = parseChatMessage(new PacketReader(w.finish()));
    expect(msg.type).toBe(ChatType.CHANNEL);
    expect(msg.channel).toBe("General");
    expect(msg.message).toBe("hi");
  });

  test("parses a SYSTEM message", () => {
    const w = new PacketWriter();
    w.uint8(ChatType.SYSTEM);
    w.uint32LE(0);
    w.uint32LE(0x00);
    w.uint32LE(0x00);
    w.uint32LE(0);
    w.uint32LE(0x00);
    w.uint32LE(0x00);
    w.uint32LE(7);
    w.rawBytes(new TextEncoder().encode("Welcome"));
    w.uint8(0);

    const msg = parseChatMessage(new PacketReader(w.finish()));
    expect(msg.type).toBe(ChatType.SYSTEM);
    expect(msg.message).toBe("Welcome");
  });
});

describe("buildChatMessage", () => {
  test("builds a SAY message", () => {
    const body = buildChatMessage(ChatType.SAY, "hello");
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(ChatType.SAY);
    expect(r.uint32LE()).toBe(0);
    expect(r.cString()).toBe("hello");
  });

  test("builds a WHISPER message with target name", () => {
    const body = buildChatMessage(ChatType.WHISPER, "hey", "Xiara");
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(ChatType.WHISPER);
    expect(r.uint32LE()).toBe(0);
    expect(r.cString()).toBe("Xiara");
    expect(r.cString()).toBe("hey");
  });

  test("builds a CHANNEL message with channel name", () => {
    const body = buildChatMessage(ChatType.CHANNEL, "hi", "General");
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(ChatType.CHANNEL);
    expect(r.uint32LE()).toBe(0);
    expect(r.cString()).toBe("General");
    expect(r.cString()).toBe("hi");
  });

  test("builds a GUILD message (no target)", () => {
    const body = buildChatMessage(ChatType.GUILD, "hello guild");
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(ChatType.GUILD);
    expect(r.uint32LE()).toBe(0);
    expect(r.cString()).toBe("hello guild");
  });
});

describe("buildNameQuery / parseNameQueryResponse", () => {
  test("builds a name query packet", () => {
    const body = buildNameQuery(0x42, 0x00);
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(0x42);
    expect(r.uint32LE()).toBe(0x00);
  });

  test("parses a successful name query response", () => {
    const w = new PacketWriter();
    w.uint8(0x01);
    w.uint8(0x42);
    w.uint8(0);
    w.cString("Xiara");
    w.cString("");
    w.uint32LE(1);
    w.uint32LE(0);
    w.uint32LE(5);

    const result = parseNameQueryResponse(new PacketReader(w.finish()));
    expect(result.found).toBe(true);
    expect(result.name).toBe("Xiara");
  });

  test("parses a not-found name query response", () => {
    const w = new PacketWriter();
    w.uint8(0x01);
    w.uint8(0x42);
    w.uint8(1);

    const result = parseNameQueryResponse(new PacketReader(w.finish()));
    expect(result.found).toBe(false);
  });
});

describe("buildWhoRequest / parseWhoResponse", () => {
  test("builds a who request with defaults", () => {
    const body = buildWhoRequest({});
    const r = new PacketReader(body);
    expect(r.uint32LE()).toBe(0);
    expect(r.uint32LE()).toBe(100);
    expect(r.cString()).toBe("");
    expect(r.cString()).toBe("");
  });

  test("builds a who request with name filter", () => {
    const body = buildWhoRequest({ name: "Xiara" });
    const r = new PacketReader(body);
    r.uint32LE();
    r.uint32LE();
    expect(r.cString()).toBe("Xiara");
  });

  test("parses a who response", () => {
    const w = new PacketWriter();
    w.uint32LE(1);
    w.uint32LE(1);
    w.cString("Xiara");
    w.cString("TestGuild");
    w.uint32LE(80);
    w.uint32LE(5);
    w.uint32LE(1);
    w.uint8(0);
    w.uint32LE(1);

    const results = parseWhoResponse(new PacketReader(w.finish()));
    expect(results).toHaveLength(1);
    expect(results[0]!.name).toBe("Xiara");
    expect(results[0]!.guild).toBe("TestGuild");
    expect(results[0]!.level).toBe(80);
  });

  test("parses an empty who response", () => {
    const w = new PacketWriter();
    w.uint32LE(0);
    w.uint32LE(0);

    const results = parseWhoResponse(new PacketReader(w.finish()));
    expect(results).toHaveLength(0);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `mise test`
Expected: FAIL — cannot resolve `protocol/chat`

**Step 3: Write minimal implementation**

Create `src/protocol/chat.ts`:

```typescript
import { PacketReader, PacketWriter } from "protocol/packet";
import { ChatType } from "protocol/opcodes";

export type ChatMessage = {
  type: number;
  language: number;
  senderGuidLow: number;
  senderGuidHigh: number;
  message: string;
  channel?: string;
};

export type NameQueryResult = {
  found: boolean;
  name?: string;
};

export type WhoResult = {
  name: string;
  guild: string;
  level: number;
  classId: number;
  race: number;
  gender: number;
  zone: number;
};

export function parseChatMessage(r: PacketReader): ChatMessage {
  const type = r.uint8();
  const language = r.uint32LE();
  const senderGuidLow = r.uint32LE();
  const senderGuidHigh = r.uint32LE();
  r.uint32LE();

  let channel: string | undefined;
  if (type === ChatType.CHANNEL) {
    channel = r.cString();
  }

  r.uint32LE();
  r.uint32LE();
  const messageLength = r.uint32LE();
  const messageBytes = r.bytes(messageLength);
  const message = new TextDecoder().decode(messageBytes);
  r.uint8();

  return { type, language, senderGuidLow, senderGuidHigh, message, channel };
}

export function buildChatMessage(
  type: number,
  message: string,
  target?: string,
): Uint8Array {
  const w = new PacketWriter();
  w.uint32LE(type);
  w.uint32LE(0);
  if (type === ChatType.WHISPER || type === ChatType.CHANNEL) {
    w.cString(target ?? "");
  }
  w.cString(message);
  return w.finish();
}

export function buildNameQuery(guidLow: number, guidHigh: number): Uint8Array {
  const w = new PacketWriter();
  w.uint32LE(guidLow);
  w.uint32LE(guidHigh);
  return w.finish();
}

export function parseNameQueryResponse(r: PacketReader): NameQueryResult {
  r.packedGuid();
  const notFound = r.uint8();
  if (notFound) return { found: false };
  const name = r.cString();
  return { found: true, name };
}

export function buildWhoRequest(opts: {
  name?: string;
  minLevel?: number;
  maxLevel?: number;
}): Uint8Array {
  const w = new PacketWriter();
  w.uint32LE(opts.minLevel ?? 0);
  w.uint32LE(opts.maxLevel ?? 100);
  w.cString(opts.name ?? "");
  w.cString("");
  w.uint32LE(0xffffffff);
  w.uint32LE(0xffffffff);
  w.uint32LE(0);
  w.uint32LE(0);
  return w.finish();
}

export function parseWhoResponse(r: PacketReader): WhoResult[] {
  const displayCount = r.uint32LE();
  r.uint32LE();
  const results: WhoResult[] = [];
  for (let i = 0; i < displayCount; i++) {
    results.push({
      name: r.cString(),
      guild: r.cString(),
      level: r.uint32LE(),
      classId: r.uint32LE(),
      race: r.uint32LE(),
      gender: r.uint8(),
      zone: r.uint32LE(),
    });
  }
  return results;
}
```

**Step 4: Run test to verify it passes**

Run: `mise test`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/protocol/chat.ts src/protocol/chat.test.ts
git commit -m "Add chat protocol parsers and builders

Pure functions for SMSG/CMSG_MESSAGE_CHAT (all chat types including
channel), CMSG_NAME_QUERY/SMSG_NAME_QUERY_RESPONSE (packed GUID),
and CMSG_WHO/SMSG_WHO. Tested with hand-built packet fixtures."
```

**Note:** No live testing yet — these are pure parsers/builders with no server interaction. Live testing starts in Task 4 once they're wired into WorldHandle.

---

### Task 4: Extend WorldHandle with Chat API

**Files:**

- Modify: `src/client.ts`

This is the session layer. Wire chat dispatch handlers into WorldConn, extend WorldHandle with send methods and the onMessage callback.

**Step 1: Add imports and types**

Add to the top of `src/client.ts`, alongside existing imports:

```typescript
import {
  parseChatMessage,
  buildChatMessage,
  buildNameQuery,
  parseNameQueryResponse,
  buildWhoRequest,
  parseWhoResponse,
  type ChatMessage as RawChatMessage,
  type WhoResult,
} from "protocol/chat";
import { ChatType } from "protocol/opcodes";
```

Re-export the WhoResult type and add a ChatMessage type for consumers:

```typescript
export type ChatMessage = {
  type: number;
  sender: string;
  message: string;
  channel?: string;
};

export type { WhoResult };
```

**Step 2: Extend WorldConn**

Add to the `WorldConn` type:

```typescript
type WorldConn = {
  socket: Socket;
  dispatch: OpcodeDispatch;
  buf: AccumulatorBuffer;
  arc4?: Arc4;
  startTime: number;
  pendingHeader?: { size: number; opcode: number };
  nameCache: Map<number, string>;
  pendingMessages: Map<number, RawChatMessage[]>;
  onMessage?: (msg: ChatMessage) => void;
};
```

Update the conn initialization in `worldSession` to include:

```typescript
nameCache: new Map(),
pendingMessages: new Map(),
```

**Step 3: Add chat handler functions**

Add these helper functions to `src/client.ts`:

```typescript
function deliverMessage(
  conn: WorldConn,
  raw: RawChatMessage,
  name: string,
): void {
  conn.onMessage?.({
    type: raw.type,
    sender: name,
    message: raw.message,
    channel: raw.channel,
  });
}

function handleChatMessage(conn: WorldConn, r: PacketReader): void {
  const raw = parseChatMessage(r);

  if (raw.senderGuidLow === 0) {
    deliverMessage(conn, raw, "");
    return;
  }

  const cached = conn.nameCache.get(raw.senderGuidLow);
  if (cached !== undefined) {
    deliverMessage(conn, raw, cached);
    return;
  }

  const pending = conn.pendingMessages.get(raw.senderGuidLow);
  if (pending) {
    pending.push(raw);
  } else {
    conn.pendingMessages.set(raw.senderGuidLow, [raw]);
    const w = new PacketWriter();
    w.uint32LE(raw.senderGuidLow);
    w.uint32LE(raw.senderGuidHigh);
    sendPacket(conn, GameOpcode.CMSG_NAME_QUERY, w.finish());
  }
}

function handleNameQueryResponse(conn: WorldConn, r: PacketReader): void {
  const result = parseNameQueryResponse(r);
  if (!result.found || !result.name) return;

  const name = result.name;

  for (const [guidLow, messages] of conn.pendingMessages) {
    const cached = conn.nameCache.get(guidLow);
    if (cached !== undefined) continue;

    conn.nameCache.set(guidLow, name);
    for (const raw of messages) deliverMessage(conn, raw, name);
    conn.pendingMessages.delete(guidLow);
    break;
  }
}

function handlePlayerNotFound(conn: WorldConn, r: PacketReader): void {
  const name = r.cString();
  conn.onMessage?.({
    type: ChatType.SYSTEM,
    sender: "",
    message: `No player named "${name}" is currently playing.`,
  });
}
```

**Step 4: Register dispatch handlers**

In the `worldSession` function, after the existing `SMSG_TIME_SYNC_REQ` handler registration, add:

```typescript
conn.dispatch.on(GameOpcode.SMSG_MESSAGE_CHAT, (r) =>
  handleChatMessage(conn, r),
);
conn.dispatch.on(GameOpcode.SMSG_GM_MESSAGECHAT, (r) =>
  handleChatMessage(conn, r),
);
conn.dispatch.on(GameOpcode.SMSG_NAME_QUERY_RESPONSE, (r) =>
  handleNameQueryResponse(conn, r),
);
conn.dispatch.on(GameOpcode.SMSG_CHAT_PLAYER_NOT_FOUND, (r) =>
  handlePlayerNotFound(conn, r),
);
```

**Step 5: Extend WorldHandle**

Update the `WorldHandle` type:

```typescript
export type WorldHandle = {
  closed: Promise<void>;
  close(): void;
  onMessage(cb: (msg: ChatMessage) => void): void;
  sendWhisper(target: string, message: string): void;
  sendSay(message: string): void;
  sendYell(message: string): void;
  sendGuild(message: string): void;
  sendParty(message: string): void;
  sendRaid(message: string): void;
  sendChannel(channel: string, message: string): void;
  who(opts?: {
    name?: string;
    minLevel?: number;
    maxLevel?: number;
  }): Promise<WhoResult[]>;
};
```

Update the resolve call in `worldSession` to return the full handle:

```typescript
resolve({
  closed,
  close() {
    clearInterval(pingInterval);
    conn.socket.end();
  },
  onMessage(cb) {
    conn.onMessage = cb;
  },
  sendWhisper(target, message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.WHISPER, message, target),
    );
  },
  sendSay(message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.SAY, message),
    );
  },
  sendYell(message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.YELL, message),
    );
  },
  sendGuild(message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.GUILD, message),
    );
  },
  sendParty(message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.PARTY, message),
    );
  },
  sendRaid(message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.RAID, message),
    );
  },
  sendChannel(channel, message) {
    sendPacket(
      conn,
      GameOpcode.CMSG_MESSAGE_CHAT,
      buildChatMessage(ChatType.CHANNEL, message, channel),
    );
  },
  async who(opts = {}) {
    sendPacket(conn, GameOpcode.CMSG_WHO, buildWhoRequest(opts));
    const r = await conn.dispatch.expect(GameOpcode.SMSG_WHO);
    return parseWhoResponse(r);
  },
});
```

**Step 6: Run typecheck and existing tests**

Run: `mise typecheck && mise test`
Expected: All PASS — no existing behavior changed

**Step 7: Commit**

```bash
git add src/client.ts
git commit -m "Extend WorldHandle with chat, name query, and who

Adds onMessage callback, send methods for all chat types, GUID-to-name
cache with async resolution via CMSG_NAME_QUERY, and a promise-based
who() method. Pending messages queue behind name lookups and flush when
the response arrives."
```

**Step 8: Live test — whisper between two clients**

Add a two-client whisper test to `src/test/live.ts`. Both accounts log in, client 1 whispers client 2, client 2 verifies receipt with the correct sender name. Also test `who()`. Run `mise test:live` and iterate until it passes. The packet formats from the reference codebase may need adjustment — use the live server as the source of truth. Debug freely; this is the primary feedback loop.

```typescript
describe("two-client chat", () => {
  test("whisper between two characters", async () => {
    const auth1 = await authHandshake(config1);
    const auth2 = await authHandshake(config2);

    const handle1 = await worldSession(config1, auth1);
    const handle2 = await worldSession(config2, auth2);

    await Bun.sleep(1000);

    const received: ChatMessage[] = [];
    handle2.onMessage((msg) => received.push(msg));

    handle1.sendWhisper(config2.character, "hello from client 1");

    await Bun.sleep(3000);

    handle1.close();
    handle2.close();
    await Promise.all([handle1.closed, handle2.closed]);

    const whisper = received.find((m) => m.message === "hello from client 1");
    expect(whisper).toBeDefined();
    expect(whisper!.sender).toBe(config1.character);
  }, 30_000);

  test("who query returns results", async () => {
    const auth1 = await authHandshake(config1);
    const handle1 = await worldSession(config1, auth1);

    await Bun.sleep(1000);

    const results = await handle1.who({});
    expect(results.length).toBeGreaterThan(0);

    handle1.close();
    await handle1.closed;
  }, 30_000);
});
```

Import `ChatMessage` from `client` at the top of `live.ts`.

**Step 9: Commit live tests**

```bash
git add src/test/live.ts
git commit -m "Add two-client live chat tests

Logs in two characters, sends a whisper from one to the other, and
verifies the message arrives with the correct sender name via GUID
resolution. Also tests /who queries."
```

---

### Task 5: TUI Layer

**Files:**

- Create: `src/tui.ts`
- Create: `src/tui.test.ts`

**Step 1: Write the failing tests for command parsing**

Create `src/tui.test.ts`:

```typescript
import { test, expect, describe } from "bun:test";
import { parseCommand } from "tui";

describe("parseCommand", () => {
  test("bare text becomes say", () => {
    expect(parseCommand("hello")).toEqual({ type: "say", message: "hello" });
  });

  test("/s sends say", () => {
    expect(parseCommand("/s hello")).toEqual({ type: "say", message: "hello" });
  });

  test("/say sends say", () => {
    expect(parseCommand("/say hello there")).toEqual({
      type: "say",
      message: "hello there",
    });
  });

  test("/w sends whisper", () => {
    expect(parseCommand("/w Xiara follow me")).toEqual({
      type: "whisper",
      target: "Xiara",
      message: "follow me",
    });
  });

  test("/whisper sends whisper", () => {
    expect(parseCommand("/whisper Xiara hi")).toEqual({
      type: "whisper",
      target: "Xiara",
      message: "hi",
    });
  });

  test("/r sends reply", () => {
    expect(parseCommand("/r hello")).toEqual({
      type: "reply",
      message: "hello",
    });
  });

  test("/g sends guild", () => {
    expect(parseCommand("/g hello guild")).toEqual({
      type: "guild",
      message: "hello guild",
    });
  });

  test("/guild sends guild", () => {
    expect(parseCommand("/guild hi")).toEqual({
      type: "guild",
      message: "hi",
    });
  });

  test("/y sends yell", () => {
    expect(parseCommand("/y HELLO")).toEqual({
      type: "yell",
      message: "HELLO",
    });
  });

  test("/p sends party", () => {
    expect(parseCommand("/p inv")).toEqual({ type: "party", message: "inv" });
  });

  test("/party sends party", () => {
    expect(parseCommand("/party inv")).toEqual({
      type: "party",
      message: "inv",
    });
  });

  test("/raid sends raid", () => {
    expect(parseCommand("/raid pull")).toEqual({
      type: "raid",
      message: "pull",
    });
  });

  test("/1 sends channel 1", () => {
    expect(parseCommand("/1 hello general")).toEqual({
      type: "channel",
      target: "1",
      message: "hello general",
    });
  });

  test("/2 sends channel 2", () => {
    expect(parseCommand("/2 lfg")).toEqual({
      type: "channel",
      target: "2",
      message: "lfg",
    });
  });

  test("/who sends who query", () => {
    expect(parseCommand("/who")).toEqual({ type: "who" });
  });

  test("/who with name filter", () => {
    expect(parseCommand("/who Xiara")).toEqual({
      type: "who",
      target: "Xiara",
    });
  });

  test("/quit sends quit", () => {
    expect(parseCommand("/quit")).toEqual({ type: "quit" });
  });

  test("empty string becomes say with empty message", () => {
    expect(parseCommand("")).toEqual({ type: "say", message: "" });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `mise test`
Expected: FAIL — cannot resolve `tui`

**Step 3: Write the TUI implementation**

Create `src/tui.ts`:

```typescript
import { createInterface } from "node:readline";
import { ChatType } from "protocol/opcodes";
import type { WorldHandle, ChatMessage } from "client";

export type Command =
  | { type: "say"; message: string }
  | { type: "yell"; message: string }
  | { type: "guild"; message: string }
  | { type: "party"; message: string }
  | { type: "raid"; message: string }
  | { type: "whisper"; target: string; message: string }
  | { type: "reply"; message: string }
  | { type: "channel"; target: string; message: string }
  | { type: "who"; target?: string }
  | { type: "quit" };

export function parseCommand(input: string): Command {
  if (!input.startsWith("/")) return { type: "say", message: input };

  const spaceIdx = input.indexOf(" ");
  const cmd = spaceIdx === -1 ? input : input.slice(0, spaceIdx);
  const rest = spaceIdx === -1 ? "" : input.slice(spaceIdx + 1);

  switch (cmd) {
    case "/s":
    case "/say":
      return { type: "say", message: rest };
    case "/y":
    case "/yell":
      return { type: "yell", message: rest };
    case "/g":
    case "/guild":
      return { type: "guild", message: rest };
    case "/p":
    case "/party":
      return { type: "party", message: rest };
    case "/raid":
      return { type: "raid", message: rest };
    case "/w":
    case "/whisper": {
      const targetEnd = rest.indexOf(" ");
      if (targetEnd === -1)
        return { type: "whisper", target: rest, message: "" };
      return {
        type: "whisper",
        target: rest.slice(0, targetEnd),
        message: rest.slice(targetEnd + 1),
      };
    }
    case "/r":
      return { type: "reply", message: rest };
    case "/who":
      return rest ? { type: "who", target: rest } : { type: "who" };
    case "/quit":
      return { type: "quit" };
    default: {
      const channelMatch = cmd.match(/^\/(\d+)$/);
      if (channelMatch) {
        return { type: "channel", target: channelMatch[1]!, message: rest };
      }
      return { type: "say", message: input };
    }
  }
}

const CHAT_TYPE_LABELS: Record<number, string> = {
  [ChatType.SYSTEM]: "system",
  [ChatType.SAY]: "say",
  [ChatType.PARTY]: "party",
  [ChatType.RAID]: "raid",
  [ChatType.GUILD]: "guild",
  [ChatType.OFFICER]: "officer",
  [ChatType.YELL]: "yell",
  [ChatType.WHISPER]: "whisper from",
  [ChatType.WHISPER_INFORM]: "whisper to",
  [ChatType.EMOTE]: "emote",
  [ChatType.CHANNEL]: "channel",
  [ChatType.RAID_LEADER]: "raid leader",
  [ChatType.RAID_WARNING]: "raid warning",
  [ChatType.PARTY_LEADER]: "party leader",
};

function formatMessage(msg: ChatMessage, interactive: boolean): string {
  if (!interactive) {
    const label =
      CHAT_TYPE_LABELS[msg.type]?.toUpperCase().replace(/ /g, "_") ??
      `TYPE_${msg.type}`;
    return `${label}\t${msg.sender}\t${msg.message}`;
  }

  const label = CHAT_TYPE_LABELS[msg.type] ?? `type ${msg.type}`;

  if (msg.type === ChatType.WHISPER) {
    return `[whisper from ${msg.sender}] ${msg.message}`;
  }
  if (msg.type === ChatType.WHISPER_INFORM) {
    return `[whisper to ${msg.sender}] ${msg.message}`;
  }
  if (msg.type === ChatType.SYSTEM) {
    return `[system] ${msg.message}`;
  }
  if (msg.type === ChatType.CHANNEL && msg.channel) {
    return `[${msg.channel}] ${msg.sender}: ${msg.message}`;
  }
  return `[${label}] ${msg.sender}: ${msg.message}`;
}

export function startTui(
  handle: WorldHandle,
  interactive: boolean,
): Promise<void> {
  return new Promise<void>((resolve) => {
    let lastWhisperFrom: string | undefined;

    handle.onMessage((msg) => {
      if (msg.type === ChatType.WHISPER) {
        lastWhisperFrom = msg.sender;
      }

      const line = formatMessage(msg, interactive);

      if (interactive) {
        process.stdout.write(`\r\x1b[K${line}\n`);
        rl.prompt(true);
      } else {
        process.stdout.write(line + "\n");
      }
    });

    const rl = createInterface({
      input: process.stdin,
      output: interactive ? process.stdout : undefined,
      prompt: interactive ? "> " : "",
      terminal: interactive,
    });

    if (interactive) rl.prompt();

    rl.on("line", async (input) => {
      const cmd = parseCommand(input.trim());

      switch (cmd.type) {
        case "say":
          handle.sendSay(cmd.message);
          break;
        case "yell":
          handle.sendYell(cmd.message);
          break;
        case "guild":
          handle.sendGuild(cmd.message);
          break;
        case "party":
          handle.sendParty(cmd.message);
          break;
        case "raid":
          handle.sendRaid(cmd.message);
          break;
        case "whisper":
          handle.sendWhisper(cmd.target, cmd.message);
          lastWhisperFrom = cmd.target;
          break;
        case "reply":
          if (!lastWhisperFrom) {
            const errLine = interactive
              ? "[system] No one has whispered you yet."
              : "SYSTEM\t\tNo one has whispered you yet.";
            process.stdout.write(errLine + "\n");
          } else {
            handle.sendWhisper(lastWhisperFrom, cmd.message);
          }
          break;
        case "channel":
          handle.sendChannel(cmd.target, cmd.message);
          break;
        case "who": {
          const results = await handle.who(
            cmd.target ? { name: cmd.target } : {},
          );
          const line = interactive
            ? `[who] ${results.length} results: ${results.map((r) => `${r.name} (${r.level})`).join(", ") || "none"}`
            : results
                .map((r) => `WHO\t${r.name}\t${r.level}\t${r.guild}`)
                .join("\n") || "WHO\t\t0\t";
          process.stdout.write(line + "\n");
          break;
        }
        case "quit":
          handle.close();
          rl.close();
          resolve();
          return;
      }

      if (interactive) rl.prompt();
    });

    rl.on("close", () => {
      resolve();
    });

    handle.closed.then(() => {
      rl.close();
    });
  });
}
```

**Step 4: Run test to verify it passes**

Run: `mise test`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/tui.ts src/tui.test.ts
git commit -m "Add TUI layer with command parsing and message display

Interactive mode uses node:readline with a prompt. Pipe mode reads raw
stdin lines and writes tab-delimited output. Supports /w, /s, /y, /g,
/p, /raid, /r (reply), /1-/9 (channels), /who, /quit. Bare text is
sent as say."
```

---

### Task 6: Update Entry Point

**Files:**

- Modify: `src/index.ts`

**Step 1: Wire in the TUI**

Replace the current `index.ts` content:

```typescript
import { parseArgs } from "node:util";
import { authHandshake, worldSession } from "client";
import { startTui } from "tui";

const { values } = parseArgs({
  args: Bun.argv.slice(2),
  options: {
    host: { type: "string", default: "t1" },
    port: { type: "string", default: "3724" },
    account: { type: "string" },
    password: { type: "string" },
    character: { type: "string" },
  },
});

if (!values.account || !values.password || !values.character) {
  console.error(
    "Usage: bun src/index.ts --account <account> --password <password> --character <name> [--host <host>] [--port <port>]",
  );
  process.exit(1);
}

const config = {
  host: values.host!,
  port: parseInt(values.port!, 10),
  account: values.account.toUpperCase(),
  password: values.password.toUpperCase(),
  character: values.character,
};

async function main() {
  console.log(
    `Connecting to ${config.host}:${config.port} as ${config.account}...`,
  );
  const auth = await authHandshake(config);
  console.log(`Authenticated. Realm: ${auth.realmHost}:${auth.realmPort}`);
  const handle = await worldSession(config, auth);
  console.log(`Logged in as ${config.character}.`);
  await startTui(handle, process.stdin.isTTY ?? false);
}

main().catch((err) => {
  console.error(err.message ?? err);
  process.exit(1);
});
```

**Step 2: Run typecheck**

Run: `mise typecheck`
Expected: PASS

**Step 3: Commit**

```bash
git add src/index.ts
git commit -m "Wire TUI into the entry point

After auth and world login, starts the TUI in interactive or pipe mode
based on isTTY detection. Replaces the bare await handle.closed with
the full chat interface."
```

---

### Task 7: Expand Live Test Coverage

**Files:**

- Modify: `src/test/live.ts`

The core whisper and who tests were added in Task 4 Step 8. Now expand live test coverage to exercise say (both clients nearby), player-not-found errors, and any other chat types that are practical to test. Use `mise test:live` as the feedback loop. Iterate freely.

**Step 1: Add additional live tests**

Add tests for:

- `sendSay` — client 1 says something, client 2 (if nearby) receives it
- Whisper to a nonexistent player — verify player-not-found message arrives
- Any other chat types that are easy to verify (guild if both characters are in the same guild, etc.)

**Step 2: Run and iterate**

Run: `mise test:live`
Iterate until all pass. Fix any protocol issues discovered.

**Step 3: Commit**

```bash
git add src/test/live.ts
git commit -m "Expand live chat test coverage

Adds say, player-not-found, and additional chat type tests alongside
the existing whisper and who tests."
```

---

### Task 8: Mock Server Integration Tests

**Files:**

- Modify: `src/test/mock-world-server.ts`
- Modify: `src/client.test.ts`

After live testing confirms the protocol works, encode the behavior in mock tests.

**Step 1: Extend mock world server**

Add chat message handling to `src/test/mock-world-server.ts`. The mock server needs to:

1. Handle `CMSG_MESSAGE_CHAT` — echo it back as `SMSG_MESSAGE_CHAT`
2. Handle `CMSG_NAME_QUERY` — respond with a canned name
3. Handle `CMSG_WHO` — respond with a canned result

Add these handler functions and wire them into `handlePacket`:

```typescript
function handleMessageChat(socket: Socket<ConnState>, body: Uint8Array): void {
  const r = new PacketReader(body);
  const chatType = r.uint32LE();
  r.uint32LE();
  let target = "";
  if (chatType === 0x07 || chatType === 0x11) {
    target = r.cString();
  }
  const message = r.cString();

  const w = new PacketWriter();
  w.uint8(chatType);
  w.uint32LE(0);
  w.uint32LE(0x42);
  w.uint32LE(0x00);
  w.uint32LE(0);
  if (chatType === 0x11) w.cString(target);
  w.uint32LE(0x42);
  w.uint32LE(0x00);
  const msgBytes = new TextEncoder().encode(message);
  w.uint32LE(msgBytes.byteLength);
  w.rawBytes(msgBytes);
  w.uint8(0);
  send(socket, 0x0096, w.finish());
}

function handleNameQuery(socket: Socket<ConnState>): void {
  const w = new PacketWriter();
  w.uint8(0x01);
  w.uint8(0x42);
  w.uint8(0);
  w.cString(FIXTURE_CHARACTER);
  w.cString("");
  w.uint32LE(1);
  w.uint32LE(0);
  w.uint32LE(1);
  send(socket, 0x0051, w.finish());
}

function handleWho(socket: Socket<ConnState>): void {
  const w = new PacketWriter();
  w.uint32LE(1);
  w.uint32LE(1);
  w.cString(FIXTURE_CHARACTER);
  w.cString("");
  w.uint32LE(10);
  w.uint32LE(1);
  w.uint32LE(1);
  w.uint8(0);
  w.uint32LE(1);
  send(socket, 0x0063, w.finish());
}
```

Add to `handlePacket`'s dispatch:

```typescript
else if (opcode === 0x0095) handleMessageChat(socket, body);
else if (opcode === 0x0050) handleNameQuery(socket);
else if (opcode === 0x0062) handleWho(socket);
```

**Step 2: Add chat integration tests**

Add to `src/client.test.ts`:

```typescript
test("sendWhisper sends message and receives echo", async () => {
  const { port, stop } = await startMockWorldServer();
  try {
    const auth = await authHandshake(mockConfig(port));
    const handle = await worldSession(mockConfig(port), auth);

    const received: ChatMessage[] = [];
    handle.onMessage((msg) => received.push(msg));

    handle.sendWhisper("Someone", "test whisper");
    await Bun.sleep(500);

    expect(received.length).toBeGreaterThan(0);

    handle.close();
    await handle.closed;
  } finally {
    stop();
  }
});

test("who returns results from mock server", async () => {
  const { port, stop } = await startMockWorldServer();
  try {
    const auth = await authHandshake(mockConfig(port));
    const handle = await worldSession(mockConfig(port), auth);

    const results = await handle.who({});
    expect(results.length).toBe(1);
    expect(results[0]!.name).toBe(FIXTURE_CHARACTER);

    handle.close();
    await handle.closed;
  } finally {
    stop();
  }
});
```

Import `ChatMessage` at the top of `client.test.ts` alongside the existing imports.

**Step 3: Run all tests**

Run: `mise test`
Expected: All tests PASS (unit + mock integration)

**Step 4: Commit**

```bash
git add src/test/mock-world-server.ts src/client.test.ts
git commit -m "Add mock server chat handlers and integration tests

The mock world server now handles CMSG_MESSAGE_CHAT (echoes back),
CMSG_NAME_QUERY (canned response), and CMSG_WHO (canned response).
Integration tests verify sendWhisper + onMessage and who() through
the full stack."
```

---

### Task 9: Final Verification

**Step 1: Run full test suite**

Run: `mise test`
Expected: All tests PASS

**Step 2: Run typecheck**

Run: `mise typecheck`
Expected: PASS

**Step 3: Run live tests**

Run: `mise test:live`
Expected: All live tests PASS

**Step 4: Manual smoke test**

Run: `mise start -- --account XI --password <password> --character Xi`

Try:

- Type `hello` (should send as say)
- Type `/w <character2> test` (should send whisper)
- Type `/who` (should show results)
- Type `/quit` (should exit cleanly)

**Step 5: Final commit if any fixups needed**

If any fixes were made during verification, commit them.
